<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_Start/index.html"><strong aria-hidden="true">1.</strong> React ile Başlarken</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_Start/01_React.html"><strong aria-hidden="true">1.1.</strong> React</a></li><li class="chapter-item expanded "><a href="01_Start/02_Introduction.html"><strong aria-hidden="true">1.2.</strong> Giriş</a></li><li class="chapter-item expanded "><a href="01_Start/03_Virtual-DOM.html"><strong aria-hidden="true">1.3.</strong> Sanal DOM</a></li><li class="chapter-item expanded "><a href="01_Start/04_SPA-MPA.html"><strong aria-hidden="true">1.4.</strong> SPA vs. MPA</a></li><li class="chapter-item expanded "><a href="01_Start/05_Setting-Up.html"><strong aria-hidden="true">1.5.</strong> Kurulum</a></li><li class="chapter-item expanded "><a href="01_Start/06_Installation.html"><strong aria-hidden="true">1.6.</strong> Yükleme</a></li><li class="chapter-item expanded "><a href="01_Start/07_File-Structure.html"><strong aria-hidden="true">1.7.</strong> Dosya Yapısı</a></li><li class="chapter-item expanded "><a href="01_Start/08_Assignment.html"><strong aria-hidden="true">1.8.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="02_Components/index.html"><strong aria-hidden="true">2.</strong> Bileşenleri Anlamak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_Components/01_Components.html"><strong aria-hidden="true">2.1.</strong> Bileşenler</a></li><li class="chapter-item expanded "><a href="02_Components/02_Rendering-Components.html"><strong aria-hidden="true">2.2.</strong> Bileşenleri Render Etme</a></li><li class="chapter-item expanded "><a href="02_Components/03_JSX.html"><strong aria-hidden="true">2.3.</strong> JSX'e Giriş</a></li><li class="chapter-item expanded "><a href="02_Components/04_Embedding-Expressions.html"><strong aria-hidden="true">2.4.</strong> İfadeleri Gömme</a></li><li class="chapter-item expanded "><a href="02_Components/05_JSX-HTML.html"><strong aria-hidden="true">2.5.</strong> JSX vs. HTML</a></li><li class="chapter-item expanded "><a href="02_Components/06_Assignment.html"><strong aria-hidden="true">2.6.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="03_Props-Components/index.html"><strong aria-hidden="true">3.</strong> Bileşenlerde Props Kullanımı</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03_Props-Components/01_Probs.html"><strong aria-hidden="true">3.1.</strong> Props</a></li><li class="chapter-item expanded "><a href="03_Props-Components/02_Usage.html"><strong aria-hidden="true">3.2.</strong> Kullanım</a></li><li class="chapter-item expanded "><a href="03_Props-Components/03_Assignment.html"><strong aria-hidden="true">3.3.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="04_Styling-Media/index.html"><strong aria-hidden="true">4.</strong> Stil ve Medya</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04_Styling-Media/01_Tailwind-Install.html"><strong aria-hidden="true">4.1.</strong> React'te Tailwind Kurulumu (Vite)</a></li><li class="chapter-item expanded "><a href="04_Styling-Media/02_Image.html"><strong aria-hidden="true">4.2.</strong> Resim Kullanımı</a></li><li class="chapter-item expanded "><a href="04_Styling-Media/03_React-Icon.html"><strong aria-hidden="true">4.3.</strong> React İkon</a></li><li class="chapter-item expanded "><a href="04_Styling-Media/04_Assignment.html"><strong aria-hidden="true">4.4.</strong> Görev</a></li><li class="chapter-item expanded "><a href="04_Styling-Media/05_Render-Multiple.html"><strong aria-hidden="true">4.5.</strong> Birden Çok Bileşeni Render Etme</a></li><li class="chapter-item expanded "><a href="04_Styling-Media/06_Styling.html"><strong aria-hidden="true">4.6.</strong> Stil</a></li><li class="chapter-item expanded "><a href="04_Styling-Media/07_Inline-Styles.html"><strong aria-hidden="true">4.7.</strong> Satır İçi Stiller</a></li><li class="chapter-item expanded "><a href="04_Styling-Media/08_External-Stylesheets.html"><strong aria-hidden="true">4.8.</strong> Harici Stil Sayfaları</a></li><li class="chapter-item expanded "><a href="04_Styling-Media/09_CSS-Modules.html"><strong aria-hidden="true">4.9.</strong> CSS Modülleri</a></li><li class="chapter-item expanded "><a href="04_Styling-Media/10_React-Styling.html"><strong aria-hidden="true">4.10.</strong> React Stil Kütüphaneleri</a></li><li class="chapter-item expanded "><a href="04_Styling-Media/11_Assignment.html"><strong aria-hidden="true">4.11.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="05_Hooks/index.html"><strong aria-hidden="true">5.</strong> Kancalara Giriş</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05_Hooks/01_Hooks.html"><strong aria-hidden="true">5.1.</strong> Hooks</a></li><li class="chapter-item expanded "><a href="05_Hooks/02_useState.html"><strong aria-hidden="true">5.2.</strong> useState</a></li><li class="chapter-item expanded "><a href="05_Hooks/03_Data-Flows-Down.html"><strong aria-hidden="true">5.3.</strong> Veri Aşağı Akışı</a></li><li class="chapter-item expanded "><a href="05_Hooks/04_Assignment.html"><strong aria-hidden="true">5.4.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="06_Effects/index.html"><strong aria-hidden="true">6.</strong> Etkilerle Çalışmak</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_Effects/01_useEffect.html"><strong aria-hidden="true">6.1.</strong> useEffect</a></li><li class="chapter-item expanded "><a href="06_Effects/02_Dependancy-Array.html"><strong aria-hidden="true">6.2.</strong> Bağımlılık Dizisi</a></li><li class="chapter-item expanded "><a href="06_Effects/03_Effect-Cleanup.html"><strong aria-hidden="true">6.3.</strong> Etki Temizleme</a></li><li class="chapter-item expanded "><a href="06_Effects/04_Assignment.html"><strong aria-hidden="true">6.4.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/index.html"><strong aria-hidden="true">7.</strong> Dinamik Render</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/01_Render-Lists.html"><strong aria-hidden="true">7.1.</strong> Listeleri Render Etme</a></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/02_Conditional-Rendering.html"><strong aria-hidden="true">7.2.</strong> Koşullu Render</a></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/03_Inline-Operator.html"><strong aria-hidden="true">7.3.</strong> Satır İçi && Operatörü</a></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/04_If-Else-Pattern.html"><strong aria-hidden="true">7.4.</strong> If-Else Pattern</a></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/05_Assignment.html"><strong aria-hidden="true">7.5.</strong> Görev</a></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/06_Controlled-Uncontrolled.html"><strong aria-hidden="true">7.6.</strong> Kontrollü ve Kontrolsüz Bileşenler</a></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/07_Handle-Form.html"><strong aria-hidden="true">7.7.</strong> Formu Yönetme</a></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/08_Event-Handling.html"><strong aria-hidden="true">7.8.</strong> Etkinlik Yönetimi</a></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/09_Passing-Arguments.html"><strong aria-hidden="true">7.9.</strong> Argümanları Geçme</a></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/10_Commont-Events.html"><strong aria-hidden="true">7.10.</strong> Yaygın Etkinlikler</a></li><li class="chapter-item expanded "><a href="07_Dynamic-Rendering/11_Assignment.html"><strong aria-hidden="true">7.11.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="08_Routing/index.html"><strong aria-hidden="true">8.</strong> React'te Yönlendirme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08_Routing/01_React-Router.html"><strong aria-hidden="true">8.1.</strong> React Router</a></li><li class="chapter-item expanded "><a href="08_Routing/02_Set-Up.html"><strong aria-hidden="true">8.2.</strong> Kurulum</a></li><li class="chapter-item expanded "><a href="08_Routing/03_React-Router-Basics.html"><strong aria-hidden="true">8.3.</strong> React Router Temelleri</a></li><li class="chapter-item expanded "><a href="08_Routing/04_Nested-Route.html"><strong aria-hidden="true">8.4.</strong> İç İçe Rota</a></li><li class="chapter-item expanded "><a href="08_Routing/05_Assignment.html"><strong aria-hidden="true">8.5.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="09_Class-Component/index.html"><strong aria-hidden="true">9.</strong> React'te Sınıf Bileşenleri</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="09_Class-Component/01_Intro.html"><strong aria-hidden="true">9.1.</strong> Sınıf Bileşenlerine Giriş</a></li><li class="chapter-item expanded "><a href="09_Class-Component/02_Component-Constructor.html"><strong aria-hidden="true">9.2.</strong> Bileşen Kurucusu</a></li><li class="chapter-item expanded "><a href="09_Class-Component/03_Functional-vs-Class.html"><strong aria-hidden="true">9.3.</strong> Fonksiyonel vs. Sınıf Bileşenleri</a></li><li class="chapter-item expanded "><a href="09_Class-Component/04_Probs-Class.html"><strong aria-hidden="true">9.4.</strong> Sınıf Bileşenlerinde Props</a></li><li class="chapter-item expanded "><a href="09_Class-Component/05_State-Class.html"><strong aria-hidden="true">9.5.</strong> Sınıf Bileşenlerinde Durum</a></li><li class="chapter-item expanded "><a href="09_Class-Component/06_Assignment.html"><strong aria-hidden="true">9.6.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="10_Lifecycle/index.html"><strong aria-hidden="true">10.</strong> React Yaşam Döngüsü Metodları</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10_Lifecycle/01_Intro.html"><strong aria-hidden="true">10.1.</strong> React Yaşam Döngüsüne Giriş</a></li><li class="chapter-item expanded "><a href="10_Lifecycle/02_Mounting.html"><strong aria-hidden="true">10.2.</strong> Montaj</a></li><li class="chapter-item expanded "><a href="10_Lifecycle/03_Demonstrate.html"><strong aria-hidden="true">10.3.</strong> Montajı Gösterme</a></li><li class="chapter-item expanded "><a href="10_Lifecycle/04_Updating.html"><strong aria-hidden="true">10.4.</strong> Güncelleme</a></li><li class="chapter-item expanded "><a href="10_Lifecycle/05_Unmounting.html"><strong aria-hidden="true">10.5.</strong> Sökme</a></li><li class="chapter-item expanded "><a href="10_Lifecycle/06_Assignment.html"><strong aria-hidden="true">10.6.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="11_State-Management/index.html"><strong aria-hidden="true">11.</strong> React'te Durum Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="11_State-Management/01_Prob-Drilling.html"><strong aria-hidden="true">11.1.</strong> Props Delme</a></li><li class="chapter-item expanded "><a href="11_State-Management/02_Context-API.html"><strong aria-hidden="true">11.2.</strong> React Context API</a></li><li class="chapter-item expanded "><a href="11_State-Management/03_Assignment.html"><strong aria-hidden="true">11.3.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="12_Higher-Order/index.html"><strong aria-hidden="true">12.</strong> Yüksek Dereceli Bileşenler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="12_Higher-Order/01_High-Order.html"><strong aria-hidden="true">12.1.</strong> Yüksek Dereceli Bileşenler</a></li><li class="chapter-item expanded "><a href="12_Higher-Order/02_Use-Cases.html"><strong aria-hidden="true">12.2.</strong> Yüksek Dereceli Bileşenlerin Kullanım Alanları</a></li><li class="chapter-item expanded "><a href="12_Higher-Order/03_Creation-HOCs.html"><strong aria-hidden="true">12.3.</strong> Yüksek Dereceli Bileşenler Oluşturma</a></li><li class="chapter-item expanded "><a href="12_Higher-Order/04_Assignment.html"><strong aria-hidden="true">12.4.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="13_Error-Handling/index.html"><strong aria-hidden="true">13.</strong> React'te Hata Yönetimi</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="13_Error-Handling/01_Error-Boundaries.html"><strong aria-hidden="true">13.1.</strong> Hata Sınırları</a></li><li class="chapter-item expanded "><a href="13_Error-Handling/02_Use-Cases.html"><strong aria-hidden="true">13.2.</strong> Hata Sınırlarının Kullanım Alanları</a></li><li class="chapter-item expanded "><a href="13_Error-Handling/03_Error-Handling.html"><strong aria-hidden="true">13.3.</strong> Hata Sınırları ile Hata Yönetimi</a></li><li class="chapter-item expanded "><a href="13_Error-Handling/04_Assignment.html"><strong aria-hidden="true">13.4.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="14_useState-useEffect/index.html"><strong aria-hidden="true">14.</strong> useState ve useEffect Ötesinde Daha Fazla Kanca</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="14_useState-useEffect/01_useReducer.html"><strong aria-hidden="true">14.1.</strong> useReducer</a></li><li class="chapter-item expanded "><a href="14_useState-useEffect/02_useCallback.html"><strong aria-hidden="true">14.2.</strong> useCallback</a></li><li class="chapter-item expanded "><a href="14_useState-useEffect/03_useMemo.html"><strong aria-hidden="true">14.3.</strong> useMemo</a></li><li class="chapter-item expanded "><a href="14_useState-useEffect/04_Assignment.html"><strong aria-hidden="true">14.4.</strong> Görev</a></li><li class="chapter-item expanded "><a href="14_useState-useEffect/05_Custom-Hooks.html"><strong aria-hidden="true">14.5.</strong> Özel Kancalar</a></li><li class="chapter-item expanded "><a href="14_useState-useEffect/06_When-Why.html"><strong aria-hidden="true">14.6.</strong> Ne Zaman ve Neden?</a></li><li class="chapter-item expanded "><a href="14_useState-useEffect/07_Assignment.html"><strong aria-hidden="true">14.7.</strong> Görev</a></li></ol></li><li class="chapter-item expanded "><a href="15_Optimization/index.html"><strong aria-hidden="true">15.</strong> React'te Performans Optimizasyonu</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="15_Optimization/01_Optimization.html"><strong aria-hidden="true">15.1.</strong> React Performans Optimizasyonu</a></li><li class="chapter-item expanded "><a href="15_Optimization/02_Common_Bottlenecks.html"><strong aria-hidden="true">15.2.</strong> Yaygın Performans Tıkanıklıkları</a></li><li class="chapter-item expanded "><a href="15_Optimization/03_Techniques.html"><strong aria-hidden="true">15.3.</strong> Optimizasyon Teknikleri</a></li><li class="chapter-item expanded "><a href="15_Optimization/04_Assignment.html"><strong aria-hidden="true">15.4.</strong> Görev</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<ul>
<li><a href="01_Start/./01_React.html">React</a></li>
<li><a href="01_Start/./02_Introduction.html">Introduction</a></li>
<li><a href="01_Start/">Virtual-DOM</a></li>
<li><a href="01_Start/">SPA vs. MPA</a></li>
<li><a href="01_Start/">Setting Up</a></li>
<li><a href="01_Start/">Installation</a></li>
<li><a href="01_Start/">File Structure</a></li>
<li><a href="01_Start/">Assignment</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-eğitimi"><a class="header" href="#react-eğitimi">React Eğitimi</a></h1>
<h2 id="giriş"><a class="header" href="#giriş">Giriş</a></h2>
<p>React, kullanıcı arayüzleri oluşturmak için kullanılan bir JavaScript kütüphanesidir ve web geliştirme dünyasında en popüler araçlardan biri haline gelmiştir. Bu eğitimde, React'in temel özelliklerini, avantajlarını ve uygulama yöntemlerini detaylı bir şekilde ele alacağız. Eğitim boyunca, iyi yapılandırılmış kod parçacıkları ile desteklenen kapsamlı açıklamalar sunulacaktır.</p>
<h2 id="1-bileşen-tabanlı-mimari-component-based-architecture"><a class="header" href="#1-bileşen-tabanlı-mimari-component-based-architecture">1. Bileşen Tabanlı Mimari (Component-Based Architecture)</a></h2>
<p>React'in en güçlü yönlerinden biri, bileşen tabanlı mimarisidir. Bu yapı, geliştiricilerin yeniden kullanılabilir kullanıcı arayüzü bileşenleri oluşturmasına olanak tanır ve bu sayede geliştirme sürecini daha verimli hale getirir. Ayrıca, kod tabanının daha kolay yönetilebilir olmasını sağlar.</p>
<p><strong>Kod Örneği: Basit Bir React Bileşeni</strong></p>
<pre><code class="language-javascript">import React from 'react';

function MerhabaDunya() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Merhaba Dünya!&lt;/h1&gt;
    &lt;/div&gt;
  );
}

export default MerhabaDunya;
</code></pre>
<p>Bu örnekte, basit bir "Merhaba Dünya!" bileşeni tanımlanmıştır. <code>function</code> ile tanımlanan bileşen, <code>return</code> ifadesiyle bir JSX (JavaScript XML) yapısı döndürür.</p>
<h2 id="2-sanal-dom-virtual-dom"><a class="header" href="#2-sanal-dom-virtual-dom">2. Sanal DOM (Virtual DOM)</a></h2>
<p>React, performansı optimize etmek için sanal DOM kullanır. Bir bileşenin durumu değiştiğinde, React bu değişiklikleri temsil eden bir sanal DOM oluşturur ve gerçek DOM'u en verimli şekilde günceller.</p>
<p><strong>Kod Örneği: Sanal DOM Kullanımı</strong></p>
<pre><code class="language-javascript">import React, { useState } from 'react';

function Sayaç() {
  const [sayac, setSayac] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;Sayaç: {sayac}&lt;/p&gt;
      &lt;button onClick={() =&gt; setSayac(sayac + 1)}&gt;Arttır&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Sayaç;
</code></pre>
<p>Bu örnekte, <code>useState</code> kancası kullanılarak sayaç değeri yönetilir. Butona tıklandığında sayaç değeri arttırılır ve sanal DOM bu değişikliği takip ederek gerçek DOM'u günceller.</p>
<h2 id="3-esneklik-flexibility"><a class="header" href="#3-esneklik-flexibility">3. Esneklik (Flexibility)</a></h2>
<p>React, çeşitli backend sistemlerle entegre edilebilir ve diğer JavaScript kütüphaneleri veya framework'leri ile birlikte kullanılabilir. Bu esneklik, React'i çok yönlü ve güçlü bir araç haline getirir.</p>
<h2 id="4-güçlü-topluluk-ve-ekosistem-strong-community-and-ecosystem"><a class="header" href="#4-güçlü-topluluk-ve-ekosistem-strong-community-and-ecosystem">4. Güçlü Topluluk ve Ekosistem (Strong Community and Ecosystem)</a></h2>
<p>React'in geniş bir topluluğu vardır ve bu topluluk, geliştiricilere birçok kaynak, araç ve kütüphane sunar. Bu araçlar arasında Redux (durum yönetimi) ve React Router (yönlendirme) gibi popüler seçenekler bulunmaktadır.</p>
<h2 id="5-facebook-desteği-supported-by-facebook"><a class="header" href="#5-facebook-desteği-supported-by-facebook">5. Facebook Desteği (Supported by Facebook)</a></h2>
<p>React, Facebook tarafından geliştirilmiş ve bakım altında tutulmaktadır. Bu, sürekli güncellemeler ve iyileştirmeler sağlanacağı anlamına gelir. Ayrıca, React, Facebook'un birçok ürününde kullanılmaktadır, bu da onun sağlamlığını garanti eder.</p>
<h2 id="6-yerel-mobil-uygulama-geliştirme-native-mobile-app-development"><a class="header" href="#6-yerel-mobil-uygulama-geliştirme-native-mobile-app-development">6. Yerel Mobil Uygulama Geliştirme (Native Mobile App Development)</a></h2>
<p>React Native ile, web uygulamaları için yazdığınız kodun prensiplerini ve büyük bir kısmını mobil uygulama geliştirme için de kullanabilirsiniz. Bu, geliştirme sürecini hızlandırır ve öğrenme eğrisini azaltır.</p>
<h2 id="7-tek-yönlü-veri-bağlama-one-way-data-binding-with-props"><a class="header" href="#7-tek-yönlü-veri-bağlama-one-way-data-binding-with-props">7. Tek Yönlü Veri Bağlama (One-way Data Binding with Props)</a></h2>
<p>React, tek yönlü veri bağlama ile çalışır. Bu, alt bileşenlerde yapılan değişikliklerin üst bileşenlerin verilerini etkilememesini sağlar ve veri akışını daha öngörülebilir ve hata ayıklamayı kolay hale getirir.</p>
<p><strong>Kod Örneği: Props Kullanımı</strong></p>
<pre><code class="language-javascript">import React from 'react';

function Selam(props) {
  return &lt;h1&gt;Merhaba, {props.isim}!&lt;/h1&gt;;
}

function App() {
  return &lt;Selam isim="Ali" /&gt;;
}

export default App;
</code></pre>
<p>Bu örnekte, <code>Selam</code> bileşeni <code>props</code> kullanarak üst bileşenden aldığı <code>isim</code> verisini kullanır.</p>
<h2 id="8-kancalar-ve-fonksiyonel-bileşenler-hooks-and-functional-components"><a class="header" href="#8-kancalar-ve-fonksiyonel-bileşenler-hooks-and-functional-components">8. Kancalar ve Fonksiyonel Bileşenler (Hooks and Functional Components)</a></h2>
<p>React 16.8 sürümü ile tanıtılan kancalar, geliştiricilerin durum ve diğer React özelliklerini fonksiyonel bileşenlerde kullanmalarına olanak tanır. Bu, kodun daha temiz ve okunabilir olmasını sağlar.</p>
<p><strong>Kod Örneği: useEffect Kancası Kullanımı</strong></p>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';

function Zamanlayici() {
  const [saniye, setSaniye] = useState(0);

  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setSaniye(saniye =&gt; saniye + 1);
    }, 1000);

    return () =&gt; clearInterval(interval);
  }, []);

  return (
    &lt;div&gt;
      &lt;p&gt;{saniye} saniye geçti.&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default Zamanlayici;
</code></pre>
<p>Bu örnekte, <code>useEffect</code> kancası kullanılarak her saniye sayaç arttırılır.</p>
<h1 id="sonuç"><a class="header" href="#sonuç">Sonuç</a></h1>
<p>React, bileşen tabanlı mimarisi, sanal DOM kullanımı, esnekliği, güçlü topluluğu ve Facebook desteği gibi özellikleri ile web ve mobil uygulama geliştirme için güçlü bir araçtır. Bu eğitimde, React'in temel özelliklerini ve bu özelliklerin nasıl kullanılacağını detaylı bir şekilde ele aldık. Geliştiricilerin, bu kütüphaneyi etkili bir şekilde kullanarak daha verimli ve sürdürülebilir projeler oluşturabileceği umulmaktadır.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="temel-bilgiler-ve-gelişmiş-teknikler"><a class="header" href="#temel-bilgiler-ve-gelişmiş-teknikler">Temel Bilgiler ve Gelişmiş Teknikler</a></h1>
<h2 id="giriş-1"><a class="header" href="#giriş-1">Giriş</a></h2>
<p>React, Facebook tarafından geliştirilen ve açık kaynak kodlu bir JavaScript kütüphanesidir. İlk olarak 2013 yılında piyasaya sürülen React, kullanıcı arayüzleri (UI) oluşturmak için kullanılır. React, verimli, esnek ve bileşen tabanlı yaklaşımı sayesinde yazılım geliştiriciler arasında geniş çapta popülerlik kazanmıştır.</p>
<h2 id="react-kullanmanın-avantajları"><a class="header" href="#react-kullanmanın-avantajları">React Kullanmanın Avantajları</a></h2>
<ol>
<li>
<p><strong>Bileşen Tabanlı Mimari:</strong>
React, yeniden kullanılabilir bileşenler oluşturmayı teşvik eder. Bu bileşenler bir araya getirilerek karmaşık kullanıcı arayüzleri inşa edilebilir. Bu modüler yaklaşım, daha temiz ve bakımı kolay kod yazılmasına olanak tanır ve geliştiriciler arasında işbirliğini kolaylaştırır.</p>
</li>
<li>
<p><strong>Sanal DOM (Virtual DOM):</strong>
React, rendering işlemlerini optimize etmek ve uygulama performansını artırmak için sanal DOM kullanır. Sanal DOM, gerçek DOM ile yeni sanal DOM arasındaki farkı hesaplar (bu işleme "diffing" denir) ve sadece değişen parçaları güncelleyerek sayfanın tamamını yeniden render etmeye gerek kalmadan daha hızlı ve verimli güncellemeler sağlar.</p>
</li>
<li>
<p><strong>Güçlü Topluluk ve Ekosistem:</strong>
React'in geniş ve aktif bir geliştirici topluluğu vardır. Bu topluluk, üçüncü taraf kütüphaneler ve araçlarla zengin bir ekosistem oluşturmuştur. Bu, yaygın problemlere mevcut çözümler bulmayı kolaylaştırır, böylece geliştirme süresi ve çabası azalır.</p>
</li>
<li>
<p><strong>Tek Yönlü Veri Bağlama (One-way Data Binding):</strong>
React, tek yönlü veri akışını takip eder, bu da uygulama durumunu izlemeyi ve yönetmeyi kolaylaştırır. Bu, kodun istikrarını artırır ve hata ayıklamayı daha basit hale getirir.</p>
</li>
<li>
<p><strong>Geliştirilmiş Kod Yeniden Kullanılabilirliği:</strong>
React bileşenleri, bir uygulamanın farklı bölümlerinde veya birden fazla projede yeniden kullanılabilir. Bu, kod tekrarını azaltır ve UI tasarımında tutarlılığı teşvik eder.</p>
</li>
<li>
<p><strong>Sunucu Tarafında Render Desteği (SSR):</strong>
React, sunucu tarafında render için kullanılabilir, bu da özellikle ilk sayfa yüklemelerinde performansı artırabilir ve web uygulamalarını SEO dostu hale getirebilir.</p>
</li>
<li>
<p><strong>Çapraz Platform Geliştirme:</strong>
React Native adlı, React üzerine inşa edilmiş bir çerçeve yardımıyla, geliştiriciler Android ve iOS için aynı React kod tabanını kullanarak yerel mobil uygulamalar oluşturabilirler. Bu, üretkenliği artırabilir ve geliştirme maliyetlerini azaltabilir.</p>
</li>
</ol>
<h2 id="react-ile-uygulama-geliştirme"><a class="header" href="#react-ile-uygulama-geliştirme">React ile Uygulama Geliştirme</a></h2>
<p>React ile uygulama geliştirmeye başlamadan önce, temel konseptleri ve yapı taşlarını anlamak önemlidir. Aşağıda, React uygulamalarında yaygın olarak kullanılan bazı temel kavramlar ve teknikler yer almaktadır.</p>
<h3 id="1-bileşenler-components"><a class="header" href="#1-bileşenler-components">1. Bileşenler (Components)</a></h3>
<p>Bileşenler, React uygulamalarının yapı taşlarıdır. Her bileşen, kendi mantığı ve arayüzü ile bağımsız bir modüldür. İşte basit bir React bileşeninin nasıl oluşturulacağına dair bir örnek:</p>
<pre><code class="language-javascript">import React from 'react';

class Welcome extends React.Component {
  render() {
    return &lt;h1&gt;Merhaba, {this.props.name}&lt;/h1&gt;;
  }
}

export default Welcome;
</code></pre>
<p>Bu örnekte, <code>Welcome</code> adlı bir bileşen tanımlanmıştır. Bu bileşen, <code>props</code> olarak adlandırılan bir özellik alır ve bu özelliği kullanarak bir başlık (<code>&lt;h1&gt;</code>) render eder.</p>
<h3 id="2-jsx"><a class="header" href="#2-jsx">2. JSX</a></h3>
<p>JSX, JavaScript XML anlamına gelir ve JavaScript kodu içerisinde HTML benzeri sözdizimi kullanmayı sağlar. JSX, React bileşenlerinin daha okunabilir ve yazılabilir olmasını sağlar. Örneğin:</p>
<pre><code class="language-javascript">const element = &lt;h1&gt;Merhaba, Dünya!&lt;/h1&gt;;
</code></pre>
<p>JSX, tarayıcı tarafından işlenmeden önce Babel gibi araçlarla normal JavaScript'e dönüştürülür.</p>
<h3 id="3-props-ve-state"><a class="header" href="#3-props-ve-state">3. Props ve State</a></h3>
<p><strong>Props</strong> (özellikler), bileşenlere dışarıdan veri geçmek için kullanılır. <strong>State</strong> (durum) ise bileşenlerin kendi iç durumlarını yönetmelerine olanak tanır. İşte props ve state kullanarak bir sayaç bileşeni örneği:</p>
<pre><code class="language-javascript">import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;Şu anki sayım: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Artır&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Counter;
</code></pre>
<p>Bu örnekte, <code>useState</code> kancası (hook) kullanılarak bileşenin durumu yönetilmektedir.</p>
<h2 id="react-ile-daha-İleri-teknikler"><a class="header" href="#react-ile-daha-İleri-teknikler">React ile Daha İleri Teknikler</a></h2>
<h3 id="1-lifecycle-metotları"><a class="header" href="#1-lifecycle-metotları">1. Lifecycle Metotları</a></h3>
<p>React bileşenleri, yaşam döngüsü (lifecycle) metotları kullanarak belirli zamanlarda işlem yapabilirler. Sınıf bileşenleri için yaygın kullanılan bazı yaşam döngüsü metotları şunlardır:</p>
<ul>
<li><code>componentDidMount()</code>: Bileşen DOM'a eklendikten sonra çağrılır.</li>
<li><code>componentDidUpdate(prevProps, prevState)</code>: Bileşen güncellendikten sonra çağrılır.</li>
<li><code>componentWillUnmount()</code>: Bileşen DOM'dan kaldırılmadan önce çağrılır.</li>
</ul>
<h3 id="2-kancalar-hooks"><a class="header" href="#2-kancalar-hooks">2. Kancalar (Hooks)</a></h3>
<p>React 16.8 ile tanıtılan kancalar, fonksiyon bileşenlerinde durum yönetimi ve diğer yan etkileri işlemek için kullanılır. Yaygın kullanılan bazı kancalar şunlardır:</p>
<ul>
<li><code>useState()</code>: Durum yönetimi sağlar.</li>
<li><code>useEffect()</code>: Yan etkileri yönetmek için kullanılır.</li>
<li><code>useContext()</code>: Context API'si ile entegrasyon sağlar.</li>
</ul>
<p>Örneğin, bir efekt kancasının kullanımı:</p>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setSeconds(seconds =&gt; seconds + 1);
    }, 1000);
    return () =&gt; clearInterval(interval);
  }, []);

  return &lt;div&gt;{seconds} saniye geçti.&lt;/div&gt;;
}

export default Timer;
</code></pre>
<p>Bu örnekte, <code>useEffect</code> kancası bir zamanlayıcı (timer) oluşturmak ve bileşen DOM'dan kaldırıldığında temizlemek için kullanılmıştır.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-virtual-dom"><a class="header" href="#react-virtual-dom">React Virtual DOM</a></h1>
<h2 id="giriş-2"><a class="header" href="#giriş-2">Giriş</a></h2>
<p>Bu eğitimde, React ve diğer kütüphanelerde performans artırımı sağlamak için kullanılan sanal DOM (Virtual DOM) kavramını ayrıntılı bir şekilde ele alacağız. Sanal DOM'un temel prensipleri, çalışma mekanizması ve yazılım geliştirme süreçlerindeki avantajları üzerinde duracağız. Eğitim boyunca örnek kod parçacıkları ve teknik açıklamalar sunarak, konunun daha iyi anlaşılmasını sağlayacağız.</p>
<h2 id="sanal-dom-nedir"><a class="header" href="#sanal-dom-nedir">Sanal DOM Nedir?</a></h2>
<p>Sanal DOM (Virtual Document Object Model), kullanıcı arayüzü güncellemelerinin performansını artırmak amacıyla kullanılan bir programlama konseptidir. Gerçek DOM'un hafif bir bellek içi temsilidir. Gerçek DOM, bir web sayfasının yapısını ve içeriğini temsil eden veri yapısıdır. Sanal DOM, bu yapının hafif bir kopyasını oluşturur ve bellek içinde tutar.</p>
<h2 id="sanal-domun-Çalışma-prensibi"><a class="header" href="#sanal-domun-Çalışma-prensibi">Sanal DOM'un Çalışma Prensibi</a></h2>
<ol>
<li><strong>UI Güncellemesi:</strong> Kullanıcı arayüzünde bir güncelleme gerektiğinde, React yeni bir sanal DOM oluşturur.</li>
<li><strong>Fark Analizi (Diffing):</strong> Yeni sanal DOM, mevcut sanal DOM ile karşılaştırılır. Bu işlem "diffing" olarak adlandırılır ve iki sanal DOM arasındaki farkları veya değişiklikleri belirler.</li>
<li><strong>Güncellemelerin Uygulanması:</strong> React, sadece etkilenen kısımları gerçek DOM üzerinde günceller. Bu sayede tüm sayfanın yeniden render edilmesi yerine, sadece değişen bölümler güncellenir.</li>
</ol>
<h2 id="performans-avantajları"><a class="header" href="#performans-avantajları">Performans Avantajları</a></h2>
<p>Sanal DOM yaklaşımı, doğrudan gerçek DOM manipülasyonlarını en aza indirir ve pahalı yeniden render işlemlerinin sayısını azaltır. Bu yöntem, özellikle karmaşık ve dinamik kullanıcı arayüzlerine sahip web uygulamalarında performansı önemli ölçüde artırır.</p>
<h2 id="Örnek-uygulama"><a class="header" href="#Örnek-uygulama">Örnek Uygulama</a></h2>
<p>Aşağıda, React ile sanal DOM kullanımını gösteren basit bir örnek bulunmaktadır:</p>
<pre><code class="language-jsx">import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Counter;
</code></pre>
<p>Bu örnekte, bir sayaç bileşeni (component) tanımlanmıştır. Kullanıcı butona tıkladığında sayaç değeri artar. React, her tıklama sonrası sanal DOM'da güncelleme yapar ve sadece değişen kısmı gerçek DOM'a uygular.</p>
<h2 id="sanal-dom-ve-react"><a class="header" href="#sanal-dom-ve-react">Sanal DOM ve React</a></h2>
<p>React, sanal DOM kullanımında öne çıkan bir kütüphanedir. React'in performans optimizasyonu sağlayan temel özelliklerinden biri sanal DOM kullanımıdır. Özellikle büyük ölçekli uygulamalarda, bu yaklaşımın getirdiği performans iyileştirmeleri belirgin bir şekilde hissedilir.</p>
<h2 id="sonuç-1"><a class="header" href="#sonuç-1">Sonuç</a></h2>
<p>Sanal DOM, modern web geliştirme süreçlerinde performans optimizasyonu sağlamak için kritik bir rol oynar. React ve benzeri kütüphanelerde sanal DOM kullanımı, karmaşık ve dinamik kullanıcı arayüzlerinin verimli bir şekilde yönetilmesine olanak tanır. Bu eğitimde, sanal DOM kavramının temellerini, çalışma prensiplerini ve pratik kullanımını ele aldık. Sanal DOM'un sağladığı avantajlar ve performans iyileştirmeleri, geliştiricilere daha hızlı ve verimli uygulamalar geliştirme imkanı sunar.</p>
<p>xw</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-page-applications-spas-ve-multi-page-applications-mpas"><a class="header" href="#single-page-applications-spas-ve-multi-page-applications-mpas">Single Page Applications (SPAs) ve Multi-page Applications (MPAs)</a></h1>
<p>Web uygulamaları geliştirirken, Single Page Applications (SPAs) ve Multi-page Applications (MPAs) olmak üzere iki temel yaklaşım bulunmaktadır. Bu eğitimde, her iki yöntemin avantajları ve dezavantajları detaylı olarak ele alınacak, ve bu yöntemlerin yazılım geliştirme süreçlerindeki farklılıkları vurgulanacaktır.</p>
<h2 id="single-page-applications-spas"><a class="header" href="#single-page-applications-spas">Single Page Applications (SPAs)</a></h2>
<p>Single Page Application (SPA), tüm uygulamanın tek bir HTML sayfası içinde yüklenip render edildiği bir yaklaşımdır. Kullanıcı uygulama ile etkileşime girdikçe, içerik dinamik olarak güncellenir ve tam sayfa yenilemeleri gerekmez. Bu, genellikle React, Angular veya Vue.js gibi JavaScript frameworkleri kullanılarak gerçekleştirilir.</p>
<p><strong>Avantajları:</strong></p>
<ol>
<li><strong>Gelişmiş Kullanıcı Deneyimi:</strong> SPAs, daha hızlı geçişler ve daha akıcı bir deneyim sunarak uygulamayı daha duyarlı ve çekici hale getirir.</li>
<li><strong>Azaltılmış Sunucu Yükü:</strong> Render işlemlerinin çoğu istemci tarafında gerçekleştiği için sunucu üzerindeki yük azalır, bu da ölçeklenebilirliği artırır.</li>
<li><strong>Basitleştirilmiş Geliştirme:</strong> SPAs, kullanıcı arayüzü (UI) ve arka uç (back-end) işlemlerinin ayrılmasını sağlar, bu da geliştiricilerin her bir bölüme ayrı ayrı odaklanmasına olanak tanır.</li>
</ol>
<p><strong>Dezavantajları:</strong></p>
<ol>
<li><strong>Başlangıç Yükleme Süresi:</strong> Tüm uygulamanın başlangıçta yüklenmesi gerektiği için ilk yükleme süresi daha uzun olabilir.</li>
<li><strong>SEO Zorlukları:</strong> SPAs, JavaScript'e bağımlı olduklarından arama motorlarının bu uygulamaları indekslemesi zor olabilir, bu da arama sıralamalarını olumsuz etkileyebilir.</li>
<li><strong>Karmaşık Durum Yönetimi:</strong> Uygulama büyüdükçe, uygulama durumunu yönetmek zorlaşabilir.</li>
</ol>
<h3 id="react-ile-spa-oluşturma"><a class="header" href="#react-ile-spa-oluşturma">React ile SPA Oluşturma</a></h3>
<pre><code class="language-jsx">import React, { useState } from 'react';
import ReactDOM from 'react-dom';

function App() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;h1&gt;Merhaba, Dünya!&lt;/h1&gt;
      &lt;p&gt;Sayac: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Arttır&lt;/button&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<p>Yukarıdaki kod parçası, temel bir React SPA örneğini göstermektedir. Bu örnek, sayacı artıran bir buton ile etkileşime girildiğinde tam sayfa yenilemesi olmadan sayfa içeriğinin nasıl güncellenebileceğini gösterir.</p>
<h2 id="multi-page-applications-mpas"><a class="header" href="#multi-page-applications-mpas">Multi-page Applications (MPAs)</a></h2>
<p>Multi-page Application (MPA), her bir işleve veya amaca hizmet eden birden fazla HTML sayfasından oluşur. Kullanıcı uygulama ile etkileşime girdiğinde, sunucu yeni bir HTML sayfası üretir ve tam sayfa yenilemesi gerçekleşir.</p>
<p><strong>Avantajları:</strong></p>
<ol>
<li><strong>Daha İyi SEO:</strong> MPAs, arama motorları tarafından daha kolay indekslenir, bu da daha iyi arama sıralamaları sağlar.</li>
<li><strong>Basitleştirilmiş Durum Yönetimi:</strong> Her sayfa bağımsız olduğu için uygulama durumunu yönetmek daha kolay olabilir.</li>
<li><strong>Aşina Geliştirme Yaklaşımı:</strong> MPAs, geleneksel istek-yanıt modelini takip eder, bu da bazı geliştiriciler için daha tanıdık olabilir.</li>
</ol>
<p><strong>Dezavantajları:</strong></p>
<ol>
<li><strong>Yavaş Gezinme:</strong> MPAs, her etkileşimde tam sayfa yenilemeleri gerektirdiği için daha yavaş ve daha az duyarlı hissedilir.</li>
<li><strong>Artan Sunucu Yükü:</strong> Birden fazla sayfanın render edilmesi ve sunulması sunucuya daha fazla yük bindirir, bu da performans ve ölçeklenebilirlik sorunlarına yol açabilir.</li>
<li><strong>Daha Az Esnek UI/UX:</strong> MPAs, SPAs kadar etkileşimli ve duyarlı bir kullanıcı arayüzü sunmayabilir.</li>
</ol>
<h3 id="basit-bir-mpa-yapısı"><a class="header" href="#basit-bir-mpa-yapısı">Basit Bir MPA Yapısı</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="tr"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Ana Sayfa&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;
        &lt;nav&gt;
            &lt;a href="index.html"&gt;Ana Sayfa&lt;/a&gt;
            &lt;a href="about.html"&gt;Hakkında&lt;/a&gt;
            &lt;a href="contact.html"&gt;İletişim&lt;/a&gt;
        &lt;/nav&gt;
    &lt;/header&gt;
    &lt;main&gt;
        &lt;h1&gt;Merhaba, Dünya!&lt;/h1&gt;
        &lt;p&gt;Bu, çoklu sayfa uygulamasının ana sayfasıdır.&lt;/p&gt;
    &lt;/main&gt;
    &lt;footer&gt;
        &lt;p&gt;&amp;copy; 2024 Şirket Adı&lt;/p&gt;
    &lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Yukarıdaki kod parçası, temel bir MPA örneğini göstermektedir. Bu örnek, her biri belirli bir amaca hizmet eden bağımsız HTML sayfalarına sahip basit bir web sitesi yapısını temsil eder.</p>
<h1 id="sonuç-2"><a class="header" href="#sonuç-2">Sonuç</a></h1>
<p>SPAs ve MPAs, farklı kullanım senaryoları için çeşitli avantajlar ve dezavantajlar sunar. SPAs, daha hızlı ve daha duyarlı kullanıcı deneyimleri sunarken, MPAs daha iyi SEO ve daha basit durum yönetimi avantajları sağlar. Geliştiriciler, proje gereksinimlerine ve hedeflerine göre hangi yaklaşımı kullanacaklarına karar vermelidir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kurulum"><a class="header" href="#kurulum">Kurulum</a></h1>
<h2 id="giriş-3"><a class="header" href="#giriş-3">Giriş</a></h2>
<p>Bu eğitimde, React çerçevesini kullanarak nasıl web tabanlı projeler oluşturabileceğinizi ele alacağız. Eğitim boyunca, adım adım React bileşenlerinin oluşturulması, yerel ve çevrimiçi geliştirme ortamlarının ayarlanması ve temel React uygulama yapı taşları hakkında bilgi sahibi olacaksınız. Bu rehber, yazılım geliştirme alanında beklenen titizlik ve standartları yansıtacak şekilde hazırlanmıştır.</p>
<h2 id="geliştirme-ortamının-kurulumu"><a class="header" href="#geliştirme-ortamının-kurulumu">Geliştirme Ortamının Kurulumu</a></h2>
<p><strong>Çevrimiçi Kurulum:</strong></p>
<p>Çevrimiçi geliştirme için CodeSandbox kullanmanızı öneririz. CodeSandbox, web tabanlı projelerin oluşturulması, paylaşılması ve üzerinde işbirliği yapılması için çevrimiçi bir geliştirme ortamıdır.</p>
<p>React örnek başlangıç projesine şu adresten ulaşabilirsiniz:
<a href="https://codesandbox.io/s/react-new">React - CodeSandbox</a></p>
<p><strong>Yerel Geliştirme:</strong></p>
<p>Yerel geliştirme için Visual Studio Code (VS Code) kullanmanızı öneririz. Ancak, rahat ettiğiniz herhangi bir editörü kullanabilirsiniz. VS Code'u indirmek için resmi web sitesini ziyaret edin:
<a href="https://code.visualstudio.com/">Visual Studio Code</a></p>
<p>VS Code'u indirdikten sonra, React projeleri geliştirmek için gerekli araçları kurmak üzere aşağıdaki adımları izleyin.</p>
<h2 id="nodejs-ve-npm-kurulumu"><a class="header" href="#nodejs-ve-npm-kurulumu">Node.js ve npm Kurulumu</a></h2>
<p>React uygulamaları oluşturmak ve yönetmek için Node.js ve npm (Node Package Manager) kullanılır. Node.js ve npm'i sisteminize kurmak için şu adımları izleyin:</p>
<ol>
<li>Node.js'in resmi web sitesine gidin: <a href="https://nodejs.org/">Node.js</a></li>
<li>İşletim sisteminize uygun olan kurulum paketini indirin ve yükleyin.</li>
<li>Yükleme tamamlandıktan sonra, terminal veya komut istemcisini açarak kurulumun doğru yapıldığını kontrol edin:
<pre><code class="language-bash">node -v
npm -v
</code></pre>
Bu komutlar, Node.js ve npm sürüm numaralarını gösterecektir.</li>
</ol>
<h2 id="yeni-react-uygulaması-oluşturma"><a class="header" href="#yeni-react-uygulaması-oluşturma">Yeni React Uygulaması Oluşturma</a></h2>
<p>React uygulaması oluşturmak için Create React App aracını kullanabilirsiniz. Bu araç, React uygulamalarını hızla başlatmak için yapılandırılmış bir şablon sağlar.</p>
<ol>
<li>
<p>Terminal veya komut istemcisini açın ve şu komutu çalıştırarak yeni bir React uygulaması oluşturun:</p>
<pre><code class="language-bash">npx create-react-app my-app
</code></pre>
<p>Bu komut, 'my-app' adlı yeni bir React uygulaması oluşturur.</p>
</li>
<li>
<p>Uygulama dizinine gidin:</p>
<pre><code class="language-bash">cd my-app
</code></pre>
</li>
<li>
<p>Uygulamayı başlatın:</p>
<pre><code class="language-bash">npm start
</code></pre>
<p>Bu komut, yerel geliştirme sunucusunu başlatır ve tarayıcınızda uygulamanızı açar.</p>
</li>
</ol>
<h2 id="react-bileşenleri"><a class="header" href="#react-bileşenleri">React Bileşenleri</a></h2>
<p>React, kullanıcı arayüzlerini bileşenler kullanarak oluşturur. Bileşenler, bağımsız ve yeniden kullanılabilir kod parçalarıdır. Her bileşen, kendine özgü HTML, CSS ve JavaScript kodlarını içerebilir.</p>
<p><strong>Fonksiyonel Bileşenler:</strong></p>
<p>Fonksiyonel bileşenler, basit bileşenler oluşturmak için kullanılır. Bir fonksiyonel bileşen, yalnızca bir render metodu içerir.</p>
<p>Örnek:</p>
<pre><code class="language-javascript">import React from 'react';

function Welcome(props) {
  return &lt;h1&gt;Merhaba, {props.name}&lt;/h1&gt;;
}

export default Welcome;
</code></pre>
<p><strong>Sınıf Bileşenleri:</strong></p>
<p>Sınıf bileşenleri, daha karmaşık bileşenler oluşturmak için kullanılır. Bu bileşenler, yaşam döngüsü metodlarını ve durumu (state) yönetir.</p>
<p>Örnek:</p>
<pre><code class="language-javascript">import React, { Component } from 'react';

class Welcome extends Component {
  render() {
    return &lt;h1&gt;Merhaba, {this.props.name}&lt;/h1&gt;;
  }
}

export default Welcome;
</code></pre>
<h2 id="jsx-ve-proplar"><a class="header" href="#jsx-ve-proplar">JSX ve Prop'lar</a></h2>
<p>JSX (JavaScript XML), JavaScript'te HTML benzeri yapıların yazılmasına olanak tanır. Prop'lar, bileşenlere veri geçişi sağlamak için kullanılır.</p>
<p>Örnek:</p>
<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom';
import Welcome from './Welcome';

ReactDOM.render(
  &lt;Welcome name="Dünya" /&gt;,
  document.getElementById('root')
);
</code></pre>
<p>Bu örnekte, <code>Welcome</code> bileşenine <code>name</code> prop'u ile veri geçilmiştir ve bu veri bileşenin içinde kullanılmıştır.</p>
<h2 id="sonuç-3"><a class="header" href="#sonuç-3">Sonuç</a></h2>
<p>Bu eğitimde, React çerçevesini kullanarak nasıl web tabanlı projeler oluşturabileceğinizi öğrendiniz. Geliştirme ortamlarının kurulumu, yeni bir React uygulamasının oluşturulması ve bileşenlerin yapısı hakkında bilgi sahibi oldunuz. React'in temel yapı taşlarını anlayarak, daha karmaşık ve dinamik kullanıcı arayüzleri oluşturabilirsiniz. Eğitim boyunca verilen kod örneklerini kullanarak, kendi projelerinizi geliştirebilir ve React ekosistemini daha derinlemesine keşfedebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vite-ile-yeni-proje-oluşturma"><a class="header" href="#vite-ile-yeni-proje-oluşturma">Vite ile Yeni Proje Oluşturma</a></h1>
<p>Bu eğitim, React ile bir proje oluşturma sürecini, Vite kullanarak adım adım anlatmaktadır. Vite, hızlı geliştirme ve optimize edilmiş üretim yapıları için tasarlanmış bir derleme aracı ve geliştirme sunucusudur. Modern tarayıcılarda mevcut olan yerel ES modülleri özelliğini kullanır, bu da geliştirme sunucusunun daha hızlı başlatılmasını ve güncellemelerin daha hızlı yapılmasını sağlar.</p>
<h2 id="Ön-koşullar"><a class="header" href="#Ön-koşullar">Ön Koşullar</a></h2>
<p>Bu eğitimi takip edebilmek için sisteminizde Node.js'in (sürüm 12 veya daha yüksek) yüklü olması gerekmektedir. Node.js yüklü değilse, resmi web sitesinden indirilebilir:
<a href="https://nodejs.org/en/download">Node.js İndir</a></p>
<p>Node.js'in yüklü olduğunu ve doğru sürümde olduğunu kontrol etmek için aşağıdaki komutu kullanabilirsiniz:</p>
<pre><code class="language-bash">node -v
</code></pre>
<h2 id="yeni-react-projesi-oluşturma"><a class="header" href="#yeni-react-projesi-oluşturma">Yeni React Projesi Oluşturma</a></h2>
<p>Vite kullanarak yeni bir React uygulaması oluşturmak için aşağıdaki adımları takip edin:</p>
<ol>
<li>
<p><strong>Node.js ve npm Kurulumu:</strong>
Node.js'i kurduktan sonra, npm (Node Package Manager) otomatik olarak kurulacaktır. Terminal veya komut satırında şu komutu çalıştırarak npm'in kurulu olup olmadığını kontrol edebilirsiniz:</p>
<pre><code class="language-bash">npm -v
</code></pre>
</li>
<li>
<p><strong>Vite ile React Projesi Oluşturma:</strong>
Proje dizinize gidin veya yeni bir proje dizini oluşturun ve ardından terminal veya komut satırında aşağıdaki komutu çalıştırın:</p>
<pre><code class="language-bash">npm create vite@latest my-react-app -- --template react
</code></pre>
<p>Bu komut, <code>my-react-app</code> adında yeni bir React projesi oluşturur.</p>
</li>
<li>
<p><strong>Bağımlılıkları Kurma:</strong>
Oluşturulan proje dizinine gidin ve bağımlılıkları yüklemek için şu komutu çalıştırın:</p>
<pre><code class="language-bash">cd my-react-app
npm install
</code></pre>
</li>
<li>
<p><strong>Geliştirme Sunucusunu Başlatma:</strong>
Geliştirme sunucusunu başlatmak için aşağıdaki komutu kullanın:</p>
<pre><code class="language-bash">npm run dev
</code></pre>
<p>Bu komut, projenizi geliştirme modunda başlatır ve yerel sunucu üzerinden erişilebilir hale getirir. Genellikle <code>http://localhost:3000</code> adresinde çalışır.</p>
</li>
</ol>
<h2 id="proje-yapısı"><a class="header" href="#proje-yapısı">Proje Yapısı</a></h2>
<p>Oluşturulan proje yapısı şu şekildedir:</p>
<pre><code>my-react-app/
├── node_modules/
├── public/
│   └── index.html
├── src/
│   ├── App.jsx
│   ├── main.jsx
│   └── styles/
│       └── main.css
├── .gitignore
├── index.html
├── package.json
└── vite.config.js
</code></pre>
<ul>
<li><strong>node_modules/</strong>: Projenin bağımlılıklarını içerir.</li>
<li><strong>public/</strong>: Projenin statik dosyalarını içerir.</li>
<li><strong>src/</strong>: Projenin kaynak kodlarını içerir.
<ul>
<li><strong>App.jsx</strong>: Ana React bileşeni.</li>
<li><strong>main.jsx</strong>: React uygulamasının giriş noktası.</li>
<li><strong>styles/</strong>: CSS dosyalarını içerir.</li>
</ul>
</li>
<li><strong>.gitignore</strong>: Git için yok sayılacak dosya ve dizinleri tanımlar.</li>
<li><strong>index.html</strong>: Uygulamanın ana HTML dosyası.</li>
<li><strong>package.json</strong>: Projenin bağımlılıklarını ve yapılandırmasını içerir.</li>
<li><strong>vite.config.js</strong>: Vite yapılandırma dosyası.</li>
</ul>
<p>Bu temel kurulum ile React uygulamanızı geliştirmeye başlayabilirsiniz. Daha karmaşık yapılandırmalar ve optimizasyonlar için Vite ve React belgelerine başvurabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-proje-yapısı"><a class="header" href="#react-proje-yapısı">React Proje Yapısı</a></h1>
<p>Bu eğitim, React projeleri için doğru dosya yapısını anlamanıza ve oluşturmanıza yardımcı olacaktır. İçeriği, yazılım geliştirme alanında beklenen titizlik ve standartlara uygun olarak sunacağız.</p>
<h2 id="react-kurulumu"><a class="header" href="#react-kurulumu">React Kurulumu</a></h2>
<p>React kurulumu için öncelikle Node.js ve npm'in (Node Package Manager) sisteminize kurulu olduğundan emin olun. Bu araçlar, React uygulamanızı geliştirmek için gereklidir. Node.js'i <a href="https://nodejs.org/">resmi web sitesinden</a> indirip kurabilirsiniz.</p>
<h2 id="proje-kurulumu"><a class="header" href="#proje-kurulumu">Proje Kurulumu</a></h2>
<p>Bir React projesi oluşturmak için <code>create-react-app</code> aracını kullanacağız. Bu araç, başlangıçta gerekli olan tüm dosya ve yapılandırmaları sizin için oluşturur. Terminal veya komut satırında aşağıdaki komutu çalıştırarak yeni bir React uygulaması oluşturabilirsiniz:</p>
<pre><code class="language-bash">npx create-react-app my-app
cd my-app
npm start
</code></pre>
<p>Bu komutlar, yeni bir React projesi oluşturur ve yerel geliştirme sunucusunu başlatır.</p>
<h2 id="dosya-yapısı"><a class="header" href="#dosya-yapısı">Dosya Yapısı</a></h2>
<p>Oluşturulan React projesinin başlangıç dosya yapısı şu şekildedir:</p>
<pre><code>my-app/
├── node_modules/
├── public/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── App.css
│   ├── App.js
│   ├── App.test.js
│   ├── index.css
│   ├── index.js
│   ├── logo.svg
│   └── serviceWorker.js
├── .gitignore
├── package.json
└── README.md
</code></pre>
<p>Bu yapıyı daha detaylı inceleyelim:</p>
<ul>
<li><strong>node_modules/</strong>: Projeye yüklenen tüm bağımlılıkları içerir. Bu klasörü manuel olarak düzenlemeyin.</li>
<li><strong>public/</strong>: Statik dosyaların bulunduğu klasördür. <code>index.html</code> dosyası, uygulamanızın HTML yapısını tanımlar.</li>
<li><strong>src/</strong>: Uygulamanızın kaynak kodlarının bulunduğu klasördür. Ana uygulama bileşenleri burada bulunur.
<ul>
<li><strong>App.js</strong>: Ana uygulama bileşeninizdir. Burada diğer bileşenleri içe aktarabilir ve kullanabilirsiniz.</li>
<li><strong>index.js</strong>: React DOM'u kullanarak, App bileşenini <code>index.html</code> içindeki bir <code>div</code> öğesine render eder.</li>
<li><strong>App.css</strong>: App bileşenine özel stiller.</li>
<li><strong>index.css</strong>: Genel stiller.</li>
</ul>
</li>
<li><strong>package.json</strong>: Projenizin bağımlılıklarını ve betiklerini (scripts) tanımlar.</li>
<li><strong>.gitignore</strong>: Git tarafından izlenmemesi gereken dosya ve klasörleri belirtir.</li>
<li><strong>README.md</strong>: Projeniz hakkında genel bilgiler içerir.</li>
</ul>
<h2 id="Önerilen-dosya-yapısı"><a class="header" href="#Önerilen-dosya-yapısı">Önerilen Dosya Yapısı</a></h2>
<p>Büyüyen projelerde kodun yönetilebilirliğini artırmak için dosya yapınızı modüler hale getirmek önemlidir. Önerilen yapı şu şekildedir:</p>
<pre><code>src/
├── assets/
│   ├── images/
│   └── styles/
├── components/
│   ├── Header.js
│   ├── Footer.js
│   └── ...
├── pages/
│   ├── Home.js
│   ├── About.js
│   └── ...
├── services/
│   └── api.js
├── App.js
├── index.js
└── ...
</code></pre>
<ul>
<li><strong>assets/</strong>: Resimler ve genel stiller gibi statik varlıklar.</li>
<li><strong>components/</strong>: Tekrar kullanılabilir küçük bileşenler.</li>
<li><strong>pages/</strong>: Uygulamanızdaki sayfalar. Her sayfa, bir veya daha fazla bileşenden oluşabilir.</li>
<li><strong>services/</strong>: API istekleri ve diğer hizmetler.</li>
</ul>
<h2 id="kod-parçacıkları"><a class="header" href="#kod-parçacıkları">Kod Parçacıkları</a></h2>
<p><strong>Header.js</strong></p>
<pre><code class="language-javascript">import React from 'react';

const Header = () =&gt; {
  return (
    &lt;header&gt;
      &lt;h1&gt;My App&lt;/h1&gt;
    &lt;/header&gt;
  );
};

export default Header;
</code></pre>
<p><strong>Home.js</strong></p>
<pre><code class="language-javascript">import React from 'react';
import Header from '../components/Header';

const Home = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Header /&gt;
      &lt;p&gt;Welcome to the Home Page&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default Home;
</code></pre>
<p>Bu yapı, kodunuzu daha modüler ve yönetilebilir hale getirir, büyük projelerde bile kodun izlenmesini kolaylaştırır.</p>
<h2 id="sonuç-4"><a class="header" href="#sonuç-4">Sonuç</a></h2>
<p>Bu eğitimde, React projeleri için önerilen dosya yapısını ve temel kurulum adımlarını ele aldık. Doğru dosya yapısı, projenizin sürdürülebilirliği ve yönetilebilirliği için kritik öneme sahiptir. Bu prensiplere bağlı kalarak, daha temiz ve okunabilir kodlar yazabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geliştirme-ortamını-kurmak"><a class="header" href="#geliştirme-ortamını-kurmak">Geliştirme Ortamını Kurmak</a></h1>
<h2 id="amaç"><a class="header" href="#amaç"><strong>Amaç:</strong></a></h2>
<p>React'in temel kavramlarını anlamak ve React uygulamaları için geliştirme ortamınızı kurmak.</p>
<h2 id="gereksinimler"><a class="header" href="#gereksinimler">Gereksinimler:</a></h2>
<ol>
<li>
<p><strong>Gözden Geçirme</strong></p>
<ul>
<li>React'e giriş bölümünü inceleyin ve React hakkında kısa bir genel bakış edinin.</li>
<li>Virtual DOM kavramını ve React içindeki önemini anlayın.</li>
<li>SPA (Single Page Application) ile MPA (Multi Page Application) arasındaki farkları karşılaştırın ve kullanım durumlarını anlayın.</li>
</ul>
</li>
<li>
<p><strong>Kurulum ve Yükleme</strong></p>
<ul>
<li>React ortamınızı yapılandırmak için kurulum ve yükleme adımlarını takip edin.</li>
</ul>
</li>
</ol>
<hr />
<h1 id="gözden-geçirme"><a class="header" href="#gözden-geçirme">Gözden Geçirme</a></h1>
<h2 id="react-nedir"><a class="header" href="#react-nedir">React Nedir?</a></h2>
<p>React, kullanıcı arayüzleri (UI) oluşturmak için kullanılan açık kaynaklı bir JavaScript kütüphanesidir. Facebook tarafından geliştirilen ve sürdürülmekte olan React, bileşen bazlı mimarisi ve virtual DOM kullanımıyla bilinir.</p>
<h2 id="virtual-dom-nedir"><a class="header" href="#virtual-dom-nedir">Virtual DOM Nedir?</a></h2>
<p>Virtual DOM (Sanal DOM), gerçek DOM'un hafif bir kopyasıdır. React, bileşenlerdeki değişiklikleri önce virtual DOM'a uygular ve ardından virtual DOM'u gerçek DOM ile karşılaştırarak sadece gerekli olan değişiklikleri gerçek DOM'a uygular. Bu yöntem, performansı artırır ve daha hızlı güncellemeler sağlar.</p>
<h2 id="spa-vs-mpa"><a class="header" href="#spa-vs-mpa">SPA vs. MPA</a></h2>
<ul>
<li>
<p><strong>SPA (Single Page Application)</strong>: Tek bir HTML sayfası kullanarak dinamik içerik yükler ve kullanıcı deneyimini kesintisiz hale getirir. URL değişimleri JavaScript ile yönetilir.</p>
<p><strong>Avantajları:</strong></p>
<ul>
<li>Hızlı kullanıcı etkileşimleri</li>
<li>Daha az sunucu yükü</li>
<li>Gelişmiş kullanıcı deneyimi</li>
</ul>
<p><strong>Dezavantajları:</strong></p>
<ul>
<li>İlk yükleme süresi uzun olabilir</li>
<li>SEO (Arama Motoru Optimizasyonu) zorlukları</li>
<li>Tarayıcı geri tuşu kullanımı zor olabilir</li>
</ul>
</li>
<li>
<p><strong>MPA (Multi Page Application)</strong>: Her sayfa değişiminde tam bir sayfa yenilemesi gerektirir. Her yeni sayfa, sunucudan tamamen yeni bir HTML belgesi olarak yüklenir.</p>
<p><strong>Avantajları:</strong></p>
<ul>
<li>SEO dostu</li>
<li>Büyük ve karmaşık uygulamalar için uygundur</li>
<li>Daha geleneksel bir navigasyon deneyimi</li>
</ul>
<p><strong>Dezavantajları:</strong></p>
<ul>
<li>Daha fazla sunucu yükü</li>
<li>Daha yavaş kullanıcı etkileşimleri</li>
<li>Her sayfa yüklemesi tam bir yeniden yükleme gerektirir</li>
</ul>
</li>
</ul>
<hr />
<h1 id="kurulum-ve-yükleme"><a class="header" href="#kurulum-ve-yükleme">Kurulum ve Yükleme</a></h1>
<p>React ortamınızı kurmak için aşağıdaki adımları izleyin:</p>
<h2 id="gereksinimler-1"><a class="header" href="#gereksinimler-1">Gereksinimler</a></h2>
<ul>
<li><strong>Node.js ve npm (Node Package Manager)</strong>: React uygulamaları oluşturmak için Node.js ve npm'in en son sürümlerine sahip olmanız gerekmektedir. Node.js'i <a href="https://nodejs.org/">resmi web sitesinden</a> indirebilirsiniz.</li>
</ul>
<h2 id="adım-1-nodejs-ve-npmi-yükleyin"><a class="header" href="#adım-1-nodejs-ve-npmi-yükleyin">Adım 1: Node.js ve npm'i Yükleyin</a></h2>
<p>Node.js ve npm'in bilgisayarınızda kurulu olup olmadığını kontrol etmek için terminale aşağıdaki komutları yazın:</p>
<pre><code class="language-bash">node -v
npm -v
</code></pre>
<p>Eğer yüklü değillerse, Node.js'i indirip kurduktan sonra yeniden kontrol edin.</p>
<h2 id="adım-2-yeni-bir-react-uygulaması-oluşturun"><a class="header" href="#adım-2-yeni-bir-react-uygulaması-oluşturun">Adım 2: Yeni Bir React Uygulaması Oluşturun</a></h2>
<p>React uygulaması oluşturmak için <code>create-react-app</code> komutunu kullanabilirsiniz. Bu komut, React uygulamanız için gerekli tüm başlangıç dosyalarını ve yapılandırmaları otomatik olarak oluşturur. Terminale aşağıdaki komutu yazın:</p>
<pre><code class="language-bash">npx create-react-app my-app
</code></pre>
<p><code>my-app</code> yerine kendi proje adınızı yazabilirsiniz. Bu komut, yeni bir React uygulaması oluşturacak ve gerekli bağımlılıkları yükleyecektir.</p>
<h2 id="adım-3-proje-dizini-İçine-girin"><a class="header" href="#adım-3-proje-dizini-İçine-girin">Adım 3: Proje Dizini İçine Girin</a></h2>
<p>Oluşturulan proje dizinine gitmek için aşağıdaki komutu kullanın:</p>
<pre><code class="language-bash">cd my-app
</code></pre>
<h2 id="adım-4-react-uygulamasını-başlatın"><a class="header" href="#adım-4-react-uygulamasını-başlatın">Adım 4: React Uygulamasını Başlatın</a></h2>
<p>React uygulamanızı başlatmak için aşağıdaki komutu çalıştırın:</p>
<pre><code class="language-bash">npm start
</code></pre>
<p>Bu komut, geliştirme sunucusunu başlatacak ve tarayıcınızda uygulamanızı açacaktır. Varsayılan olarak, uygulamanız <code>http://localhost:3000</code> adresinde çalışır.</p>
<hr />
<p>Bu adımları izleyerek React geliştirme ortamınızı başarıyla kurabilirsiniz. React'in temel kavramlarını anlamak ve uygun bir geliştirme ortamı oluşturmak, verimli bir geliştirme süreci için kritik öneme sahiptir. Bu aşamaları tamamladıktan sonra, daha ileri seviye React özelliklerini ve bileşenlerini keşfetmeye başlayabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-components"><a class="header" href="#understanding-components">Understanding Components</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-bileşenlerine-giriş"><a class="header" href="#react-bileşenlerine-giriş">React Bileşenlerine Giriş</a></h1>
<p>React, kullanıcı arayüzleri oluşturmak için kullanılan popüler bir JavaScript kütüphanesidir. Bu kütüphanenin temel yapı taşları "bileşenler"dir. Bu eğitimde, React bileşenlerinin temellerini, bileşen türlerini ve bu bileşenlerin nasıl oluşturulacağını ele alacağız.</p>
<h2 id="1-bileşen-nedir"><a class="header" href="#1-bileşen-nedir">1. Bileşen Nedir?</a></h2>
<p>Bileşenler, bir React uygulamasının yeniden kullanılabilir ve bağımsız parçalarıdır. Kullanıcı arayüzünün (UI) hem yapısını (JSX) hem de davranışını (JavaScript) kapsarlar. Bileşenler, uygulamaların modüler ve bakımı kolay olmasını sağlar.</p>
<h2 id="2-bileşen-türleri"><a class="header" href="#2-bileşen-türleri">2. Bileşen Türleri</a></h2>
<p>React'te iki ana bileşen türü vardır:</p>
<ul>
<li><strong>Fonksiyonel Bileşenler (Functional Components)</strong></li>
<li><strong>Sınıf Bileşenleri (Class Components)</strong></li>
</ul>
<p>Bu eğitimde, öncelikle fonksiyonel bileşenlere odaklanacağız.</p>
<h2 id="3-fonksiyonel-bileşenler"><a class="header" href="#3-fonksiyonel-bileşenler">3. Fonksiyonel Bileşenler</a></h2>
<p>Fonksiyonel bileşenler, basit bir JavaScript fonksiyonu olarak tanımlanabilir. Bu bileşenler, props (özellikler) adı verilen parametreler alır ve JSX (JavaScript XML) döner. JSX, HTML'ye benzeyen bir sözdizimidir ve JavaScript kodu içinde HTML benzeri yapılar oluşturmanıza olanak tanır.</p>
<h3 id="31-arrow-function-ile-fonksiyonel-bileşen"><a class="header" href="#31-arrow-function-ile-fonksiyonel-bileşen">3.1. Arrow Function ile Fonksiyonel Bileşen</a></h3>
<pre><code class="language-jsx">import React from 'react';

const MerhabaDunya = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Merhaba Dünya!&lt;/h1&gt;
    &lt;/div&gt;
  );
};

export default MerhabaDunya;
</code></pre>
<p>Bu örnekte, <code>MerhabaDunya</code> adlı bir fonksiyonel bileşen oluşturulmuştur. Bu bileşen, <code>Merhaba Dünya!</code> yazısını içeren bir <code>div</code> döner.</p>
<h3 id="32-normal-function-ile-fonksiyonel-bileşen"><a class="header" href="#32-normal-function-ile-fonksiyonel-bileşen">3.2. Normal Function ile Fonksiyonel Bileşen</a></h3>
<p>Fonksiyonel bir bileşeni normal bir fonksiyon kullanarak da oluşturabilirsiniz. Bu yöntem, ok fonksiyonları kullanmaya benzer.</p>
<pre><code class="language-jsx">import React from 'react';

function MerhabaDunya() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Merhaba Dünya!&lt;/h1&gt;
    &lt;/div&gt;
  );
}

export default MerhabaDunya;
</code></pre>
<p>Bu örnekte, <code>MerhabaDunya</code> bileşeni normal bir fonksiyon olarak tanımlanmıştır ve aynı sonucu döner.</p>
<h2 id="4-bileşenlerin-Özellikleri-props"><a class="header" href="#4-bileşenlerin-Özellikleri-props">4. Bileşenlerin Özellikleri (Props)</a></h2>
<p>Props, bileşenlere veri geçmek için kullanılan mekanizmadır. Bir bileşen, props aracılığıyla ebeveyn bileşenden veri alabilir.</p>
<h3 id="41-props-kullanımı"><a class="header" href="#41-props-kullanımı">4.1. Props Kullanımı</a></h3>
<pre><code class="language-jsx">import React from 'react';

const Selamla = (props) =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Merhaba, {props.isim}!&lt;/h1&gt;
    &lt;/div&gt;
  );
};

export default Selamla;
</code></pre>
<p>Bu örnekte, <code>Selamla</code> bileşeni <code>isim</code> adında bir prop alır ve bu değeri <code>Merhaba, {isim}!</code> ifadesi içinde kullanır.</p>
<pre><code class="language-jsx">import React from 'react';
import Selamla from './Selamla';

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Selamla isim="Ali" /&gt;
      &lt;Selamla isim="Ayşe" /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<p><code>App</code> bileşeninde, <code>Selamla</code> bileşeni iki kez kullanılmış ve her seferinde farklı bir <code>isim</code> prop'u geçilmiştir. Bu, bileşenlerin yeniden kullanılabilirliğini gösterir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-bileşenlerinin-render-edilmesi"><a class="header" href="#react-bileşenlerinin-render-edilmesi">React Bileşenlerinin Render Edilmesi</a></h1>
<p>Bu eğitimde, React'te bileşenlerin nasıl render edildiğini kapsamlı ve detaylı bir şekilde ele alacağız. Eğitim boyunca ciddi ve bilimsel bir dil kullanarak konunun yazılım geliştirme alanındaki titizlik ve standartlara uygun olarak anlatılmasını sağlayacağız.</p>
<h2 id="proje-dizininin-açılması-ve-bileşen-dosyalarının-oluşturulması"><a class="header" href="#proje-dizininin-açılması-ve-bileşen-dosyalarının-oluşturulması">Proje Dizininin Açılması ve Bileşen Dosyalarının Oluşturulması</a></h2>
<ol>
<li>
<p><strong>Proje Dizininin Açılması:</strong></p>
<ul>
<li>Proje dizininizi kod editörünüzde açın. Bu eğitimde, tüm bileşenlerimizi <code>src</code> klasörü altında oluşturacağız.</li>
</ul>
</li>
<li>
<p><strong>Bileşen Klasörünün Oluşturulması:</strong></p>
<ul>
<li><code>src</code> klasörü altında yeni bir klasör oluşturun ve adını <code>components</code> koyun. Bu klasör, bileşen dosyalarımızı saklayacağımız yer olacaktır.</li>
</ul>
</li>
<li>
<p><strong>Bileşen Dosyasının Oluşturulması:</strong></p>
<ul>
<li><code>components</code> klasörü içinde yeni bir dosya oluşturun ve adını <code>MyComponent.jsx</code> koyun. Bu dosya, bileşenimizi tanımlayacağımız yerdir.</li>
</ul>
</li>
</ol>
<h2 id="basit-bir-bileşenin-oluşturulması"><a class="header" href="#basit-bir-bileşenin-oluşturulması">Basit Bir Bileşenin Oluşturulması</a></h2>
<p><code>MyComponent.jsx</code> dosyasına aşağıdaki kodu ekleyerek basit bir bileşen oluşturalım:</p>
<pre><code class="language-jsx">import React from 'react';

const MyComponent = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Merhaba, React!&lt;/h1&gt;
      &lt;p&gt;Bu, basit bir React bileşenidir.&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default MyComponent;
</code></pre>
<p>Bu kod, React'in <code>div</code> elemanına sarmalanmış bir başlık (<code>h1</code>) ve paragraf (<code>p</code>) render eden basit bir fonksiyon bileşeni tanımlar.</p>
<h2 id="ana-dosyada-bileşenin-render-edilmesi"><a class="header" href="#ana-dosyada-bileşenin-render-edilmesi">Ana Dosyada Bileşenin Render Edilmesi</a></h2>
<p>Şimdi, bu bileşeni <code>main.jsx</code> dosyasında render etmemiz gerekiyor. <code>src</code> klasöründe bulunan <code>main.jsx</code> dosyasını açın ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React from 'react';
import ReactDOM from 'react-dom';
import MyComponent from './components/MyComponent';

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;MyComponent /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);
</code></pre>
<p>Bu kod, <code>MyComponent</code> bileşenimizi <code>index.html</code> dosyasındaki <code>root</code> elementine render eder.</p>
<h2 id="geliştirme-sunucusunun-başlatılması"><a class="header" href="#geliştirme-sunucusunun-başlatılması">Geliştirme Sunucusunun Başlatılması</a></h2>
<p>Son olarak, terminalinizde aşağıdaki komutu çalıştırarak geliştirme sunucusunu başlatın:</p>
<pre><code class="language-sh">npm start
</code></pre>
<p>Bu komut, yerel geliştirme sunucunuzu başlatacak ve projenizi tarayıcıda görüntülemenizi sağlayacaktır. Tarayıcınızda <code>http://localhost:3000</code> adresine giderek oluşturduğunuz bileşeni görebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsx"><a class="header" href="#jsx">JSX</a></h1>
<p>Bu eğitimde, JSX ile ilgili kapsamlı ve ayrıntılı bilgiler sunacağız. Eğitim boyunca ciddi ve bilimsel bir dil kullanarak, doğru ve eksiksiz bilgi vermeye özen göstereceğiz. JSX, React kullanarak bileşenlerin yapılarını oluşturmak ve yönetmek için HTML benzeri kod yazmanıza olanak tanıyan bir JavaScript sözdizimi uzantısıdır. Bu eğitimde, JSX'in temellerini ve kullanımıyla ilgili önemli noktaları ele alacağız.</p>
<h1 id="jsx-nedir"><a class="header" href="#jsx-nedir">JSX Nedir?</a></h1>
<p>JSX (JavaScript XML), JavaScript içine HTML benzeri kod yazmayı sağlayan bir sözdizimi uzantısıdır. React, JSX'i derleme sürecinde düzenli JavaScript koduna dönüştürür. JSX kullanımı, bileşenlerin yapısını oluşturmayı ve yönetmeyi kolaylaştırır.</p>
<h1 id="jsx-kullanımına-İlişkin-temel-noktalar"><a class="header" href="#jsx-kullanımına-İlişkin-temel-noktalar">JSX Kullanımına İlişkin Temel Noktalar</a></h1>
<h2 id="1-İfadeler"><a class="header" href="#1-İfadeler">1. İfadeler</a></h2>
<p>JSX kodu içinde JavaScript ifadelerini süslü parantezler ({}) içine alarak yerleştirebilirsiniz. Örneğin:</p>
<pre><code class="language-jsx">const name = "John";
const element = &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;
</code></pre>
<p>Bu örnekte, <code>name</code> değişkeninin değeri süslü parantezler içinde kullanılarak JSX içinde yerleştirilmiştir.</p>
<h2 id="2-nitelikler"><a class="header" href="#2-nitelikler">2. Nitelikler</a></h2>
<p>JSX nitelikleri, HTML niteliklerine benzer, ancak camelCase adlandırma kuralını kullanır. Örneğin, <code>class</code> yerine <code>className</code> ve <code>onclick</code> yerine <code>onClick</code> kullanılır:</p>
<pre><code class="language-jsx">const element = &lt;button className="btn" onClick={handleClick}&gt;Click me&lt;/button&gt;;
</code></pre>
<h2 id="3-kapanış-etiketleri"><a class="header" href="#3-kapanış-etiketleri">3. Kapanış Etiketleri</a></h2>
<p>HTML'den farklı olarak, JSX'te tüm öğelerin kapanış etiketine sahip olması gerekir. Kendi kendine kapanan öğeler için (örneğin, <code>img</code> veya <code>input</code>), kapanış açı parantezinden önce tek bir eğik çizgi kullanmalısınız:</p>
<pre><code class="language-jsx">const element = &lt;img src="image.jpg" alt="Description" /&gt;;
</code></pre>
<h1 id="jsxin-yararları"><a class="header" href="#jsxin-yararları">JSX'in Yararları</a></h1>
<ul>
<li><strong>Okunabilirlik</strong>: HTML benzeri sözdizimi, bileşen yapısının kolayca anlaşılmasını sağlar.</li>
<li><strong>Dinamik İçerik</strong>: JavaScript ifadeleri ile dinamik içerik oluşturulabilir.</li>
<li><strong>Bileşen Yönetimi</strong>: Büyük uygulamalarda bileşenlerin yönetimi ve bakımı kolaylaşır.</li>
</ul>
<h1 id="jsxin-dönüştürülmesi"><a class="header" href="#jsxin-dönüştürülmesi">JSX'in Dönüştürülmesi</a></h1>
<p>JSX, React tarafından derleme sürecinde JavaScript fonksiyon çağrılarına dönüştürülür. Örneğin:</p>
<pre><code class="language-jsx">const element = &lt;h1 className="title"&gt;Hello, world!&lt;/h1&gt;;
</code></pre>
<p>Bu kod, React tarafından aşağıdaki JavaScript koduna dönüştürülür:</p>
<pre><code class="language-javascript">const element = React.createElement(
  'h1',
  { className: 'title' },
  'Hello, world!'
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactte-İfade-gömme"><a class="header" href="#reactte-İfade-gömme">React'te İfade Gömme</a></h1>
<h2 id="giriş-4"><a class="header" href="#giriş-4">Giriş</a></h2>
<p>React uygulamalarında JSX içinde ifadelerin gömülmesi, JavaScript değişkenlerini, fonksiyonlarını veya diğer ifadeleri JSX kodu içinde kullanmanıza olanak tanır. JSX içine bir ifade gömmek için, sadece ifadeyi süslü parantezler ({}) içine almanız yeterlidir. Bu, React bileşenlerinizin dinamik olmasını sağlar ve değişkenlere, duruma veya proplara dayalı olarak veri görüntülemenize olanak tanır.</p>
<h2 id="değişkenler"><a class="header" href="#değişkenler">Değişkenler</a></h2>
<p>Bir değişkenin değerini görüntülemek için değişkeni süslü parantezler içine yerleştirebilirsiniz.</p>
<pre><code class="language-jsx">const name = "John";
const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;
</code></pre>
<p>Bu kod, <code>name</code> değişkeninin değerini (<code>"John"</code>) <code>&lt;h1&gt;</code> etiketinin içinde görüntüler.</p>
<h2 id="aritmetik-İşlemler"><a class="header" href="#aritmetik-İşlemler">Aritmetik İşlemler</a></h2>
<p>Süslü parantezler içinde doğrudan aritmetik işlemler yapabilirsiniz.</p>
<pre><code class="language-jsx">const a = 5;
const b = 10;
const element = &lt;p&gt;{a + b}&lt;/p&gt;;
</code></pre>
<p>Bu örnek, <code>a</code> ve <code>b</code> değişkenlerinin toplamını (<code>15</code>) <code>&lt;p&gt;</code> etiketi içinde görüntüler.</p>
<h2 id="fonksiyonlar"><a class="header" href="#fonksiyonlar">Fonksiyonlar</a></h2>
<p>JavaScript fonksiyonlarını süslü parantezler içinde çağırabilir ve fonksiyonun dönüş değerini kullanabilirsiniz.</p>
<pre><code class="language-jsx">function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};

const element = (
  &lt;h1&gt;
    Hello, {formatName(user)}!
  &lt;/h1&gt;
);
</code></pre>
<p>Bu kod, <code>user</code> nesnesini <code>formatName</code> fonksiyonuna geçirir ve dönüş değerini <code>&lt;h1&gt;</code> etiketi içinde görüntüler.</p>
<h2 id="dizileri-haritalama"><a class="header" href="#dizileri-haritalama">Dizileri Haritalama</a></h2>
<p>Bir dizi üzerinde haritalama yapabilir ve dizi verilerine dayalı olarak bir öğe listesi oluşturabilirsiniz.</p>
<pre><code class="language-jsx">const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =&gt;
  &lt;li key={number.toString()}&gt;
    {number}
  &lt;/li&gt;
);

const element = (
  &lt;ul&gt;
    {listItems}
  &lt;/ul&gt;
);
</code></pre>
<p>Bu örnek, <code>numbers</code> dizisi üzerinde haritalama yapar ve her bir sayı için bir <code>&lt;li&gt;</code> öğesi oluşturur ve listeyi <code>&lt;ul&gt;</code> etiketi içinde görüntüler.</p>
<h2 id="sonuç-5"><a class="header" href="#sonuç-5">Sonuç</a></h2>
<p>JSX içinde ifadelerin gömülmesi, React bileşenlerinizin daha dinamik ve esnek olmasını sağlar. Değişkenler, aritmetik işlemler, fonksiyon çağrıları ve dizi haritalamaları gibi çeşitli yöntemlerle JSX içine JavaScript ifadeleri gömülebilir. Bu yöntemler, bileşenlerinizin veri odaklı ve dinamik içerikler oluşturmasına yardımcı olur.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jsx-ve-html-karşılaştırması"><a class="header" href="#jsx-ve-html-karşılaştırması">JSX ve HTML Karşılaştırması</a></h1>
<h2 id="giriş-5"><a class="header" href="#giriş-5">Giriş</a></h2>
<p>JSX (JavaScript XML) ve HTML (HyperText Markup Language) ilk bakışta benzer görünebilir, ancak bazı önemli farklılıklara sahiptirler. JSX, React uygulamalarında bileşenleri ve yapılarını tanımlamak için kullanılan JavaScript için bir sözdizimi uzantısıdır. HTML ise web sayfalarını oluşturmak için kullanılan standart bir işaretleme dilidir.</p>
<h2 id="ana-farklılıklar"><a class="header" href="#ana-farklılıklar">Ana Farklılıklar</a></h2>
<ol>
<li>
<p><strong>Sözdizimi</strong>:</p>
<ul>
<li><strong>JSX</strong>: JavaScript kodunuzun içinde HTML benzeri kod yazmanıza izin veren bir JavaScript sözdizimi uzantısıdır. JSX kodu, DOM elemanlarını oluşturmak ve güncellemek için JavaScript fonksiyon çağrılarına dönüştürülür.</li>
<li><strong>HTML</strong>: Web sayfalarının yapısını tanımlamak için kullanılan bir işaretleme dilidir. HTML, tarayıcı tarafından DOM'u oluşturmak için ayrıştırılır.</li>
</ul>
</li>
<li>
<p><strong>Değişken İç İçe Geçirme (Variable Interpolation)</strong>:</p>
<ul>
<li><strong>JSX</strong>: JavaScript ifadelerini kodun içinde süslü parantezler ({}) kullanarak yerleştirebilirsiniz. Bu, değişkenleri, fonksiyonları ve diğer ifadeleri doğrudan kullanmanıza olanak tanır.</li>
<li><strong>HTML</strong>: JavaScript ifadelerini doğrudan kullanamazsınız; DOM'u manipüle etmek için JavaScript'i <code>&lt;script&gt;</code> etiketleri veya inline olay işleyicileri içinde kullanmanız gerekir.</li>
</ul>
</li>
<li>
<p><strong>Özellik İsimlendirmesi (Attribute Naming)</strong>:</p>
<ul>
<li><strong>JSX</strong>: Özellikler için camelCase isimlendirme kullanır. Örneğin, <code>class</code> yerine <code>className</code> ve <code>onclick</code> yerine <code>onClick</code> kullanırsınız.</li>
<li><strong>HTML</strong>: Özellikler için tire ile ayrılmış isimler kullanır.</li>
</ul>
</li>
<li>
<p><strong>Kendi Kendini Kapatan Etiketler (Self-closing Tags)</strong>:</p>
<ul>
<li><strong>JSX</strong>: Tüm elemanların bir kapanış etiketi olması gerekir, kendi kendini kapatan elemanlar da dahil olmak üzere. Örneğin, <code>&lt;img src="logo.png" alt="Logo" /&gt;</code>.</li>
<li><strong>HTML</strong>: Bazı kendi kendini kapatan elemanlar için kapanış etiketini atlayabilirsiniz.</li>
</ul>
</li>
<li>
<p><strong>Bileşen Oluşturma (Component Creation)</strong>:</p>
<ul>
<li><strong>JSX</strong>: Yeniden kullanılabilir ve bakımı kolay UI parçalarını tanımlamak için kullanılır. JSX ile özel bileşenler oluşturabilir ve bunları HTML elemanları gibi kullanabilirsiniz.</li>
<li><strong>HTML</strong>: Sınırlı bir dizi elemanla sınırlıdır ve yeniden kullanılabilir bileşenler oluşturmak için yerleşik bir mekanizması yoktur.</li>
</ul>
</li>
</ol>
<h2 id="htmlden-jsxe-dönüştürme"><a class="header" href="#htmlden-jsxe-dönüştürme">HTML'den JSX'e Dönüştürme</a></h2>
<p>JSX'e dönüştürmek için aşağıdaki çevrimiçi araçları kullanabilirsiniz:</p>
<ul>
<li><a href="https://transform.tools/html-to-jsx">HTML to JSX</a></li>
</ul>
<h2 id="Örnekler"><a class="header" href="#Örnekler">Örnekler</a></h2>
<h3 id="html"><a class="header" href="#html">HTML</a></h3>
<pre><code class="language-html">&lt;div class="container"&gt;
  &lt;h1 onclick="handleClick()"&gt;Merhaba Dünya&lt;/h1&gt;
  &lt;img src="logo.png" alt="Logo"&gt;
&lt;/div&gt;
</code></pre>
<h3 id="jsx-1"><a class="header" href="#jsx-1">JSX</a></h3>
<pre><code class="language-jsx">&lt;div className="container"&gt;
  &lt;h1 onClick={handleClick}&gt;Merhaba Dünya&lt;/h1&gt;
  &lt;img src="logo.png" alt="Logo" /&gt;
&lt;/div&gt;
</code></pre>
<h2 id="sonuç-6"><a class="header" href="#sonuç-6">Sonuç</a></h2>
<p>JSX ve HTML arasında belirgin farklar vardır ve bu farklar, React gibi modern JavaScript kütüphaneleri ile çalışırken önemlidir. JSX, JavaScript ile daha entegre bir şekilde çalışmanıza olanak tanırken, HTML, web sayfalarının temel yapısını tanımlamak için kullanılır. Bu farklılıkları anlamak, etkili ve verimli bir şekilde çalışmanızı sağlar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bileşen-component-rendering"><a class="header" href="#bileşen-component-rendering">Bileşen (Component) Rendering</a></h1>
<p>Bu eğitimin amacı, React geliştirme ortamını kurma, bileşen renderinginin temel kavramlarını anlama ve basit bir bileşen rendering örneği oluşturarak uygulamalı deneyim kazanmaktır. Bu eğitimi tamamlayarak, React kullanarak web siteleri oluşturma becerilerinizi geliştireceksiniz.</p>
<h2 id="gereksinimler-2"><a class="header" href="#gereksinimler-2"><strong>Gereksinimler:</strong></a></h2>
<ol>
<li>Projenin kaynak klasörü içinde "components" adında yeni bir klasör oluşturun.</li>
<li>"Components" klasörü içinde "Greeting.jsx" adında yeni bir bileşen dosyası oluşturun.</li>
<li>"Greeting" bileşenini, "Hello, React!" gibi basit bir karşılama mesajı render edecek şekilde uygulayın.</li>
<li>Ana App bileşeninde "Greeting" bileşenini import edin ve render edin.</li>
<li>React uygulamasının karşılama mesajını doğru bir şekilde render ettiğinden emin olun.</li>
</ol>
<h2 id="teslimat"><a class="header" href="#teslimat"><strong>Teslimat:</strong></a></h2>
<ol>
<li>React projenizi barındırmak için bir GitHub deposu oluşturun.</li>
<li>Kodunuzu depoya commit edin ve pushlayın.</li>
<li>Uygulamanızın nasıl çalıştırılacağına dair talimatlar içeren bir README dosyası ekleyin.</li>
<li>Uygulamanızın canlı demosunu Netlify veya GitHub Pages gibi bir platform kullanarak sağlayın.</li>
</ol>
<h2 id="adım-adım-uygulama"><a class="header" href="#adım-adım-uygulama"><strong>Adım Adım Uygulama:</strong></a></h2>
<h3 id="1-react-projesi-kurulumu"><a class="header" href="#1-react-projesi-kurulumu">1. React Projesi Kurulumu</a></h3>
<p>İlk olarak, React projesi kurmak için aşağıdaki adımları izleyin:</p>
<pre><code class="language-bash">npx create-react-app my-react-app
cd my-react-app
</code></pre>
<h3 id="2-components-klasörü-oluşturma"><a class="header" href="#2-components-klasörü-oluşturma">2. "components" Klasörü Oluşturma</a></h3>
<p>Proje dizininde <code>src</code> klasörü altında <code>components</code> adında bir klasör oluşturun.</p>
<pre><code class="language-bash">mkdir src/components
</code></pre>
<h3 id="3-greetingjsx-bileşeni-oluşturma"><a class="header" href="#3-greetingjsx-bileşeni-oluşturma">3. "Greeting.jsx" Bileşeni Oluşturma</a></h3>
<p><code>src/components</code> klasörü içinde <code>Greeting.jsx</code> dosyasını oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React from 'react';

const Greeting = () =&gt; {
    return &lt;h1&gt;Hello, React!&lt;/h1&gt;;
};

export default Greeting;
</code></pre>
<h3 id="4-ana-bileşende-app-greeting-bileşenini-render-etme"><a class="header" href="#4-ana-bileşende-app-greeting-bileşenini-render-etme">4. Ana Bileşende (App) Greeting Bileşenini Render Etme</a></h3>
<p>Ana bileşen dosyası olan <code>src/App.js</code> dosyasını açın ve <code>Greeting</code> bileşenini import edip render edin:</p>
<pre><code class="language-jsx">import React from 'react';
import './App.css';
import Greeting from './components/Greeting';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;Greeting /&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-props-in-components"><a class="header" href="#using-props-in-components">Using Props in Components</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="props"><a class="header" href="#props">Props</a></h1>
<p>Bu eğitim, React kütüphanesini kullanarak yazılım geliştiricilerin bileşenler arası veri aktarımını nasıl gerçekleştirebileceğini ele alacaktır. Eğitim boyunca, props (properties) kullanımı hakkında detaylı bilgiler verilecek ve örnek kod parçacıkları ile konunun daha iyi anlaşılması sağlanacaktır. Eğitimde verilen bilgiler, yazılım geliştirme alanında beklenen titizlik ve standartları yansıtacak şekilde hazırlanmıştır.</p>
<h2 id="props-nedir"><a class="header" href="#props-nedir">Props Nedir?</a></h2>
<p>Props, "properties" kelimesinin kısaltmasıdır ve React bileşenleri arasında veri geçişini sağlamak için kullanılır. Props, bileşenlerin yeniden kullanılabilir ve özelleştirilebilir olmasını sağlar. Bir bileşenden diğerine veri aktarımı props ile gerçekleştirilir ve bu veri, child (alt) bileşen içinde doğrudan değiştirilmemelidir. Props, sadece okunabilir olarak ele alınmalıdır.</p>
<h2 id="props-kullanımı"><a class="header" href="#props-kullanımı">Props Kullanımı</a></h2>
<h3 id="adım-1-bileşenler-klasörü-oluşturma"><a class="header" href="#adım-1-bileşenler-klasörü-oluşturma">Adım 1: Bileşenler Klasörü Oluşturma</a></h3>
<p>Projenizin <code>src</code> dizininde yeni bir klasör oluşturun ve bu klasöre <code>components</code> adını verin.</p>
<pre><code class="language-bash">src/
└── components/
</code></pre>
<h3 id="adım-2-yeni-bir-bileşen-oluşturma"><a class="header" href="#adım-2-yeni-bir-bileşen-oluşturma">Adım 2: Yeni Bir Bileşen Oluşturma</a></h3>
<p><code>components</code> klasörünün içinde <code>ChildComponent.jsx</code> adlı yeni bir dosya oluşturun.</p>
<h3 id="adım-3-react-bileşeninin-temel-yapısını-ekleyin"><a class="header" href="#adım-3-react-bileşeninin-temel-yapısını-ekleyin">Adım 3: React Bileşeninin Temel Yapısını Ekleyin</a></h3>
<p><code>ChildComponent.jsx</code> dosyasına aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React from 'react';

const ChildComponent = () =&gt; {
  return (
    &lt;div&gt;
      Child Component
    &lt;/div&gt;
  );
};

export default ChildComponent;
</code></pre>
<h3 id="adım-4-child-bileşene-prop-ekleme"><a class="header" href="#adım-4-child-bileşene-prop-ekleme">Adım 4: Child Bileşene Prop Ekleme</a></h3>
<p><code>ChildComponent</code> fonksiyonunu, <code>message</code> adlı bir prop kabul edecek şekilde düzenleyin:</p>
<pre><code class="language-jsx">import React from 'react';

const ChildComponent = ({ message }) =&gt; {
  return (
    &lt;div&gt;
      {message}
    &lt;/div&gt;
  );
};

export default ChildComponent;
</code></pre>
<h3 id="adım-5-child-bileşeni-parent-bileşende-İçe-aktarma-ve-kullanma"><a class="header" href="#adım-5-child-bileşeni-parent-bileşende-İçe-aktarma-ve-kullanma">Adım 5: Child Bileşeni Parent Bileşende İçe Aktarma ve Kullanma</a></h3>
<p><code>src/App.jsx</code> dosyasında <code>ChildComponent</code> bileşenini içe aktarın ve JSX içinde kullanarak <code>message</code> propunu geçirin:</p>
<pre><code class="language-jsx">import React from 'react';
import ChildComponent from './components/ChildComponent';

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Parent Component&lt;/h1&gt;
      &lt;ChildComponent message="Hello from the parent component!" /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-yazılım-geliştirici"><a class="header" href="#react-yazılım-geliştirici">React Yazılım Geliştirici</a></h1>
<p>Bu eğitim, React kullanarak bileşen tabanlı uygulamalar geliştirme konusunda derinlemesine bilgi sağlayacaktır. React, kullanıcı arayüzleri oluşturmak için kullanılan popüler bir JavaScript kütüphanesidir ve bu eğitimde, bileşenlerin nasıl oluşturulacağı, kullanılacağı ve yönetileceği ele alınacaktır.</p>
<h2 id="1-veri-akışı-data-flow"><a class="header" href="#1-veri-akışı-data-flow">1. Veri Akışı (Data Flow)</a></h2>
<p>React'ta veri akışı tek yönlüdür; bu, verilerin ebeveynden çocuğa doğru aktığı anlamına gelir. Bu yaklaşım, uygulamanın veri yönetimini basitleştirir ve bileşenler arasındaki veri akışını daha öngörülebilir hale getirir.</p>
<p><strong>Örnek:</strong></p>
<pre><code class="language-jsx">// ParentComponent.jsx
import React from 'react';
import ChildComponent from './ChildComponent';

const ParentComponent = () =&gt; {
  const data = "Hello from Parent!";
  return &lt;ChildComponent message={data} /&gt;;
};

export default ParentComponent;

// ChildComponent.jsx
import React from 'react';

const ChildComponent = ({ message }) =&gt; {
  return &lt;div&gt;{message}&lt;/div&gt;;
};

export default ChildComponent;
</code></pre>
<p>Bu örnekte, <code>ParentComponent</code> bir <code>message</code> prop'u aracılığıyla veriyi <code>ChildComponent</code>'e geçirir.</p>
<h2 id="2-yeniden-kullanılabilirlik-reusability"><a class="header" href="#2-yeniden-kullanılabilirlik-reusability">2. Yeniden Kullanılabilirlik (Reusability)</a></h2>
<p>React bileşenleri, tekrar kullanılabilir ve özelleştirilebilir olmaları için tasarlanmalıdır. Bu, bileşenlerin props kullanılarak özelleştirilmesi anlamına gelir.</p>
<p><strong>Örnek:</strong></p>
<pre><code class="language-jsx">// Button.jsx
import React from 'react';

const Button = ({ text, onClick }) =&gt; {
  return &lt;button onClick={onClick}&gt;{text}&lt;/button&gt;;
};

export default Button;

// App.jsx
import React from 'react';
import Button from './Button';

const handleClick = () =&gt; {
  alert('Button clicked!');
};

const App = () =&gt; {
  return &lt;Button text="Click Me" onClick={handleClick} /&gt;;
};

export default App;
</code></pre>
<p>Bu örnekte, <code>Button</code> bileşeni farklı metinler ve tıklama olayları ile özelleştirilebilir.</p>
<h2 id="3-dinamik-render-etme-dynamic-rendering"><a class="header" href="#3-dinamik-render-etme-dynamic-rendering">3. Dinamik Render Etme (Dynamic Rendering)</a></h2>
<p>React bileşenleri, props değerlerine göre koşullu olarak içerik gösterebilir.</p>
<p><strong>Örnek:</strong></p>
<pre><code class="language-jsx">// StatusMessage.jsx
import React from 'react';

const StatusMessage = ({ isLoading }) =&gt; {
  return (
    &lt;div&gt;
      {isLoading ? 'Loading...' : 'Data Loaded'}
    &lt;/div&gt;
  );
};

export default StatusMessage;

// App.jsx
import React, { useState, useEffect } from 'react';
import StatusMessage from './StatusMessage';

const App = () =&gt; {
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      setLoading(false);
    }, 3000);
  }, []);

  return &lt;StatusMessage isLoading={loading} /&gt;;
};

export default App;
</code></pre>
<p>Bu örnekte, <code>StatusMessage</code> bileşeni <code>isLoading</code> prop'una göre farklı içerikler gösterir.</p>
<h2 id="4-olay-İşleme-event-handling"><a class="header" href="#4-olay-İşleme-event-handling">4. Olay İşleme (Event Handling)</a></h2>
<p>React bileşenlerinde olay işleyicileri props aracılığıyla geçirilebilir.</p>
<p><strong>Örnek:</strong></p>
<pre><code class="language-jsx">// ClickableButton.jsx
import React from 'react';

const ClickableButton = ({ onClick }) =&gt; {
  return &lt;button onClick={onClick}&gt;Click Me&lt;/button&gt;;
};

export default ClickableButton;

// App.jsx
import React from 'react';
import ClickableButton from './ClickableButton';

const App = () =&gt; {
  const handleClick = () =&gt; {
    alert('Button was clicked!');
  };

  return &lt;ClickableButton onClick={handleClick} /&gt;;
};

export default App;
</code></pre>
<p>Bu örnekte, <code>ClickableButton</code> bileşeni bir tıklama olayı işleyicisi ile birlikte kullanılır.</p>
<h2 id="5-bileşen-kompozisyonu-composition"><a class="header" href="#5-bileşen-kompozisyonu-composition">5. Bileşen Kompozisyonu (Composition)</a></h2>
<p>React bileşenleri, diğer bileşenleri props olarak alabilir, bu da daha esnek ve modüler bir yapı sağlar.</p>
<p><strong>Örnek:</strong></p>
<pre><code class="language-jsx">// Container.jsx
import React from 'react';

const Container = ({ children }) =&gt; {
  return &lt;div className="container"&gt;{children}&lt;/div&gt;;
};

export default Container;

// App.jsx
import React from 'react';
import Container from './Container';

const App = () =&gt; {
  return (
    &lt;Container&gt;
      &lt;h1&gt;Hello, World!&lt;/h1&gt;
      &lt;p&gt;This is a paragraph inside a container.&lt;/p&gt;
    &lt;/Container&gt;
  );
};

export default App;
</code></pre>
<p>Bu örnekte, <code>Container</code> bileşeni, içeriğini çocuk bileşenler olarak alır.</p>
<h1 id="uygulama-adımları"><a class="header" href="#uygulama-adımları">Uygulama Adımları</a></h1>
<h2 id="1-bileşen-klasörü-oluşturma"><a class="header" href="#1-bileşen-klasörü-oluşturma">1. Bileşen Klasörü Oluşturma</a></h2>
<p>Projenizin <code>src</code> dizininde bileşenlerinizi düzenli tutmak için <code>components</code> adlı bir klasör oluşturun.</p>
<h2 id="2-yeni-bir-bileşen-dosyası-oluşturma"><a class="header" href="#2-yeni-bir-bileşen-dosyası-oluşturma">2. Yeni Bir Bileşen Dosyası Oluşturma</a></h2>
<p><code>components</code> klasörü içinde, <code>Greeting.jsx</code> adlı yeni bir dosya oluşturun.</p>
<h2 id="3-reacti-İçe-aktarma"><a class="header" href="#3-reacti-İçe-aktarma">3. React'i İçe Aktarma</a></h2>
<p><code>Greeting.jsx</code> dosyasını açın ve React kütüphanesini içe aktarın.</p>
<pre><code class="language-jsx">import React from 'react';
</code></pre>
<h2 id="4-fonksiyonel-bileşen-oluşturma"><a class="header" href="#4-fonksiyonel-bileşen-oluşturma">4. Fonksiyonel Bileşen Oluşturma</a></h2>
<p><code>Greeting</code> adında yeni bir fonksiyonel bileşen tanımlayın. Bu bileşen, bir argüman olarak <code>props</code> alır.</p>
<pre><code class="language-jsx">const Greeting = (props) =&gt; {
  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
};
</code></pre>
<h2 id="5-props-kullanımı"><a class="header" href="#5-props-kullanımı">5. Props Kullanımı</a></h2>
<p><code>props</code> nesnesini kullanarak bileşene geçirilen özellikleri erişin ve kullanın.</p>
<h2 id="6-bileşeni-dışa-aktarma"><a class="header" href="#6-bileşeni-dışa-aktarma">6. Bileşeni Dışa Aktarma</a></h2>
<p>Bileşeninizi diğer kısımlarda kullanabilmek için dışa aktarın.</p>
<pre><code class="language-jsx">export default Greeting;
</code></pre>
<h2 id="7-bileşeni-props-ile-kullanma"><a class="header" href="#7-bileşeni-props-ile-kullanma">7. Bileşeni Props ile Kullanma</a></h2>
<p>Başka bir bileşende <code>Greeting</code> bileşenini kullanmak için önce onu içe aktarın ve ardından props ile çağırın.</p>
<pre><code class="language-jsx">// App.jsx
import React from 'react';
import Greeting from './components/Greeting';

const App = () =&gt; {
  return &lt;Greeting name="John Doe" /&gt;;
};

export default App;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ürün-vitrini-oluşturma"><a class="header" href="#Ürün-vitrini-oluşturma">Ürün Vitrini Oluşturma</a></h1>
<h2 id="giriş-6"><a class="header" href="#giriş-6">Giriş</a></h2>
<p>Bu eğitimde, React bileşenleri ve props ile çalışma pratiği yaparak dinamik bir ürün listesi oluşturmayı hedefleyeceğiz. Bu eğitim, yeniden kullanılabilir bileşenler oluşturma, props aracılığıyla veri geçişi ve Tailwind CSS kullanarak bileşenleri stilize etme konularında becerilerinizi geliştirecektir.</p>
<h2 id="gereksinimler-3"><a class="header" href="#gereksinimler-3">Gereksinimler</a></h2>
<ol>
<li>Yeni bir React projesi kurun veya mevcut bir proje yapısını kullanın.</li>
<li>Projenin kaynak dizininde <code>components</code> adında bir klasör oluşturun.</li>
<li><code>components</code> klasörünün içinde <code>ProductList.jsx</code> adında yeni bir bileşen dosyası oluşturun.</li>
<li><code>ProductList</code> bileşenini, her ürün için aşağıdaki bilgileri içeren bir ürün listesi render edecek şekilde uygulayın:
<ul>
<li>Ürün adı</li>
<li>Ürün resmi (Yer tutucu bir resim veya gerçek bir resim URL'si kullanın)</li>
<li>Ürün fiyatı</li>
<li>Ürün açıklaması</li>
</ul>
</li>
<li>Ürün nesnelerini içeren bir dizi saklamak için <code>productsData</code> gibi ayrı bir veri dosyası oluşturun. Her ürün nesnesi, <code>ProductList</code> bileşeninde ürünü render etmek için gerekli bilgileri içermelidir.</li>
<li>Ürün verilerini, ana bileşenden veya ayrı bir dosyadan <code>ProductList</code> bileşenine props olarak geçirin.</li>
<li>Tailwind CSS sınıflarını kullanarak ürün listesi ve bireysel ürün kartlarını görsel olarak çekici düzenler elde edecek şekilde stilize edin.</li>
</ol>
<h2 id="projenin-oluşturulması"><a class="header" href="#projenin-oluşturulması">Projenin Oluşturulması</a></h2>
<h2 id="adım-1-proje-kurulumu"><a class="header" href="#adım-1-proje-kurulumu">Adım 1: Proje Kurulumu</a></h2>
<p>Yeni bir React projesi oluşturmak için aşağıdaki komutu kullanın:</p>
<pre><code class="language-bash">npx create-react-app product-showcase
cd product-showcase
</code></pre>
<p>Tailwind CSS'i projeye ekleyin:</p>
<pre><code class="language-bash">npm install -D tailwindcss
npx tailwindcss init
</code></pre>
<p><code>tailwind.config.js</code> dosyasını aşağıdaki gibi yapılandırın:</p>
<pre><code class="language-js">/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</code></pre>
<p><code>src/index.css</code> dosyasına aşağıdaki satırları ekleyin:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h2 id="adım-2-bileşen-klasörünün-ve-dosyasının-oluşturulması"><a class="header" href="#adım-2-bileşen-klasörünün-ve-dosyasının-oluşturulması">Adım 2: Bileşen Klasörünün ve Dosyasının Oluşturulması</a></h2>
<p><code>src</code> dizininde <code>components</code> adında bir klasör oluşturun ve bu klasörde <code>ProductList.jsx</code> dosyasını oluşturun.</p>
<h2 id="adım-3-productlist-bileşeninin-uygulanması"><a class="header" href="#adım-3-productlist-bileşeninin-uygulanması">Adım 3: ProductList Bileşeninin Uygulanması</a></h2>
<p><code>ProductList.jsx</code> dosyasının içeriği aşağıdaki gibi olmalıdır:</p>
<pre><code class="language-jsx">import React from 'react';

const ProductList = ({ products }) =&gt; {
  return (
    &lt;div className="grid grid-cols-1 md:grid-cols-3 gap-6"&gt;
      {products.map((product) =&gt; (
        &lt;div key={product.id} className="bg-white p-4 rounded-lg shadow-md"&gt;
          &lt;img src={product.image} alt={product.name} className="w-full h-48 object-cover rounded-t-lg"/&gt;
          &lt;div className="mt-4"&gt;
            &lt;h2 className="text-lg font-semibold"&gt;{product.name}&lt;/h2&gt;
            &lt;p className="text-gray-700"&gt;${product.price}&lt;/p&gt;
            &lt;p className="mt-2 text-gray-600"&gt;{product.description}&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
};

export default ProductList;
</code></pre>
<h2 id="adım-4-Ürün-verilerinin-oluşturulması"><a class="header" href="#adım-4-Ürün-verilerinin-oluşturulması">Adım 4: Ürün Verilerinin Oluşturulması</a></h2>
<p><code>src</code> dizininde <code>productsData.js</code> dosyasını oluşturun ve aşağıdaki içeriği ekleyin:</p>
<pre><code class="language-js">const productsData = [
  {
    id: 1,
    name: "Ürün 1",
    image: "https://via.placeholder.com/150",
    price: 100,
    description: "Bu, ürün 1 için bir açıklamadır."
  },
  {
    id: 2,
    name: "Ürün 2",
    image: "https://via.placeholder.com/150",
    price: 150,
    description: "Bu, ürün 2 için bir açıklamadır."
  },
  {
    id: 3,
    name: "Ürün 3",
    image: "https://via.placeholder.com/150",
    price: 200,
    description: "Bu, ürün 3 için bir açıklamadır."
  }
];

export default productsData;
</code></pre>
<h2 id="adım-5-ana-bileşen-ve-veri-geçişi"><a class="header" href="#adım-5-ana-bileşen-ve-veri-geçişi">Adım 5: Ana Bileşen ve Veri Geçişi</a></h2>
<p><code>src/App.js</code> dosyasını aşağıdaki gibi düzenleyin:</p>
<pre><code class="language-jsx">import React from 'react';
import ProductList from './components/ProductList';
import productsData from './productsData';

function App() {
  return (
    &lt;div className="App container mx-auto p-4"&gt;
      &lt;h1 className="text-2xl font-bold mb-4"&gt;Ürün Vitrini&lt;/h1&gt;
      &lt;ProductList products={productsData} /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<h2 id="adım-6-projenin-githuba-yüklenmesi"><a class="header" href="#adım-6-projenin-githuba-yüklenmesi">Adım 6: Projenin GitHub'a Yüklenmesi</a></h2>
<p>Yeni bir GitHub deposu oluşturun ve projeyi yüklemek için aşağıdaki komutları kullanın:</p>
<pre><code class="language-bash">git init
git add .
git commit -m "İlk commit"
git remote add origin &lt;GitHub_depo_URL&gt;
git push -u origin master
</code></pre>
<h2 id="sonuç-7"><a class="header" href="#sonuç-7">Sonuç</a></h2>
<p>Bu eğitimde, React ile yeniden kullanılabilir bileşenler oluşturma, props aracılığıyla veri geçişi ve Tailwind CSS kullanarak bileşenleri stilize etme konularında becerilerinizi geliştirdiniz. Bu beceriler, modern web geliştirme süreçlerinde önemli rol oynamaktadır ve daha karmaşık uygulamaların temelini oluşturur. Projenizi geliştirmeye ve özelleştirmeye devam ederek bu temel becerileri daha da güçlendirebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling-and-media"><a class="header" href="#styling-and-media">Styling and Media</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tailwind-cssin-react-vite-uygulamasına-kurulumu"><a class="header" href="#tailwind-cssin-react-vite-uygulamasına-kurulumu">Tailwind CSS'in React (Vite) Uygulamasına Kurulumu</a></h1>
<h2 id="giriş-7"><a class="header" href="#giriş-7">Giriş</a></h2>
<p>Bu eğitimde, bir React uygulamasına Tailwind CSS'in nasıl kurulacağını adım adım açıklayacağız. Bu süreçte, Vite yapılandırma aracını kullanacağız. Eğitim boyunca, yazılım geliştirme alanındaki titizlik ve standartlara uygun, iyi yapılandırılmış kod parçacıkları ile örnekler sunulacaktır.</p>
<h2 id="tailwind-cssin-kurulumu"><a class="header" href="#tailwind-cssin-kurulumu">Tailwind CSS'in Kurulumu</a></h2>
<h3 id="1-tailwind-css-ve-bağımlılıklarının-kurulumu"><a class="header" href="#1-tailwind-css-ve-bağımlılıklarının-kurulumu">1. Tailwind CSS ve Bağımlılıklarının Kurulumu</a></h3>
<p>İlk adım olarak, Tailwind CSS ve gerekli bağımlılıklarını npm kullanarak projeye dahil etmeliyiz. Terminali açarak aşağıdaki komutu çalıştırın:</p>
<pre><code class="language-bash">npm install -D tailwindcss postcss autoprefixer
</code></pre>
<p>Bu komut, <code>tailwindcss</code>, <code>postcss</code> ve <code>autoprefixer</code> paketlerini geliştirici bağımlılıkları olarak (development dependencies) projeye ekleyecektir.</p>
<h3 id="2-yapılandırma-dosyalarının-oluşturulması"><a class="header" href="#2-yapılandırma-dosyalarının-oluşturulması">2. Yapılandırma Dosyalarının Oluşturulması</a></h3>
<p>Yapılandırma dosyalarını oluşturmak için aşağıdaki komutu çalıştırın:</p>
<pre><code class="language-bash">npx tailwindcss init -p
</code></pre>
<p>Bu komut, <code>tailwind.config.cjs</code> ve <code>postcss.config.cjs</code> dosyalarını projeye ekleyecektir. Bu dosyalar Tailwind ve PostCSS yapılandırmaları için kullanılacaktır.</p>
<h3 id="3-kaynak-yollarının-yapılandırılması"><a class="header" href="#3-kaynak-yollarının-yapılandırılması">3. Kaynak Yollarının Yapılandırılması</a></h3>
<p>Tailwind'in projedeki dosyaları tanıması için <code>tailwind.config.cjs</code> dosyasını açın ve <code>content</code> bölümüne aşağıdaki yolları ekleyin:</p>
<pre><code class="language-javascript">module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</code></pre>
<p>Bu yapılandırma, Tailwind'in <code>index.html</code> ve <code>src</code> klasörü altındaki tüm JavaScript ve TypeScript dosyalarını izlemesini sağlar.</p>
<h3 id="4-tailwind-yönergelerinin-eklenmesi"><a class="header" href="#4-tailwind-yönergelerinin-eklenmesi">4. Tailwind Yönergelerinin Eklenmesi</a></h3>
<p>Tailwind CSS'i kullanabilmek için <code>./src/index.css</code> dosyasına aşağıdaki Tailwind direktiflerini ekleyin:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<p>Bu direktifler, Tailwind'in temel stillerini, bileşenlerini ve yardımcı sınıflarını projenize dahil eder.</p>
<h3 id="5-vite-sunucusunun-başlatılması"><a class="header" href="#5-vite-sunucusunun-başlatılması">5. Vite Sunucusunun Başlatılması</a></h3>
<p>Vite geliştirme sunucusunu başlatmak için terminalde aşağıdaki komutu çalıştırın:</p>
<pre><code class="language-bash">npm run dev
</code></pre>
<p>Bu komut, Vite sunucusunu başlatarak projenizi yerel sunucuda çalıştıracaktır. Başarılı bir şekilde çalıştırıldığında, terminalde benzer bir mesaj görmelisiniz:</p>
<pre><code>  VITE v2.7.10  ready in 300ms
  ➜  Local:   http://localhost:3000/
  ➜  Network: use `--host` to expose
</code></pre>
<h3 id="6-tailwind-css-ile-yazmaya-başlama"><a class="header" href="#6-tailwind-css-ile-yazmaya-başlama">6. Tailwind CSS ile Yazmaya Başlama</a></h3>
<p>Artık Tailwind CSS sınıflarını kullanarak stil vermeye başlayabilirsiniz. Örneğin, <code>App.js</code> dosyanıza aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">function App() {
  return (
    &lt;div className="App"&gt;
      &lt;h1 className="text-3xl font-bold bg-red-500 text-center"&gt;
        Merhaba, React ve Tailwind!
      &lt;/h1&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>Bu örnekte, <code>h1</code> etiketine Tailwind CSS sınıfları eklenerek büyük, kalın, kırmızı arka planlı ve ortalanmış bir başlık oluşturulmuştur.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resimlerin-İçe-aktarılması-ve-kullanımı"><a class="header" href="#resimlerin-İçe-aktarılması-ve-kullanımı">Resimlerin İçe Aktarılması ve Kullanımı</a></h1>
<p>Bu eğitimde, React projelerinizde yerel resimleri nasıl içe aktaracağınızı ve kullanacağınızı ayrıntılı ve kapsamlı bir şekilde ele alacağız. Adımlar, herhangi bir hatayı eleştirel bir şekilde değerlendirerek bilimsel ve titiz bir yaklaşımla sunulacaktır. Eğitim boyunca kullanılan kod parçacıkları, yüksek kalite standartlarına uygun olarak yapılandırılmıştır.</p>
<h2 id="1-proje-yapısının-oluşturulması"><a class="header" href="#1-proje-yapısının-oluşturulması">1. Proje Yapısının Oluşturulması</a></h2>
<p>Öncelikle, projenizin <code>src</code> dizininde bileşenlerinizi düzenli tutmak için bir <code>components</code> adlı yeni bir klasör oluşturun. Eğer bu klasör zaten mevcutsa, bu adımı atlayabilirsiniz.</p>
<pre><code class="language-sh">mkdir src/components
</code></pre>
<h2 id="2-bileşen-dosyasının-oluşturulması"><a class="header" href="#2-bileşen-dosyasının-oluşturulması">2. Bileşen Dosyasının Oluşturulması</a></h2>
<p><code>components</code> klasörünün içinde <code>MyComponent.jsx</code> adlı yeni bir dosya oluşturun. Bu dosya, fonksiyonel bileşeninizi içerecektir.</p>
<pre><code class="language-sh">touch src/components/MyComponent.jsx
</code></pre>
<h2 id="3-resim-dizininin-düzenlenmesi"><a class="header" href="#3-resim-dizininin-düzenlenmesi">3. Resim Dizininin Düzenlenmesi</a></h2>
<p>Resmi bir React bileşenine içe aktarmadan önce, resmin projenizin dizin yapısında uygun bir konumda olduğundan emin olun. Bu, resmin <code>src/Images</code> klasöründe bulunması gerektiği anlamına gelir. Gerekli dizini oluşturun ve resimleri bu klasöre yerleştirin.</p>
<pre><code class="language-sh">mkdir src/Images
</code></pre>
<p>Örnek olarak, <code>example.png</code> adlı bir resmi <code>src/Images</code> dizinine yerleştirin.</p>
<h2 id="4-bileşen-dosyasının-açılması"><a class="header" href="#4-bileşen-dosyasının-açılması">4. Bileşen Dosyasının Açılması</a></h2>
<p>Görüntüyü göstermek istediğiniz React bileşenini açın. Bu örnekte, <code>MyComponent.jsx</code> dosyasını açacağız ve resmi nasıl göstereceğimizi açıklayacağız.</p>
<pre><code class="language-jsx">// src/components/MyComponent.jsx

import React from 'react';
import exampleImage from '../Images/example.png';

const MyComponent = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Resim Örneği&lt;/h1&gt;
      &lt;img src={exampleImage} alt="Example" /&gt;
    &lt;/div&gt;
  );
};

export default MyComponent;
</code></pre>
<h2 id="5-bileşeni-uygulamada-gösterme"><a class="header" href="#5-bileşeni-uygulamada-gösterme">5. Bileşeni Uygulamada Gösterme</a></h2>
<p>Uygulamanızda resmi göstermek için <code>MyComponent</code> bileşenini render edin. Bunun için <code>App.jsx</code> dosyasını açın ve bileşeni ekleyin.</p>
<pre><code class="language-jsx">// src/App.jsx

import React from 'react';
import MyComponent from './components/MyComponent';

const App = () =&gt; {
  return (
    &lt;div className="App"&gt;
      &lt;MyComponent /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<h2 id="6-alternatif-yöntemler-resimlerin-srcimages-klasöründen-İçe-aktarılması"><a class="header" href="#6-alternatif-yöntemler-resimlerin-srcimages-klasöründen-İçe-aktarılması">6. Alternatif Yöntemler: Resimlerin src/Images Klasöründen İçe Aktarılması</a></h2>
<p>Bu yöntem, resimleri <code>src/Images</code> klasöründen içe aktarıp kullanmayı kapsamaktadır. Adımlar, yukarıda belirtilen adımlarla büyük ölçüde benzerdir, ancak burada resimlerin farklı bir klasörden içe aktarılması vurgulanmaktadır.</p>
<ol>
<li><code>components</code> klasörünü oluşturun ve <code>MyComponent.jsx</code> dosyasını ekleyin.</li>
<li>Resimlerinizi <code>src/Images</code> klasörüne yerleştirin.</li>
<li><code>MyComponent.jsx</code> dosyasını açın ve resimleri içe aktarın.</li>
<li>Uygulamanızda bileşeni render edin.</li>
</ol>
<p>Kod örneği:</p>
<pre><code class="language-jsx">// src/components/MyComponent.jsx

import React from 'react';
import exampleImage from '../İmages/example.png';

const MyComponent = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Resim Örneği&lt;/h1&gt;
      &lt;img src={exampleImage} alt="Example" /&gt;
    &lt;/div&gt;
  );
};

export default MyComponent;
</code></pre>
<p>Bu eğitim, React projelerinde yerel resimlerin nasıl içe aktarılacağını ve kullanılacağını sistematik bir şekilde açıklamaktadır. Her adım, yazılım geliştirme alanındaki en iyi uygulamalar ve standartlar göz önünde bulundurularak hazırlanmıştır. React bileşenlerinizde resim kullanırken bu adımları takip edebilir ve gerektiğinde bileşenlerinizi ve dizin yapınızı düzenleyerek projelerinizi daha verimli hale getirebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-icons"><a class="header" href="#react-icons">React-Icons</a></h1>
<h2 id="giriş-8"><a class="header" href="#giriş-8">Giriş</a></h2>
<p>React-Icons, React projelerinizde popüler ikonları kolayca kullanmanıza olanak tanıyan bir kütüphanedir. Bu eğitimde, react-icons kütüphanesinin nasıl kurulacağını ve kullanılacağını detaylı bir şekilde ele alacağız. Bu süreç boyunca, belirli bir ikonun nasıl ekleneceğini ve kullanılacağını göstereceğiz. Eğitimin sonunda, uygulamanızda çeşitli ikonları profesyonel bir şekilde kullanabileceksiniz.</p>
<h2 id="adım-1-react-icons-kütüphanesini-kurma"><a class="header" href="#adım-1-react-icons-kütüphanesini-kurma">Adım 1: React-Icons Kütüphanesini Kurma</a></h2>
<p>React-Icons kütüphanesini projenize eklemek için aşağıdaki npm komutunu kullanabilirsiniz:</p>
<pre><code class="language-bash">npm install react-icons
</code></pre>
<p>Bu komut, React-Icons kütüphanesini projenize dahil eder ve gerekli bağımlılıkları indirir.</p>
<h2 id="adım-2-proje-yapısını-hazırlama"><a class="header" href="#adım-2-proje-yapısını-hazırlama">Adım 2: Proje Yapısını Hazırlama</a></h2>
<p>Proje yapısında daha düzenli bir görünüm elde etmek için, <code>src</code> dizini içinde bir <code>components</code> klasörü oluşturalım. Bu klasörde, ikonları kullanacağımız bileşen dosyalarını saklayacağız.</p>
<pre><code class="language-bash">mkdir src/components
</code></pre>
<h2 id="adım-3-react-bileşeninde-İkon-kullanma"><a class="header" href="#adım-3-react-bileşeninde-İkon-kullanma">Adım 3: React Bileşeninde İkon Kullanma</a></h2>
<p>Şimdi, <code>components</code> klasörü içinde <code>MyComponent.jsx</code> adlı bir dosya oluşturun ve bu dosyada bir ikon kullanacağız. React-Icons kütüphanesi, FontAwesome, Material Design ve diğer çeşitli ikon kütüphanelerinden ikonlar içerir. Bu örnekte, FontAwesome'dan bir ikon kullanacağız.</p>
<h3 id="31-İkonu-İçeri-aktarma"><a class="header" href="#31-İkonu-İçeri-aktarma">3.1: İkonu İçeri Aktarma</a></h3>
<p>Öncelikle, kullanmak istediğimiz ikonu <code>react-icons</code> kütüphanesinden içeri aktaralım:</p>
<pre><code class="language-jsx">import React from "react";
import { BiSolidHomeHeart } from "react-icons/bi";

const MyComponent = () =&gt; {
  return (
    &lt;div&gt;
      &lt;BiSolidHomeHeart /&gt;
    &lt;/div&gt;
  );
};

export default MyComponent;
</code></pre>
<p>Bu kod parçacığında, <code>BiSolidHomeHeart</code> adlı ikonu <code>react-icons/bi</code> modülünden içe aktardık ve bir React bileşeninde kullandık.</p>
<h2 id="adım-4-appjs-dosyasında-bileşeni-kullanma"><a class="header" href="#adım-4-appjs-dosyasında-bileşeni-kullanma">Adım 4: App.js Dosyasında Bileşeni Kullanma</a></h2>
<p>Son olarak, <code>App.js</code> dosyasında <code>MyComponent</code> bileşenini içe aktaralım ve kullanalım:</p>
<pre><code class="language-jsx">import React from "react";
import MyComponent from "./components/MyComponent";

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;MyComponent /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>Bu adımda, <code>MyComponent</code> bileşenini <code>App.js</code> dosyasına dahil ettik ve JSX içinde kullandık.</p>
<h2 id="kod-Örneği"><a class="header" href="#kod-Örneği">Kod Örneği</a></h2>
<p>Yukarıdaki adımları takip ederek, ikonları React bileşenlerinde kullanabilirsiniz. Aşağıda tam bir örnek sunulmaktadır:</p>
<h3 id="mycomponentjsx"><a class="header" href="#mycomponentjsx"><code>MyComponent.jsx</code>:</a></h3>
<pre><code class="language-jsx">import React from "react";
import { BiSolidHomeHeart } from "react-icons/bi";

const MyComponent = () =&gt; {
  return (
    &lt;div&gt;
      &lt;BiSolidHomeHeart /&gt;
    &lt;/div&gt;
  );
};

export default MyComponent;
</code></pre>
<h3 id="appjs"><a class="header" href="#appjs"><code>App.js</code>:</a></h3>
<pre><code class="language-jsx">import React from "react";
import MyComponent from "./components/MyComponent";

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;MyComponent /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<h2 id="sonuç-8"><a class="header" href="#sonuç-8">Sonuç</a></h2>
<p>Bu eğitimde, React-Icons kütüphanesini nasıl kuracağınızı, projenize nasıl dahil edeceğinizi ve bileşenlerde nasıl kullanacağınızı öğrendiniz. Bu bilgiyle, React projelerinizde popüler ikonları kolayca kullanabilirsiniz. Daha fazla ikon ve kütüphane seçenekleri için <a href="https://react-icons.github.io/react-icons/">React-Icons resmi dokümantasyonunu</a> ziyaret edebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yazılım-geliştirici-eğitim-kılavuzu"><a class="header" href="#yazılım-geliştirici-eğitim-kılavuzu">Yazılım Geliştirici Eğitim Kılavuzu</a></h1>
<h2 id="giriş-9"><a class="header" href="#giriş-9">Giriş</a></h2>
<p>Bu eğitim, React bileşenleri kullanarak görsel olarak çekici ve duyarlı bir Hizmet Sayfası oluşturmayı amaçlamaktadır. Eğitim boyunca, Tailwind CSS kullanarak stil verme, props kullanımı ve bileşenlerin nasıl oluşturulacağı hakkında detaylı bilgi verilecektir.</p>
<h2 id="gereksinimler-4"><a class="header" href="#gereksinimler-4">Gereksinimler</a></h2>
<ol>
<li>
<p><strong>Kurulum:</strong></p>
<ul>
<li>Yeni bir React uygulaması başlatın.</li>
<li>Tailwind CSS'i React projenize kurun.</li>
</ul>
</li>
<li>
<p><strong>Bileşenler:</strong></p>
<ul>
<li><code>components</code> adlı bir klasör oluşturun.</li>
<li>Bu klasörün içinde <code>ServiceCard.js</code> adlı yeni bir bileşen oluşturun.</li>
<li>Bu bileşen, görüntü, metin, paragraf ve düğme etiketi için props alacaktır.</li>
</ul>
</li>
<li>
<p><strong>Hizmet Sayfası:</strong></p>
<ul>
<li><code>ServicePage.js</code> adlı yeni bir bileşen oluşturun.</li>
<li>Bu sayfanın başlığı "Services" olmalıdır.</li>
<li><code>ServiceCard</code> bileşenini üç kez entegre edin, her kart için farklı props geçirin.</li>
</ul>
</li>
<li>
<p><strong>Tailwind CSS ile Stil Verme:</strong></p>
<ul>
<li>Duyarlı tasarım ekleyin:
<ul>
<li>Masaüstü için: Üç hizmet kartını yan yana görüntüleyin.</li>
<li>Mobil için: Kartlar üst üste yığılmalıdır.</li>
</ul>
</li>
<li>Her <code>ServiceCard</code> şu öğeleri içermelidir:
<ul>
<li>Bir görüntü</li>
<li>Bir metin başlığı</li>
<li>Bir paragraf</li>
<li>Bir düğme</li>
</ul>
</li>
<li>Tüm kartlar bir hover efekti içermelidir.</li>
<li>Görselliği artırmak için ikonlar kullanın.</li>
</ul>
</li>
</ol>
<h2 id="detaylı-adımlar"><a class="header" href="#detaylı-adımlar">Detaylı Adımlar</a></h2>
<h3 id="1-react-uygulamasını-başlatma"><a class="header" href="#1-react-uygulamasını-başlatma">1. React Uygulamasını Başlatma</a></h3>
<pre><code class="language-bash">npx create-react-app service-page
cd service-page
</code></pre>
<h3 id="2-tailwind-css-kurulumu"><a class="header" href="#2-tailwind-css-kurulumu">2. Tailwind CSS Kurulumu</a></h3>
<pre><code class="language-bash">npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
</code></pre>
<p><code>tailwind.config.js</code> dosyasını aşağıdaki gibi yapılandırın:</p>
<pre><code class="language-javascript">/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</code></pre>
<p><code>src/index.css</code> dosyasını aşağıdaki gibi güncelleyin:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h3 id="3-bileşenlerin-oluşturulması"><a class="header" href="#3-bileşenlerin-oluşturulması">3. Bileşenlerin Oluşturulması</a></h3>
<h4 id="servicecardjs"><a class="header" href="#servicecardjs">ServiceCard.js</a></h4>
<pre><code class="language-javascript">import React from 'react';

const ServiceCard = ({ image, title, description, buttonLabel }) =&gt; {
  return (
    &lt;div className="max-w-sm rounded overflow-hidden shadow-lg hover:shadow-2xl transition-shadow duration-300"&gt;
      &lt;img className="w-full" src={image} alt={title} /&gt;
      &lt;div className="px-6 py-4"&gt;
        &lt;div className="font-bold text-xl mb-2"&gt;{title}&lt;/div&gt;
        &lt;p className="text-gray-700 text-base"&gt;{description}&lt;/p&gt;
      &lt;/div&gt;
      &lt;div className="px-6 pt-4 pb-2"&gt;
        &lt;button className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"&gt;
          {buttonLabel}
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default ServiceCard;
</code></pre>
<h4 id="servicepagejs"><a class="header" href="#servicepagejs">ServicePage.js</a></h4>
<pre><code class="language-javascript">import React from 'react';
import ServiceCard from './components/ServiceCard';

const ServicePage = () =&gt; {
  const services = [
    {
      image: 'https://via.placeholder.com/150',
      title: 'Service 1',
      description: 'This is the description for service 1.',
      buttonLabel: 'Learn More'
    },
    {
      image: 'https://via.placeholder.com/150',
      title: 'Service 2',
      description: 'This is the description for service 2.',
      buttonLabel: 'Learn More'
    },
    {
      image: 'https://via.placeholder.com/150',
      title: 'Service 3',
      description: 'This is the description for service 3.',
      buttonLabel: 'Learn More'
    },
  ];

  return (
    &lt;div className="container mx-auto"&gt;
      &lt;h1 className="text-4xl font-bold text-center my-8"&gt;Services&lt;/h1&gt;
      &lt;div className="flex flex-wrap justify-around"&gt;
        {services.map((service, index) =&gt; (
          &lt;ServiceCard 
            key={index} 
            image={service.image} 
            title={service.title} 
            description={service.description} 
            buttonLabel={service.buttonLabel} 
          /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default ServicePage;
</code></pre>
<h3 id="4-stil-verme"><a class="header" href="#4-stil-verme">4. Stil Verme</a></h3>
<p>Tailwind CSS kullanarak bileşenlerin stilini aşağıdaki gibi verin:</p>
<ul>
<li>
<p><strong>Masaüstü Görünümü:</strong></p>
<pre><code class="language-css">.container {
  @apply flex flex-wrap justify-around;
}
</code></pre>
</li>
<li>
<p><strong>Mobil Görünümü:</strong></p>
<pre><code class="language-css">.container {
  @apply flex flex-col items-center;
}
</code></pre>
</li>
</ul>
<h3 id="Özet"><a class="header" href="#Özet">Özet</a></h3>
<p>Bu eğitimde, React ve Tailwind CSS kullanarak duyarlı bir Hizmet Sayfası oluşturmayı öğrendik. React bileşenlerini kullanarak dinamik ve yeniden kullanılabilir kod parçacıkları oluşturduk ve Tailwind CSS ile stil verdik. Bu yapı, modern web geliştirme standartlarına uygun olarak tasarlanmıştır ve geliştiricilere etkili ve verimli bir şekilde bileşen tabanlı kullanıcı arayüzleri oluşturma becerisi kazandırır.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uygulamada-birden-fazla-bileşen-render-etme"><a class="header" href="#uygulamada-birden-fazla-bileşen-render-etme">Uygulamada Birden Fazla Bileşen Render Etme</a></h1>
<h2 id="giriş-10"><a class="header" href="#giriş-10">Giriş</a></h2>
<p>"React'te birden fazla bileşeni render etme" kavramı, tek bir React uygulamasında birden fazla yeniden kullanılabilir ve bağımsız UI öğesinin görüntülenmesi sürecini ifade eder. Bu eğitimde, temel bileşenleri oluşturmaktan, bunları ana uygulama dosyasında nasıl kullanacağınıza kadar adım adım ilerleyeceğiz. Bu süreci adım adım takip ederek, React uygulamanızda bileşen tabanlı bir mimariyi nasıl kurabileceğinizi öğreneceksiniz.</p>
<h2 id="adım-1-bileşenler-için-yeni-bir-klasör-oluşturma"><a class="header" href="#adım-1-bileşenler-için-yeni-bir-klasör-oluşturma">Adım 1: Bileşenler için Yeni Bir Klasör Oluşturma</a></h2>
<p>Öncelikle, projenizin <code>src</code> dizininde <code>components</code> adında yeni bir klasör oluşturun. Bu klasör, uygulamanızda kullanacağınız tüm bileşen dosyalarını barındıracaktır.</p>
<pre><code class="language-bash">src/
  components/
</code></pre>
<h2 id="adım-2-bireysel-bileşen-dosyaları-oluşturma"><a class="header" href="#adım-2-bireysel-bileşen-dosyaları-oluşturma">Adım 2: Bireysel Bileşen Dosyaları Oluşturma</a></h2>
<p><code>components</code> klasörünün içinde, her bir bileşen için ayrı dosyalar oluşturun. Örneğin, <code>Header.js</code>, <code>Content.js</code> ve <code>Footer.js</code> dosyalarını oluşturabilirsiniz. Bu dosyalar sırasıyla Header, Content ve Footer bileşenlerini temsil edecektir.</p>
<pre><code class="language-bash">src/
  components/
    Header.js
    Content.js
    Footer.js
</code></pre>
<h2 id="adım-3-bileşenleri-tanımlama-ve-İhraç-etme"><a class="header" href="#adım-3-bileşenleri-tanımlama-ve-İhraç-etme">Adım 3: Bileşenleri Tanımlama ve İhraç Etme</a></h2>
<p>Her bileşen dosyasında, işlevsel bir bileşen tanımlayın ve ihraç edin. İşte her bir bileşen için örnek kodlar:</p>
<p><strong>Header.jsx</strong></p>
<pre><code class="language-jsx">import React from 'react';

const Header = () =&gt; {
  return (
    &lt;header&gt;
      &lt;h1&gt;Başlık&lt;/h1&gt;
    &lt;/header&gt;
  );
};

export default Header;
</code></pre>
<p><strong>Content.jsx</strong></p>
<pre><code class="language-jsx">import React from 'react';

const Content = () =&gt; {
  return (
    &lt;main&gt;
      &lt;p&gt;İçerik burada görüntülenecek.&lt;/p&gt;
    &lt;/main&gt;
  );
};

export default Content;
</code></pre>
<p><strong>Footer.jsx</strong></p>
<pre><code class="language-jsx">import React from 'react';

const Footer = () =&gt; {
  return (
    &lt;footer&gt;
      &lt;p&gt;Footer metni burada yer alacak.&lt;/p&gt;
    &lt;/footer&gt;
  );
};

export default Footer;
</code></pre>
<h2 id="adım-4-bileşenleri-ana-uygulamada-İçe-aktarma-ve-render-etme"><a class="header" href="#adım-4-bileşenleri-ana-uygulamada-İçe-aktarma-ve-render-etme">Adım 4: Bileşenleri Ana Uygulamada İçe Aktarma ve Render Etme</a></h2>
<p>Bileşenlerinizi tanımlayıp ihraç ettikten sonra, ana uygulama dosyanız olan <code>src/App.jsx</code> dosyasını açın ve bileşenlerinizi içe aktararak render edin.</p>
<p><strong>App.jsx</strong></p>
<pre><code class="language-jsx">import React from 'react';
import Header from './components/Header';
import Content from './components/Content';
import Footer from './components/Footer';

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Header /&gt;
      &lt;Content /&gt;
      &lt;Footer /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<h2 id="sonuç-9"><a class="header" href="#sonuç-9">Sonuç</a></h2>
<p>Bu adımları takip ettiğinizde, uygulamanız çalıştırıldığında Header, Content ve Footer bileşenlerinin sırasıyla görüntülendiğini göreceksiniz. Her bir bileşenin bağımsız olarak tanımlanması ve ana uygulama dosyasında kullanılması, kodunuzu daha modüler ve yeniden kullanılabilir hale getirir.</p>
<p>Bu eğitim boyunca kullanılan kod örnekleri, React bileşenlerinin nasıl oluşturulacağı ve kullanılacağı konusunda temel bir anlayış sağlar. İleri düzeyde React geliştirmeleri için, bileşenler arasındaki veri akışı ve durum yönetimi konularını da incelemeniz önerilir.</p>
<p>Bu eğitim, React uygulamalarında bileşen tabanlı mimarinin temellerini anlamanıza yardımcı olmayı amaçlamaktadır. Daha derinlemesine bilgi ve örnekler için React dökümantasyonunu incelemenizi tavsiye ederiz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactte-stil-uygulama"><a class="header" href="#reactte-stil-uygulama"><strong>React'te Stil Uygulama</strong></a></h1>
<p>React'te bileşenleri stillendirmek için satır içi stiller, harici stil dosyaları veya CSS modülleri kullanabilirsiniz. İşte her yöntemin nasıl kullanılacağına dair bir açıklama:</p>
<h2 id="1-satır-İçi-stiller-inline-styles"><a class="header" href="#1-satır-İçi-stiller-inline-styles"><strong>1. Satır İçi Stiller (Inline Styles)</strong></a></h2>
<p>Satır içi stiller, doğrudan bileşenlere JavaScript nesneleri olarak uygulanır. Stil adları camelCase yazılır ve değerler string veya sayı olabilir.</p>
<h3 id="Örnek"><a class="header" href="#Örnek">Örnek:</a></h3>
<pre><code class="language-jsx">import React from 'react';

function InlineStyledComponent() {
  const style = {
    backgroundColor: 'lightblue',
    padding: '20px',
    borderRadius: '5px'
  };

  return (
    &lt;div style={style}&gt;
      Bu bir satır içi stil ile stillendirilmiş bileşen örneğidir.
    &lt;/div&gt;
  );
}

export default InlineStyledComponent;
</code></pre>
<h2 id="2-harici-stil-dosyaları-external-stylesheets"><a class="header" href="#2-harici-stil-dosyaları-external-stylesheets"><strong>2. Harici Stil Dosyaları (External Stylesheets)</strong></a></h2>
<p>Harici stil dosyası kullanmak için bir CSS dosyası oluşturun ve bu dosyayı bileşeninize dahil edin.</p>
<h3 id="Örnek-1"><a class="header" href="#Örnek-1">Örnek:</a></h3>
<p><strong>styles.css:</strong></p>
<pre><code class="language-css">.external-styled-component {
  background-color: lightgreen;
  padding: 20px;
  border-radius: 5px;
}
</code></pre>
<p><strong>Component.js:</strong></p>
<pre><code class="language-jsx">import React from 'react';
import './styles.css';

function ExternalStyledComponent() {
  return (
    &lt;div className="external-styled-component"&gt;
      Bu bir harici stil dosyası ile stillendirilmiş bileşen örneğidir.
    &lt;/div&gt;
  );
}

export default ExternalStyledComponent;
</code></pre>
<h2 id="3-css-modülleri-css-modules"><a class="header" href="#3-css-modülleri-css-modules"><strong>3. CSS Modülleri (CSS Modules)</strong></a></h2>
<p>CSS Modülleri, küresel ad alanı çakışmalarını önleyen bileşen kapsamlı stiller kullanmanın bir yoludur. CSS Modülleri kullanmak için, CSS dosya adını <code>.module.css</code> ile bitirin ve bu dosyayı bileşeninizde içe aktarın.</p>
<h3 id="Örnek-2"><a class="header" href="#Örnek-2">Örnek:</a></h3>
<p><strong>styles.module.css:</strong></p>
<pre><code class="language-css">.module-styled-component {
  background-color: lightcoral;
  padding: 20px;
  border-radius: 5px;
}
</code></pre>
<p><strong>Component.js:</strong></p>
<pre><code class="language-jsx">import React from 'react';
import styles from './styles.module.css';

function ModuleStyledComponent() {
  return (
    &lt;div className={styles['module-styled-component']}&gt;
      Bu bir CSS modülü ile stillendirilmiş bileşen örneğidir.
    &lt;/div&gt;
  );
}

export default ModuleStyledComponent;
</code></pre>
<h2 id="yöntemlerin-karşılaştırılması"><a class="header" href="#yöntemlerin-karşılaştırılması"><strong>Yöntemlerin Karşılaştırılması</strong></a></h2>
<ul>
<li>
<p><strong>Satır İçi Stiller:</strong></p>
<ul>
<li><strong>Avantajlar:</strong> Basit ve hızlı kullanım.</li>
<li><strong>Dezavantajlar:</strong> Stil adlarının camelCase olması, büyük stil kuralları için okunabilirliği azaltabilir ve yeniden kullanılabilirliği düşürür.</li>
</ul>
</li>
<li>
<p><strong>Harici Stil Dosyaları:</strong></p>
<ul>
<li><strong>Avantajlar:</strong> HTML ve CSS ayrımı, daha iyi dosya organizasyonu ve stil kurallarının yeniden kullanılabilirliği.</li>
<li><strong>Dezavantajlar:</strong> Küresel ad çakışmaları ve stil izolasyonunun zayıf olması.</li>
</ul>
</li>
<li>
<p><strong>CSS Modülleri:</strong></p>
<ul>
<li><strong>Avantajlar:</strong> Bileşen bazında stil izolasyonu, küresel ad çakışmalarını önler.</li>
<li><strong>Dezavantajlar:</strong> Ek yapılandırma ve karmaşıklık.</li>
</ul>
</li>
</ul>
<p>Her yöntem, kullanım amacına ve projenin ihtiyaçlarına göre seçilebilir. Geliştiriciler, hangi stil yöntemiyle en verimli ve sürdürülebilir sonuçları alacaklarına karar vermelidir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-stil-kullanımı"><a class="header" href="#inline-stil-kullanımı">Inline Stil Kullanımı</a></h1>
<h2 id="giriş-11"><a class="header" href="#giriş-11">Giriş</a></h2>
<p>React projelerinde stil tanımlama yöntemlerinden biri olan "inline styles", özellikle dinamik ve komponent bazlı stillendirmede yaygın olarak kullanılır. Bu eğitimde, React'te inline stil kullanımını detaylandıracak, önemli noktalara dikkat çekerek ve doğru bilinen yanlışları eleştirerek kapsamlı bir kılavuz sunacağız. Eğitim boyunca yapılandırılmış ve açıklamalı kod parçacıkları ile konunun daha iyi anlaşılmasını hedefleyeceğiz.</p>
<h2 id="1-proje-yapılandırması"><a class="header" href="#1-proje-yapılandırması">1. Proje Yapılandırması</a></h2>
<p>React projesinde inline stil kullanımı için öncelikle doğru dosya yapısını kurmalıyız. Aşağıdaki adımları izleyerek proje yapınızı oluşturun:</p>
<ol>
<li>
<p><strong>Komponentler için klasör oluşturun</strong>: Proje dizininizin <code>src</code> klasörü içinde, <code>components</code> adında yeni bir klasör oluşturun (eğer zaten yoksa).</p>
<pre><code class="language-bash">mkdir src/components
</code></pre>
</li>
<li>
<p><strong>Yeni bir JSX dosyası oluşturun</strong>: <code>components</code> klasörü içinde, istediğiniz komponent adında yeni bir JSX dosyası oluşturun, örneğin <code>InlineStyledText.jsx</code>.</p>
<pre><code class="language-bash">touch src/components/InlineStyledText.jsx
</code></pre>
</li>
<li>
<p><strong>Komponenti oluşturun</strong>: <code>InlineStyledText.jsx</code> dosyasını açarak aşağıdaki gibi basit bir komponent tanımlayın.</p>
<pre><code class="language-jsx">// src/components/InlineStyledText.jsx
import React from 'react';

const InlineStyledText = () =&gt; {
  const style = {
    color: 'blue',
    fontSize: '20px',
    margin: '10px'
  };

  return (
    &lt;p style={style}&gt;Bu metin inline stil ile stilize edilmiştir.&lt;/p&gt;
  );
};

export default InlineStyledText;
</code></pre>
</li>
<li>
<p><strong>Komponenti kullanın</strong>: Parent komponentinizde veya <code>App.jsx</code> dosyasında <code>InlineStyledText</code> komponentini içe aktarın ve JSX içinde kullanın.</p>
<pre><code class="language-jsx">// src/App.jsx
import React from 'react';
import InlineStyledText from './components/InlineStyledText';

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;InlineStyledText /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
</li>
<li>
<p><strong>Geliştirme sunucusunu başlatın</strong>: Proje klasörüne gidin ve geliştirme sunucusunu başlatın.</p>
<pre><code class="language-bash">npm run dev
</code></pre>
</li>
</ol>
<h2 id="2-inline-stil-kullanımının-avantaj-ve-dezavantajları"><a class="header" href="#2-inline-stil-kullanımının-avantaj-ve-dezavantajları">2. Inline Stil Kullanımının Avantaj ve Dezavantajları</a></h2>
<p><strong>Avantajlar:</strong></p>
<ul>
<li><strong>Dinamik Stil</strong>: JavaScript değişkenleri kullanarak stilleri dinamik olarak değiştirebilirsiniz.</li>
<li><strong>Enkapsülasyon</strong>: Her komponentin kendi stili olduğu için stil çakışmaları minimize edilir.</li>
<li><strong>Kolaylık</strong>: Küçük ve basit stiller için hızlı ve kolay bir çözüm sunar.</li>
</ul>
<p><strong>Dezavantajlar:</strong></p>
<ul>
<li><strong>Bakım Zorluğu</strong>: Büyük projelerde inline stil kullanımı kodun okunabilirliğini ve bakımını zorlaştırabilir.</li>
<li><strong>Performans</strong>: Büyük ve kompleks stillerde performans sorunları yaşanabilir.</li>
<li><strong>Yeniden Kullanılabilirlik</strong>: Stil tanımları komponent seviyesinde olduğu için yeniden kullanılabilirliği düşüktür.</li>
</ul>
<h2 id="3-kritik-noktalar-ve-doğru-bilinen-yanlışlar"><a class="header" href="#3-kritik-noktalar-ve-doğru-bilinen-yanlışlar">3. Kritik Noktalar ve Doğru Bilinen Yanlışlar</a></h2>
<ol>
<li>
<p><strong>JavaScript Nesneleri ile Stil Tanımlama</strong>: Inline stil tanımlarken stil özellikleri JavaScript nesneleri olarak tanımlanır. CSS'deki kebab-case yerine camelCase kullanılır. Örneğin <code>background-color</code> yerine <code>backgroundColor</code>.</p>
<p>Yanlış:</p>
<pre><code class="language-jsx">const style = {
  'background-color': 'red'
};
</code></pre>
<p>Doğru:</p>
<pre><code class="language-jsx">const style = {
  backgroundColor: 'red'
};
</code></pre>
</li>
<li>
<p><strong>Sayı Değerleri</strong>: Birimler gerektiren CSS özelliklerinde (örneğin <code>px</code>, <code>em</code>), sayısal değerler string olarak verilmelidir.</p>
<p>Yanlış:</p>
<pre><code class="language-jsx">const style = {
  margin: 10
};
</code></pre>
<p>Doğru:</p>
<pre><code class="language-jsx">const style = {
  margin: '10px'
};
</code></pre>
</li>
<li>
<p><strong>Bileşik Stiller</strong>: Birden fazla stil özelliği aynı anda dinamik olarak değiştirilebilir.</p>
<p>Yanlış:</p>
<pre><code class="language-jsx">const style = {
  color: isActive ? 'green' : 'red'
};
</code></pre>
<p>Doğru:</p>
<pre><code class="language-jsx">const style = {
  color: isActive ? 'green' : 'red',
  fontWeight: isActive ? 'bold' : 'normal'
};
</code></pre>
</li>
</ol>
<h2 id="4-Örnekler-ve-uygulamalar"><a class="header" href="#4-Örnekler-ve-uygulamalar">4. Örnekler ve Uygulamalar</a></h2>
<p><strong>Durum Bazlı Stil Değiştirme</strong>:</p>
<pre><code class="language-jsx">// src/components/StatusStyledText.jsx
import React from 'react';

const StatusStyledText = ({ isActive }) =&gt; {
  const style = {
    color: isActive ? 'green' : 'red',
    fontWeight: isActive ? 'bold' : 'normal',
    fontSize: '16px'
  };

  return (
    &lt;p style={style}&gt;
      {isActive ? 'Aktif' : 'Pasif'}
    &lt;/p&gt;
  );
};

export default StatusStyledText;
</code></pre>
<p><strong>Dinamik Stil Değişimi</strong>:</p>
<pre><code class="language-jsx">// src/components/DynamicStyledButton.jsx
import React, { useState } from 'react';

const DynamicStyledButton = () =&gt; {
  const [isClicked, setIsClicked] = useState(false);

  const handleClick = () =&gt; {
    setIsClicked(!isClicked);
  };

  const style = {
    backgroundColor: isClicked ? 'blue' : 'gray',
    color: 'white',
    padding: '10px 20px',
    border: 'none',
    cursor: 'pointer'
  };

  return (
    &lt;button style={style} onClick={handleClick}&gt;
      {isClicked ? 'Tıklandı' : 'Tıkla'}
    &lt;/button&gt;
  );
};

export default DynamicStyledButton;
</code></pre>
<h2 id="sonuç-10"><a class="header" href="#sonuç-10">Sonuç</a></h2>
<p>React'te inline stil kullanımı, doğru ve etkili bir şekilde kullanıldığında projelerin stil yönetimini kolaylaştırabilir. Ancak, büyük ve karmaşık projelerde dikkatli olunması ve alternatif stil yönetim yöntemlerinin (örneğin CSS dosyaları, CSS-in-JS kütüphaneleri) değerlendirilmesi önemlidir. Bu eğitimde sunulan bilgiler ve kod örnekleri ile inline stil kullanımının temellerini ve kritik noktalarını öğrenmiş oldunuz. React geliştirme süreçlerinizde bu bilgileri uygulayarak daha temiz ve yönetilebilir kodlar yazabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="harici-stiller-kullanarak-bileşen-geliştirme"><a class="header" href="#harici-stiller-kullanarak-bileşen-geliştirme">Harici Stiller Kullanarak Bileşen Geliştirme</a></h1>
<p>Bu eğitim, React uygulamalarında harici stil dosyaları kullanarak bileşenler geliştirmek için gerekli adımları kapsamaktadır. Aşağıda, adım adım rehberlik sunulmuştur ve her adımda kod parçacıkları ile detaylandırılmıştır. Amacımız, bilimsel ve titiz bir yaklaşımla React bileşenlerinin nasıl oluşturulacağını ve harici stil dosyaları ile nasıl stil verileceğini açıklamaktır.</p>
<h2 id="1-proje-yapılandırması-1"><a class="header" href="#1-proje-yapılandırması-1">1. Proje Yapılandırması</a></h2>
<p>Öncelikle, projenizin kök dizininde bileşenler için bir klasör oluşturun. Bu, bileşenlerinizi düzenli tutmanızı sağlar.</p>
<pre><code class="language-bash">mkdir -p src/components
</code></pre>
<h2 id="2-jsx-bileşeni-oluşturma"><a class="header" href="#2-jsx-bileşeni-oluşturma">2. JSX Bileşeni Oluşturma</a></h2>
<p>Bileşenler klasörü içinde yeni bir JSX dosyası oluşturun. Bu dosya, bileşenimizin ana yapısını içerecektir.</p>
<pre><code class="language-jsx">// src/components/ExternalStyledText.jsx
import React from 'react';
import './ExternalStyledText.css';

const ExternalStyledText = () =&gt; {
    return (
        &lt;div className="external-styled-text"&gt;
            Merhaba, bu bir harici stilli bileşendir!
        &lt;/div&gt;
    );
};

export default ExternalStyledText;
</code></pre>
<h2 id="3-harici-stil-dosyası-oluşturma"><a class="header" href="#3-harici-stil-dosyası-oluşturma">3. Harici Stil Dosyası Oluşturma</a></h2>
<p>Aynı bileşen klasörü içinde harici stil dosyasını oluşturun. Bu dosya, bileşenin stil tanımlamalarını içerecektir.</p>
<pre><code class="language-css">/* src/components/ExternalStyledText.css */
.external-styled-text {
    color: blue;
    font-size: 20px;
    border: 1px solid black;
    padding: 10px;
    border-radius: 5px;
}
</code></pre>
<h2 id="4-bileşeni-İçe-aktarma-ve-kullanma"><a class="header" href="#4-bileşeni-İçe-aktarma-ve-kullanma">4. Bileşeni İçe Aktarma ve Kullanma</a></h2>
<p>Ana bileşen veya <code>App.jsx</code> dosyasında yeni oluşturduğunuz bileşeni içe aktarın ve JSX yapısına dahil edin.</p>
<pre><code class="language-jsx">// src/App.jsx
import React from 'react';
import ExternalStyledText from './components/ExternalStyledText';

const App = () =&gt; {
    return (
        &lt;div className="App"&gt;
            &lt;h1&gt;React Uygulamasına Hoş Geldiniz&lt;/h1&gt;
            &lt;ExternalStyledText /&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<h2 id="5-geliştirme-sunucusunu-başlatma"><a class="header" href="#5-geliştirme-sunucusunu-başlatma">5. Geliştirme Sunucusunu Başlatma</a></h2>
<p>Proje dizinine gidin ve geliştirme sunucusunu başlatın. Bu adım, uygulamanızı yerel olarak çalıştırmanızı sağlar.</p>
<pre><code class="language-bash">npm run dev
</code></pre>
<h1 id="sonuç-11"><a class="header" href="#sonuç-11">Sonuç</a></h1>
<p>Yukarıdaki adımları izleyerek, harici stil dosyaları ile stillendirilmiş React bileşenleri oluşturabilirsiniz. Bu yöntem, stil ve işlevselliği ayrı tutarak kodunuzu daha temiz ve sürdürülebilir hale getirir. React'te bileşen geliştirme sürecinde, bileşenlerinizi ve stil dosyalarınızı düzenli bir şekilde yapılandırmak önemlidir.</p>
<p>Bu eğitimin her adımında kullanılan kod parçacıklarını dikkatlice inceleyin ve projenizde uygulayın. Herhangi bir hatalı bilgiye karşı eleştirel bir yaklaşım sergilemek ve doğru yöntemleri kullanmak, başarılı bir yazılım geliştiricisi olmanın temelidir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="css-modülleri"><a class="header" href="#css-modülleri">CSS Modülleri</a></h1>
<p>Bu eğitimde, React projelerinde CSS Modülleri kullanarak stil yönetimini nasıl yapacağınızı ele alacağız. CSS Modülleri, stil çakışmalarını önlemek ve bileşen tabanlı mimariyi desteklemek için kullanışlı bir yaklaşımdır. Adım adım bir bileşen oluşturacak ve bu bileşeni CSS Modülleri ile nasıl stilize edeceğinizi göstereceğiz.</p>
<h2 id="giriş-12"><a class="header" href="#giriş-12">Giriş</a></h2>
<p>CSS Modülleri, CSS sınıf isimlerini bileşen bazında izole eden ve böylece stil çakışmalarını önleyen bir tekniktir. Bu modüller, her bileşenin kendi CSS dosyasını kullanarak stil yönetimini kolaylaştırır. React ile kullanıldığında, projelerde daha düzenli ve yönetilebilir bir stil yapısı sağlar.</p>
<h2 id="adım-1-bileşenler-İçin-klasör-oluşturma"><a class="header" href="#adım-1-bileşenler-İçin-klasör-oluşturma">Adım 1: Bileşenler İçin Klasör Oluşturma</a></h2>
<p>Öncelikle, proje yapınızı organize etmek için bileşenler (components) klasörünü oluşturun. Bu klasör, her bileşenin JSX ve CSS dosyalarını içerecektir.</p>
<pre><code class="language-sh">src/
├── components/
│   ├── ModuleStyledText.jsx
│   ├── ModuleStyledText.module.css
│   ...
</code></pre>
<h2 id="adım-2-jsx-dosyasını-oluşturma"><a class="header" href="#adım-2-jsx-dosyasını-oluşturma">Adım 2: JSX Dosyasını Oluşturma</a></h2>
<p><code>components</code> klasörü içinde, <code>ModuleStyledText.jsx</code> adında yeni bir JSX dosyası oluşturun. Bu dosya, bileşenin yapısını tanımlayacaktır.</p>
<pre><code class="language-jsx">// ModuleStyledText.jsx
import React from 'react';
import styles from './ModuleStyledText.module.css';

const ModuleStyledText = () =&gt; {
  return (
    &lt;div className={styles.textContainer}&gt;
      &lt;p className={styles.text}&gt;Bu bir CSS Modülü ile stilize edilmiş metindir.&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default ModuleStyledText;
</code></pre>
<h2 id="adım-3-css-modül-dosyasını-oluşturma"><a class="header" href="#adım-3-css-modül-dosyasını-oluşturma">Adım 3: CSS Modül Dosyasını Oluşturma</a></h2>
<p><code>components</code> klasörü içinde, <code>ModuleStyledText.module.css</code> adında yeni bir CSS dosyası oluşturun. Bu dosya, bileşenin stil kurallarını içerecektir.</p>
<pre><code class="language-css">/* ModuleStyledText.module.css */
.textContainer {
  padding: 10px;
  background-color: #f0f0f0;
  border-radius: 5px;
}

.text {
  color: #333;
  font-size: 16px;
}
</code></pre>
<h2 id="adım-4-bileşeni-İçe-aktarma-ve-kullanma"><a class="header" href="#adım-4-bileşeni-İçe-aktarma-ve-kullanma">Adım 4: Bileşeni İçe Aktarma ve Kullanma</a></h2>
<p>Ana bileşen dosyanıza (<code>App.jsx</code> veya başka bir üst bileşen) gidin ve <code>ModuleStyledText</code> bileşenini içe aktarın ve JSX içinde kullanın.</p>
<pre><code class="language-jsx">// App.jsx
import React from 'react';
import ModuleStyledText from './components/ModuleStyledText';

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;CSS Modülleri ile Stil Yönetimi&lt;/h1&gt;
      &lt;ModuleStyledText /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<h2 id="adım-5-projeyi-Çalıştırma"><a class="header" href="#adım-5-projeyi-Çalıştırma">Adım 5: Projeyi Çalıştırma</a></h2>
<p>Proje klasörünüze gidin ve geliştirme sunucusunu başlatın. Aşağıdaki komutları kullanarak projenizi başlatabilirsiniz:</p>
<pre><code class="language-sh">npm install
npm run dev
</code></pre>
<p>Bu adımlar, React projelerinizde CSS Modülleri kullanarak bileşenlerinizi nasıl stilize edeceğinizi göstermektedir. CSS Modülleri, stil çakışmalarını önler ve kodunuzu daha yönetilebilir hale getirir.</p>
<h2 id="eleştirel-değerlendirme"><a class="header" href="#eleştirel-değerlendirme">Eleştirel Değerlendirme</a></h2>
<p>CSS Modülleri, bileşen tabanlı mimarilerde stil yönetimini kolaylaştırsa da, projenizin büyüklüğüne ve karmaşıklığına bağlı olarak stil yönetiminde bazı zorluklar yaşanabilir. Büyük projelerde, global stillerin yönetimi ve stil kurallarının tutarlılığı konularında dikkatli olunmalıdır. Ayrıca, CSS-in-JS kütüphaneleri ile karşılaştırıldığında, bazı performans ve bakım farklılıkları olabilir.</p>
<h2 id="sonuç-12"><a class="header" href="#sonuç-12">Sonuç</a></h2>
<p>Bu eğitimde, CSS Modüllerinin temellerini ve React projelerinde nasıl kullanıldığını öğrendiniz. Bu teknik, özellikle büyük projelerde stil çakışmalarını önlemeye yardımcı olur ve bileşen tabanlı mimarilerle uyumludur. Öğrendiklerinizi projelerinizde uygulayarak daha düzenli ve sürdürülebilir bir stil yönetimi sağlayabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stil-kütüphaneleri"><a class="header" href="#stil-kütüphaneleri">Stil Kütüphaneleri</a></h1>
<p>Bu eğitim rehberi, React uygulamalarınızda stilleri daha kolay oluşturmanıza ve yönetmenize yardımcı olan popüler React stil kütüphanelerini kapsayacaktır. Özellikle, CSS-in-JS yaklaşımını kullanan ve React bileşenlerini stilize etmek için yaygın olarak kullanılan iki ana kütüphane olan <strong>styled-components</strong> ve <strong>Emotion</strong> üzerinde duracağız.</p>
<h2 id="1-styled-components"><a class="header" href="#1-styled-components">1. styled-components</a></h2>
<p><strong>styled-components</strong>, React bileşenlerini stilize etmek için kullanılan bir CSS-in-JS kütüphanesidir. Aşağıda bu kütüphanenin temel özellikleri ve kullanımı hakkında detaylı bilgi verilmiştir.</p>
<ul>
<li><strong>CSS-in-JS kütüphanesi</strong>: CSS stillerini JavaScript içinde yazmanıza olanak tanır.</li>
<li><strong>Tagged Template Literals</strong>: ES6 ile gelen template literals kullanır.</li>
<li><strong>Temalar, Sunucu Tarafında Rendering ve Otomatik Vendor-Prefixing</strong>: Temaları destekler, SSR (Server-Side Rendering) ile uyumludur ve tarayıcı uyumluluğu için vendor-prefix ekler.</li>
<li><strong>Bileşenlere Bağlı Scoped Stiller</strong>: Stiller bileşenlere bağlıdır ve izole edilir.</li>
<li><strong>Modülerlik ve Yeniden Kullanılabilirlik</strong>: Modüler yapıyı teşvik eder ve stil kurallarının yeniden kullanılabilir olmasını sağlar.</li>
</ul>
<h3 id="styled-components-kullanımı"><a class="header" href="#styled-components-kullanımı">styled-components Kullanımı</a></h3>
<p><strong>Kurulum</strong>:</p>
<pre><code class="language-bash">npm install styled-components
</code></pre>
<p><strong>Örnek Kullanım</strong>:</p>
<pre><code class="language-jsx">import styled from 'styled-components';

const Button = styled.button`
  background: papayawhip;
  border-radius: 3px;
  border: none;
  color: palevioletred;
  margin: 0.5em;
  padding: 0.5em 1em;
  font-size: 1em;

  &amp;:hover {
    background: palevioletred;
    color: white;
  }
`;

function App() {
  return (
    &lt;div&gt;
      &lt;Button&gt;Click Me&lt;/Button&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p><strong>Resmi Belgeler ve Kaynaklar</strong>:</p>
<ul>
<li>GitHub: <a href="https://github.com/styled-components/styled-components">styled-components GitHub</a></li>
<li>Dokümantasyon: <a href="https://styled-components.com/docs">styled-components Documentation</a></li>
</ul>
<h2 id="2-emotion"><a class="header" href="#2-emotion">2. Emotion</a></h2>
<p><strong>Emotion</strong>, yüksek performanslı stil kompozisyonu için tasarlanmış bir başka popüler CSS-in-JS kütüphanesidir. Emotion, iki ana yol sunar: JSX tabanlı <code>@emotion/react</code> ve styled-components'e benzer <code>@emotion/css</code>.</p>
<ul>
<li><strong>CSS-in-JS kütüphanesi</strong>: React bileşenleri için stil oluşturmanızı sağlar.</li>
<li><strong>JSX Tabanlı ve styled-components Benzeri Yöntemler</strong>: Farklı kullanım yöntemleri sunar.</li>
<li><strong>Temalar, Sunucu Tarafında Rendering ve Otomatik Vendor-Prefixing</strong>: Bu özellikleri destekler.</li>
<li><strong>Yüksek Performans</strong>: Ölü kodların elemesi ve kritik CSS çıkarımı gibi optimizasyonlara sahiptir.</li>
<li><strong>Bileşen Tabanlı Stil ve Yeniden Kullanılabilirlik</strong>: Bileşen bazlı stil oluşturmayı teşvik eder.</li>
</ul>
<h3 id="emotion-kullanımı"><a class="header" href="#emotion-kullanımı">Emotion Kullanımı</a></h3>
<p><strong>Kurulum</strong>:</p>
<pre><code class="language-bash">npm install @emotion/react @emotion/styled
</code></pre>
<p><strong>Örnek Kullanım</strong>:</p>
<pre><code class="language-jsx">/** @jsxImportSource @emotion/react */
import { css } from '@emotion/react';
import styled from '@emotion/styled';

const buttonStyle = css`
  background: papayawhip;
  border-radius: 3px;
  border: none;
  color: palevioletred;
  margin: 0.5em;
  padding: 0.5em 1em;
  font-size: 1em;

  &amp;:hover {
    background: palevioletred;
    color: white;
  }
`;

const Button = styled.button`
  ${buttonStyle}
`;

function App() {
  return (
    &lt;div&gt;
      &lt;Button&gt;Click Me&lt;/Button&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p><strong>Resmi Belgeler ve Kaynaklar</strong>:</p>
<ul>
<li>GitHub: <a href="https://github.com/emotion-js/emotion">Emotion GitHub</a></li>
<li>Dokümantasyon: <a href="https://emotion.sh/docs/introduction">Emotion Documentation</a></li>
</ul>
<h1 id="sonuç-13"><a class="header" href="#sonuç-13">Sonuç</a></h1>
<p>Bu eğitim rehberinde, React projelerinde stil oluşturmayı kolaylaştıran ve yönetilebilir hale getiren iki popüler CSS-in-JS kütüphanesi olan styled-components ve Emotion incelenmiştir. Her iki kütüphane de temalar, sunucu tarafında rendering ve otomatik vendor-prefixing gibi güçlü özellikler sunar ve bileşen bazlı stil oluşturmayı teşvik eder. Kütüphanelerin nasıl kurulacağını ve temel kullanım örneklerini inceleyerek, projelerinizde etkili stil çözümleri uygulayabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling-teknikleri"><a class="header" href="#styling-teknikleri">Styling Teknikleri</a></h1>
<p>Bu eğitim, React uygulamalarında çeşitli stil tekniklerini kullanmayı kapsamlı bir şekilde ele almaktadır. React ile bileşen tabanlı yapı, props ve state yönetimi gibi temel konularla birlikte, stil uygulama yöntemleri üzerinde derinlemesine durulacaktır. Aşağıda verilen yapılandırılmış eğitim, sağlanan PDF'deki görevlere dayanarak hazırlanmıştır.</p>
<h2 id="eğitim-İçeriği"><a class="header" href="#eğitim-İçeriği">Eğitim İçeriği</a></h2>
<ol>
<li>
<p><strong>React Uygulaması ve Bileşenler</strong></p>
<ul>
<li>React uygulaması oluşturma</li>
<li>Bileşenler, props ve state kullanımı</li>
</ul>
</li>
<li>
<p><strong>Navigasyon Barı: Inline Styles</strong></p>
<ul>
<li>Inline styles kullanımı</li>
<li>Sınırlı ve gerekli olduğu yerlerde inline styles uygulaması</li>
</ul>
</li>
<li>
<p><strong>Hizmetler Bölümü: Harici Stil Dosyaları</strong></p>
<ul>
<li>Harici stil dosyalarının kullanımı</li>
<li>Sınıflar ve seçiciler ile stil uygulamaları</li>
</ul>
</li>
<li>
<p><strong>Alt Bilgi (Footer): CSS Modülleri</strong></p>
<ul>
<li>CSS modülleri ile stil uygulama</li>
<li>Scoped styling kavramı</li>
</ul>
</li>
<li>
<p><strong>Duyarlı Tasarım (Responsive Design)</strong></p>
<ul>
<li>Farklı ekran boyutlarına uyum sağlayan tasarım oluşturma</li>
<li>Duyarlı tasarım teknikleri</li>
</ul>
</li>
<li>
<p><strong>Projenin GitHub'a Yüklenmesi ve Canlı Demo Oluşturma</strong></p>
<ul>
<li>GitHub'da depo oluşturma ve kod yükleme</li>
<li>README dosyası hazırlama</li>
<li>Netlify veya GitHub Pages ile canlı demo oluşturma</li>
</ul>
</li>
</ol>
<h2 id="1-react-uygulaması-ve-bileşenler"><a class="header" href="#1-react-uygulaması-ve-bileşenler">1. React Uygulaması ve Bileşenler</a></h2>
<p><strong>React Uygulaması Oluşturma</strong></p>
<p>React uygulaması oluşturmak için aşağıdaki adımları izleyin:</p>
<pre><code class="language-bash">npx create-react-app styling-showcase
cd styling-showcase
npm start
</code></pre>
<p>Bu komutlar, temel bir React uygulaması başlatacaktır. Şimdi bileşenleri oluşturmaya başlayabiliriz.</p>
<h2 id="2-navigasyon-barı-inline-styles"><a class="header" href="#2-navigasyon-barı-inline-styles">2. Navigasyon Barı: Inline Styles</a></h2>
<p><strong>Navigasyon Barı Bileşeni Oluşturma</strong></p>
<p><code>src/components</code> klasöründe <code>Navbar.js</code> dosyasını oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React from 'react';

const navbarStyle = {
  backgroundColor: '#282c34',
  padding: '10px',
  color: 'white',
  textAlign: 'center'
};

const Navbar = () =&gt; {
  return (
    &lt;nav style={navbarStyle}&gt;
      &lt;h1&gt;Company Name&lt;/h1&gt;
      &lt;ul style={{ listStyleType: 'none', margin: 0, padding: 0 }}&gt;
        &lt;li style={{ display: 'inline', margin: '0 10px' }}&gt;Home&lt;/li&gt;
        &lt;li style={{ display: 'inline', margin: '0 10px' }}&gt;Services&lt;/li&gt;
        &lt;li style={{ display: 'inline', margin: '0 10px' }}&gt;Contact&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;
  );
};

export default Navbar;
</code></pre>
<p>Bu bileşen, inline styles kullanarak basit bir navigasyon barı oluşturur. Inline styles'ın sadece gerektiğinde kullanıldığını unutmayın.</p>
<h2 id="3-hizmetler-bölümü-harici-stil-dosyaları"><a class="header" href="#3-hizmetler-bölümü-harici-stil-dosyaları">3. Hizmetler Bölümü: Harici Stil Dosyaları</a></h2>
<p><strong>Hizmetler Bileşeni Oluşturma</strong></p>
<p><code>src/components</code> klasöründe <code>Services.js</code> dosyasını oluşturun ve <code>Services.css</code> adlı bir stil dosyası ekleyin. <code>Services.js</code> aşağıdaki gibi olacaktır:</p>
<pre><code class="language-jsx">import React from 'react';
import './Services.css';

const Services = () =&gt; {
  return (
    &lt;div className="services"&gt;
      &lt;h2&gt;Our Services&lt;/h2&gt;
      &lt;ul&gt;
        &lt;li&gt;Web Development&lt;/li&gt;
        &lt;li&gt;Mobile App Development&lt;/li&gt;
        &lt;li&gt;UI/UX Design&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default Services;
</code></pre>
<p><code>Services.css</code> dosyasına ise aşağıdaki stilleri ekleyin:</p>
<pre><code class="language-css">.services {
  background-color: #f4f4f4;
  padding: 20px;
  text-align: center;
}

.services h2 {
  color: #333;
}

.services ul {
  list-style-type: none;
  padding: 0;
}

.services li {
  margin: 10px 0;
}
</code></pre>
<p>Bu bileşen, harici stil dosyaları kullanılarak stil verilmiş bir hizmetler bölümünü içerir.</p>
<h2 id="4-alt-bilgi-footer-css-modülleri"><a class="header" href="#4-alt-bilgi-footer-css-modülleri">4. Alt Bilgi (Footer): CSS Modülleri</a></h2>
<p><strong>Alt Bilgi Bileşeni Oluşturma</strong></p>
<p><code>src/components</code> klasöründe <code>Footer.js</code> dosyasını ve <code>Footer.module.css</code> adlı bir stil dosyasını oluşturun. <code>Footer.js</code> aşağıdaki gibi olacaktır:</p>
<pre><code class="language-jsx">import React from 'react';
import styles from './Footer.module.css';

const Footer = () =&gt; {
  return (
    &lt;footer className={styles.footer}&gt;
      &lt;p&gt;© 2024 Company Name. All rights reserved.&lt;/p&gt;
    &lt;/footer&gt;
  );
};

export default Footer;
</code></pre>
<p><code>Footer.module.css</code> dosyasına ise aşağıdaki stilleri ekleyin:</p>
<pre><code class="language-css">.footer {
  background-color: #282c34;
  color: white;
  padding: 10px;
  text-align: center;
}
</code></pre>
<p>Bu bileşen, CSS modülleri kullanarak scoped styling uygulanmış bir alt bilgi bölümü içerir.</p>
<h2 id="5-duyarlı-tasarım-responsive-design"><a class="header" href="#5-duyarlı-tasarım-responsive-design">5. Duyarlı Tasarım (Responsive Design)</a></h2>
<p>Duyarlı tasarım, her bileşen için geçerli olacak şekilde CSS medya sorguları kullanılarak sağlanabilir. Örneğin, <code>Services.css</code> dosyasına aşağıdaki medya sorgusunu ekleyin:</p>
<pre><code class="language-css">@media (max-width: 600px) {
  .services ul {
    display: block;
  }

  .services li {
    margin: 20px 0;
  }
}
</code></pre>
<p>Bu medya sorgusu, ekran genişliği 600 pikselden küçük olduğunda hizmetler listesini dikey olarak hizalayacaktır.</p>
<h2 id="6-projenin-githuba-yüklenmesi-ve-canlı-demo-oluşturma"><a class="header" href="#6-projenin-githuba-yüklenmesi-ve-canlı-demo-oluşturma">6. Projenin GitHub'a Yüklenmesi ve Canlı Demo Oluşturma</a></h2>
<p><strong>GitHub'a Yükleme</strong></p>
<ol>
<li>GitHub'da yeni bir depo oluşturun.</li>
<li>Aşağıdaki komutları kullanarak projeyi yükleyin:</li>
</ol>
<pre><code class="language-bash">git init
git remote add origin https://github.com/yourusername/styling-showcase.git
git add .
git commit -m "Initial commit"
git push -u origin master
</code></pre>
<p><strong>Canlı Demo Oluşturma</strong></p>
<p>Netlify veya GitHub Pages kullanarak canlı demo oluşturabilirsiniz. Netlify kullanarak dağıtım yapmak için:</p>
<ol>
<li>Netlify hesabı oluşturun ve giriş yapın.</li>
<li>"New site from Git" seçeneğini tıklayın.</li>
<li>GitHub depo bağlantısını seçin ve dağıtımı tamamlayın.</li>
</ol>
<h2 id="sonuç-14"><a class="header" href="#sonuç-14">Sonuç</a></h2>
<p>Bu eğitim, React uygulamalarında farklı stil tekniklerini kullanarak kapsamlı ve duyarlı bir kullanıcı arayüzü oluşturmayı ele almıştır. Inline styles, harici stil dosyaları ve CSS modülleri gibi yöntemlerle stil uygulamanın yanı sıra, duyarlı tasarım teknikleri ve projenin GitHub'da barındırılması gibi konular da detaylandırılmıştır. Bu eğitim, yazılım geliştirme standartlarına uygun şekilde hazırlanmıştır ve kod parçacıkları ile desteklenmiştir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-hooks"><a class="header" href="#introduction-to-hooks">Introduction to Hooks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-hook"><a class="header" href="#react-hook">React Hook</a></h1>
<p>Bu eğitimde, React'in Hook'larını kullanarak fonksiyonel bileşenlerde durum (state) ve diğer React özelliklerine nasıl erişileceğini öğreneceksiniz. İçeriğimiz ciddi ve bilimsel bir tonda olup, yazılım geliştirme alanında beklenen titizlik ve standartları yansıtacaktır. Kod parçacıkları iyi yapılandırılmış ve açıklayıcı olacaktır.</p>
<h2 id="hook-nedir"><a class="header" href="#hook-nedir">Hook Nedir?</a></h2>
<p>React Hook'ları, fonksiyonel bileşenlerin durum ve diğer React özelliklerine erişim sağlamasına olanak tanır. Hook'lar sayesinde, durum yönetimi ve yan etkilerin kontrolü daha temiz ve sürdürülebilir kod yazmanızı sağlar.</p>
<h3 id="hookların-kuralları"><a class="header" href="#hookların-kuralları">Hook'ların Kuralları</a></h3>
<p>Hook'ların doğru çalışması için bazı kurallar vardır:</p>
<ol>
<li>Hook'lar sadece React fonksiyon bileşenleri içinde çağrılabilir.</li>
<li>Hook'lar sadece bir bileşenin en üst seviyesinde çağrılabilir. Koşullu veya döngü içinde çağrılamazlar.</li>
<li>Hook'lar koşullu olarak kullanılamaz.</li>
</ol>
<h3 id="yaygın-olarak-kullanılan-hooklar"><a class="header" href="#yaygın-olarak-kullanılan-hooklar">Yaygın Olarak Kullanılan Hook'lar</a></h3>
<p>React'te yerleşik olarak gelen ve sıklıkla kullanılan bazı Hook'lar şunlardır:</p>
<ul>
<li><code>useState</code></li>
<li><code>useEffect</code></li>
<li><code>useContext</code></li>
</ul>
<p>Ayrıca, özel ihtiyaçlarınız için kendi özel Hook'larınızı oluşturabilir ve durumlu mantığı birden çok bileşen arasında tekrar kullanabilirsiniz.</p>
<h2 id="usestate-hooku"><a class="header" href="#usestate-hooku">useState Hook'u</a></h2>
<p><code>useState</code> Hook'u, fonksiyonel bileşenlerde durum yönetimini sağlar. Bir durum değeri ve bu durumu güncellemek için bir fonksiyon döner.</p>
<h3 id="Örnek-kullanım"><a class="header" href="#Örnek-kullanım">Örnek Kullanım</a></h3>
<pre><code class="language-javascript">import React, { useState } from 'react';

function Counter() {
  // count adında bir durum ve setCount adında bir güncelleme fonksiyonu tanımlanır.
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;Butona {count} defa tıkladınız.&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Tıkla
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Counter;
</code></pre>
<p>Bu örnekte, <code>useState</code> ile bir sayaç durumu oluşturulmuş ve bir butona tıklanıldığında durum güncellenmiştir.</p>
<h2 id="useeffect-hooku"><a class="header" href="#useeffect-hooku">useEffect Hook'u</a></h2>
<p><code>useEffect</code> Hook'u, yan etkilerin yönetimini sağlar. Yan etkiler, veri getirimi, abonelikler veya manuel DOM manipülasyonları gibi işlemleri içerir.</p>
<h3 id="Örnek-kullanım-1"><a class="header" href="#Örnek-kullanım-1">Örnek Kullanım</a></h3>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';

function ExampleComponent() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    // Bu kod parçası her render işleminden sonra çalışır.
    document.title = `Tıkladığınız sayısı: ${count}`;

    // Temizlik işlemleri için opsiyonel bir geri dönüş fonksiyonu dönebilirsiniz.
    return () =&gt; {
      document.title = 'React App';
    };
  }, [count]); // Sadece count değiştiğinde etkisi çalışır.

  return (
    &lt;div&gt;
      &lt;p&gt;Butona {count} defa tıkladınız.&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Tıkla
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

export default ExampleComponent;
</code></pre>
<p>Bu örnekte, <code>useEffect</code> kullanılarak her render işleminden sonra sayfa başlığının güncellenmesi sağlanmıştır.</p>
<h2 id="usecontext-hooku"><a class="header" href="#usecontext-hooku">useContext Hook'u</a></h2>
<p><code>useContext</code> Hook'u, Context API ile tanımlanan değerleri kullanmayı sağlar. Bu, bileşen ağacının derinliklerindeki bileşenlere veri geçirme işlemini kolaylaştırır.</p>
<h3 id="Örnek-kullanım-2"><a class="header" href="#Örnek-kullanım-2">Örnek Kullanım</a></h3>
<pre><code class="language-javascript">import React, { useContext } from 'react';

const ThemeContext = React.createContext('light');

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return &lt;button className={theme}&gt;Buton&lt;/button&gt;;
}

export default ThemedButton;
</code></pre>
<p>Bu örnekte, <code>useContext</code> kullanılarak <code>ThemeContext</code>'ten alınan tema değeri butonun sınıf adı olarak kullanılmıştır.</p>
<h2 id="Özel-hook-oluşturma"><a class="header" href="#Özel-hook-oluşturma">Özel Hook Oluşturma</a></h2>
<p>Özel Hook'lar, birden fazla bileşende tekrar kullanılabilir mantık oluşturmanızı sağlar. Bu, kodunuzu daha modüler ve yönetilebilir hale getirir.</p>
<h3 id="Örnek-kullanım-3"><a class="header" href="#Örnek-kullanım-3">Örnek Kullanım</a></h3>
<pre><code class="language-javascript">import { useState, useEffect } from 'react';

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() =&gt; {
    const handleResize = () =&gt; setWidth(window.innerWidth);
    window.addEventListener('resize', handleResize);

    // Cleanup işlemi
    return () =&gt; {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return width;
}

export default useWindowWidth;
</code></pre>
<p>Bu özel Hook, pencere genişliğini takip eder ve bu bilgiyi kullanmak isteyen bileşenlere sağlar.</p>
<pre><code class="language-javascript">import React from 'react';
import useWindowWidth from './useWindowWidth';

function WidthComponent() {
  const width = useWindowWidth();

  return (
    &lt;div&gt;
      &lt;p&gt;Pencere genişliği: {width}px&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default WidthComponent;
</code></pre>
<p>Bu örnekte, <code>useWindowWidth</code> özel Hook'u kullanılarak pencere genişliği takip edilmiş ve bileşen içerisinde kullanılmıştır.</p>
<h2 id="sonuç-15"><a class="header" href="#sonuç-15">Sonuç</a></h2>
<p>React Hook'ları, fonksiyonel bileşenlerde durum ve yan etkileri yönetmeyi kolaylaştırarak daha temiz ve sürdürülebilir kod yazmanızı sağlar. Bu eğitimde, <code>useState</code>, <code>useEffect</code>, <code>useContext</code> gibi yaygın olarak kullanılan Hook'ların yanı sıra özel Hook oluşturmayı öğrendiniz. Hook'ların doğru ve etkili kullanımı, React uygulamalarınızı daha modüler ve yönetilebilir hale getirecektir.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usestate-kancası-hook-kullanımı"><a class="header" href="#usestate-kancası-hook-kullanımı">useState Kancası (Hook) Kullanımı</a></h2>
<p>Bu eğitim, React'te <code>useState</code> kancasının nasıl kullanılacağını ayrıntılı bir şekilde ele almaktadır. Eğitim, ciddi ve bilimsel bir dil kullanılarak yazılmıştır ve yazılım geliştirme alanında beklenen titizlik ve standartları yansıtır. Eğitim boyunca, iyi yapılandırılmış kod parçacıkları sağlanmıştır.</p>
<h3 id="1-bileşenler-için-klasör-oluşturma"><a class="header" href="#1-bileşenler-için-klasör-oluşturma">1. Bileşenler için Klasör Oluşturma</a></h3>
<p>Projenizin <code>src</code> dizininde, bileşenlerinizi organize etmek için bir klasör oluşturun. Eğer yoksa, bu klasörü şu şekilde oluşturabilirsiniz:</p>
<pre><code class="language-bash">mkdir src/components
</code></pre>
<h3 id="2-yeni-bileşen-dosyası-oluşturma"><a class="header" href="#2-yeni-bileşen-dosyası-oluşturma">2. Yeni Bileşen Dosyası Oluşturma</a></h3>
<p><code>components</code> klasörünün içinde, oluşturmak istediğiniz bileşenin adını taşıyan yeni bir JSX dosyası oluşturun. Örneğin, bir sayaç bileşeni için:</p>
<pre><code class="language-bash">touch src/components/Counter.jsx
</code></pre>
<h3 id="3-react-ve-usestate-kancasını-İçe-aktarma"><a class="header" href="#3-react-ve-usestate-kancasını-İçe-aktarma">3. React ve useState Kancasını İçe Aktarma</a></h3>
<p>Oluşturduğunuz <code>Counter.jsx</code> dosyasında, React ve <code>useState</code> kancasını içe aktarın:</p>
<pre><code class="language-javascript">import React, { useState } from 'react';
</code></pre>
<h3 id="4-fonksiyonel-bileşen-oluşturma-1"><a class="header" href="#4-fonksiyonel-bileşen-oluşturma-1">4. Fonksiyonel Bileşen Oluşturma</a></h3>
<p>Durum eklemek istediğiniz fonksiyonel bileşeni yazın:</p>
<pre><code class="language-javascript">const Counter = () =&gt; {
    // useState kullanarak durum değişkenini tanımlayın
    const [count, setCount] = useState(0);

    return (
        &lt;div&gt;
            &lt;p&gt;Sayım: {count}&lt;/p&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Artır&lt;/button&gt;
        &lt;/div&gt;
    );
};
</code></pre>
<h3 id="5-durumu-usestate-ile-tanımlama"><a class="header" href="#5-durumu-usestate-ile-tanımlama">5. Durumu useState ile Tanımlama</a></h3>
<p>Yukarıdaki örnekte görüldüğü gibi, <code>useState</code> kancasını kullanarak bir durum değişkeni (<code>count</code>) ve bu durumu güncellemek için bir fonksiyon (<code>setCount</code>) tanımladık.</p>
<h3 id="6-durumu-görüntüleme"><a class="header" href="#6-durumu-görüntüleme">6. Durumu Görüntüleme</a></h3>
<p>Bileşenin JSX'inde, durum değişkeninin değerini görüntüleyin:</p>
<pre><code class="language-javascript">&lt;p&gt;Sayım: {count}&lt;/p&gt;
</code></pre>
<h3 id="7-durumu-güncelleme"><a class="header" href="#7-durumu-güncelleme">7. Durumu Güncelleme</a></h3>
<p>Durumu güncellemek için, <code>useState</code> tarafından döndürülen güncelleme fonksiyonunu kullanın. Bu örnekte, butona tıklandığında <code>setCount</code> fonksiyonu çağrılarak <code>count</code> değişkeninin değeri artırılmaktadır:</p>
<pre><code class="language-javascript">&lt;button onClick={() =&gt; setCount(count + 1)}&gt;Artır&lt;/button&gt;
</code></pre>
<h3 id="8-bileşeni-dışa-aktarma"><a class="header" href="#8-bileşeni-dışa-aktarma">8. Bileşeni Dışa Aktarma</a></h3>
<p>Bileşeni diğer dosyalarda kullanabilmek için dışa aktarın:</p>
<pre><code class="language-javascript">export default Counter;
</code></pre>
<h3 id="9-bileşeni-İçe-aktarma-ve-kullanma"><a class="header" href="#9-bileşeni-İçe-aktarma-ve-kullanma">9. Bileşeni İçe Aktarma ve Kullanma</a></h3>
<p>Ana bileşende veya <code>App.jsx</code> dosyasında, <code>Counter</code> bileşenini içe aktarın ve JSX içinde kullanın:</p>
<pre><code class="language-javascript">import React from 'react';
import Counter from './components/Counter';

const App = () =&gt; {
    return (
        &lt;div&gt;
            &lt;h1&gt;Hoş Geldiniz&lt;/h1&gt;
            &lt;Counter /&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<h3 id="sonuç-16"><a class="header" href="#sonuç-16">Sonuç</a></h3>
<p>Bu eğitimde, React'te <code>useState</code> kancasının nasıl kullanılacağını ayrıntılı bir şekilde ele aldık. Bu kancayı kullanarak fonksiyonel bileşenlere durum ekleyebilir ve durumu güncelleyebilirsiniz. Eğitim boyunca verilen adımları takip ederek, <code>useState</code> kancasının temel kullanımını öğrenmiş oldunuz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactte-veri-akışı"><a class="header" href="#reactte-veri-akışı">React'te Veri Akışı</a></h1>
<p>React, veri akışının tek yönlü olduğu ve verilerin üst bileşenlerden alt bileşenlere "props" adı verilen özellikler aracılığıyla iletildiği bir yapıya sahiptir. Bu temel ilke, "tek yönlü veri bağlama" veya "tek yönlü veri akışı" olarak da bilinir. Bu eğitimde, React'te veri akışının nasıl gerçekleştiğini adım adım açıklayacağız.</p>
<h2 id="1-bileşenler-için-yeni-bir-klasör-oluşturma"><a class="header" href="#1-bileşenler-için-yeni-bir-klasör-oluşturma">1. Bileşenler için Yeni Bir Klasör Oluşturma</a></h2>
<p>Projenizin <code>src</code> dizininde, bileşenler için yeni bir klasör oluşturun. Bu klasörün adı <code>components</code> olacak.</p>
<pre><code class="language-bash">mkdir src/components
</code></pre>
<h2 id="2-parent-bileşenini-oluşturma"><a class="header" href="#2-parent-bileşenini-oluşturma">2. Parent Bileşenini Oluşturma</a></h2>
<p><code>components</code> klasörü içinde <code>Parent.jsx</code> adında yeni bir JSX dosyası oluşturun ve basit bir fonksiyonel bileşen tanımlayın. Bu bileşen, bir mesajı temsil eden bir duruma sahip olacak.</p>
<pre><code class="language-jsx">// src/components/Parent.jsx
import React, { useState } from 'react';
import Child from './Child';

const Parent = () =&gt; {
  const [message, setMessage] = useState('Merhaba, bu bir mesajdır!');

  return (
    &lt;div&gt;
      &lt;h1&gt;Parent Bileşeni&lt;/h1&gt;
      &lt;Child message={message} /&gt;
    &lt;/div&gt;
  );
};

export default Parent;
</code></pre>
<h2 id="3-child-bileşenini-oluşturma"><a class="header" href="#3-child-bileşenini-oluşturma">3. Child Bileşenini Oluşturma</a></h2>
<p><code>components</code> klasörü içinde <code>Child.jsx</code> adında başka bir JSX dosyası oluşturun. Bu bileşen, Parent bileşeninden gelen <code>message</code> prop'unu alacak ve gösterecek.</p>
<pre><code class="language-jsx">// src/components/Child.jsx
import React from 'react';

const Child = ({ message }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h2&gt;Child Bileşeni&lt;/h2&gt;
      &lt;p&gt;{message}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default Child;
</code></pre>
<h2 id="4-parent-bileşenini-kullanma-ve-İçe-aktarma"><a class="header" href="#4-parent-bileşenini-kullanma-ve-İçe-aktarma">4. Parent Bileşenini Kullanma ve İçe Aktarma</a></h2>
<p><code>App.jsx</code> dosyasında, Parent bileşenini içe aktarın ve JSX içinde kullanın.</p>
<pre><code class="language-jsx">// src/App.jsx
import React from 'react';
import Parent from './components/Parent';

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;React Uygulaması&lt;/h1&gt;
      &lt;Parent /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<h1 id="sonuç-17"><a class="header" href="#sonuç-17">Sonuç</a></h1>
<p>Uygulamayı çalıştırdığınızda, Parent bileşeninin mesaj durumunu props aracılığıyla Child bileşenine aktardığını ve Child bileşeninin bu mesajı gösterdiğini göreceksiniz. Bu, React'te verinin üst bileşenlerden alt bileşenlere nasıl aktığını gösteren bir örnektir.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sayaç-uygulaması"><a class="header" href="#sayaç-uygulaması">Sayaç Uygulaması</a></h2>
<h3 id="amaç-1"><a class="header" href="#amaç-1">Amaç:</a></h3>
<p>React kullanarak bir Sayaç Uygulaması geliştirin. Uygulama kullanıcıların bir sayaç değerini artırmasına, azaltmasına ve sıfırlamasına olanak tanımalıdır.</p>
<h3 id="gereksinimler-5"><a class="header" href="#gereksinimler-5">Gereksinimler:</a></h3>
<ol>
<li>
<p><strong>Sayaç Ekranı</strong>:</p>
<ul>
<li>Sayaç belirgin bir şekilde görüntülenmelidir, mümkünse bir daire veya kare içinde.</li>
<li>Kolayca okunabilir olması için yeterince büyük olmalıdır.</li>
<li>Temiz ve okunabilir bir yazı tipi seçin.</li>
</ul>
</li>
<li>
<p><strong>Düğmeler</strong>:</p>
<ul>
<li>Üç düğmeyi (<strong><code>+</code></strong>, <strong><code>-</code></strong> ve <strong><code>Sıfırla</code></strong>) stilize edin, böylece birbirlerinden kolayca ayırt edilebilir olsunlar.</li>
<li>Her düğmenin işlevini temsil etmek için farklı renkler veya tonlar kullanmayı düşünün.</li>
<li>Tüm düğmelerin bir hover etkisi olmalıdır.</li>
</ul>
</li>
<li>
<p><strong>Duyarlılık</strong>:</p>
<ul>
<li>Sayaç Uygulamasının duyarlı olmasını sağlayın. Hem masaüstü hem de mobil görünümlerde iyi görünmelidir.</li>
<li>Daha dar bir görünüm için düzenin nasıl değişebileceğini göz önünde bulundurun.</li>
</ul>
</li>
<li>
<p><strong>Bonus</strong>:</p>
<ul>
<li>Sayaç değiştiğinde veya düğmelere basıldığında ince geçişler veya animasyonlar ekleyin.</li>
</ul>
</li>
<li>
<p><strong>Dokümantasyon</strong>:</p>
<ul>
<li>CSS'inizi hangi bölümleri stillendirdiğinizi belirtecek şekilde yorumlayın.</li>
<li>Bu, başkalarının stil kararlarınızı anlamasına yardımcı olacaktır.</li>
</ul>
</li>
</ol>
<h3 id="teslimat-1"><a class="header" href="#teslimat-1">Teslimat:</a></h3>
<ol>
<li>React projenizi barındırmak için bir GitHub deposu oluşturun.</li>
<li>Kodunuzu bu depoya commit ve push edin.</li>
<li>Uygulamanızı nasıl çalıştıracağınızı açıklayan bir README dosyası ekleyin.</li>
<li>Netlify veya GitHub Pages gibi bir platform kullanarak web sitenizin canlı demosunu sağlayın.</li>
</ol>
<h3 id="react-sayaç-uygulaması-eğitimi"><a class="header" href="#react-sayaç-uygulaması-eğitimi">React Sayaç Uygulaması Eğitimi</a></h3>
<h4 id="adım-1-react-projesi-kurulumu"><a class="header" href="#adım-1-react-projesi-kurulumu">Adım 1: React Projesi Kurulumu</a></h4>
<p>Öncelikle, React uygulamasını oluşturmak için gerekli araçları kurmamız gerekiyor. Terminal veya komut istemcisinde aşağıdaki komutları çalıştırarak başlayabilirsiniz:</p>
<pre><code class="language-bash">npx create-react-app sayac-uygulamasi
cd sayac-uygulamasi
</code></pre>
<p>Bu komutlar, yeni bir React projesi oluşturacak ve proje dizinine geçiş yapacaktır.</p>
<h4 id="adım-2-uygulama-yapısı"><a class="header" href="#adım-2-uygulama-yapısı">Adım 2: Uygulama Yapısı</a></h4>
<p><code>src</code> klasörü altında <code>components</code> adında bir klasör oluşturun. Bu klasörde <code>Counter.js</code> dosyasını oluşturacağız. <code>Counter.js</code> dosyası sayaç bileşenimizi içerecek.</p>
<p><code>src/components/Counter.js</code> dosyasını şu şekilde oluşturun:</p>
<pre><code class="language-jsx">import React, { useState } from 'react';
import './Counter.css';

const Counter = () =&gt; {
  const [count, setCount] = useState(0);

  const increment = () =&gt; setCount(count + 1);
  const decrement = () =&gt; setCount(count - 1);
  const reset = () =&gt; setCount(0);

  return (
    &lt;div className="counter-container"&gt;
      &lt;h1 className="counter-display"&gt;{count}&lt;/h1&gt;
      &lt;div className="button-group"&gt;
        &lt;button className="button increment" onClick={increment}&gt;+&lt;/button&gt;
        &lt;button className="button decrement" onClick={decrement}&gt;-&lt;/button&gt;
        &lt;button className="button reset" onClick={reset}&gt;Sıfırla&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default Counter;
</code></pre>
<h4 id="adım-3-css-ile-stil-verme"><a class="header" href="#adım-3-css-ile-stil-verme">Adım 3: CSS ile Stil Verme</a></h4>
<p><code>src/components</code> klasöründe <code>Counter.css</code> dosyasını oluşturun ve stil tanımlarınızı ekleyin:</p>
<pre><code class="language-css">.counter-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 50px;
}

.counter-display {
  font-size: 4rem;
  margin-bottom: 20px;
}

.button-group {
  display: flex;
  gap: 10px;
}

.button {
  padding: 10px 20px;
  font-size: 1.5rem;
  border: none;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.button.increment {
  background-color: #4CAF50;
  color: white;
}

.button.decrement {
  background-color: #f44336;
  color: white;
}

.button.reset {
  background-color: #008CBA;
  color: white;
}

.button:hover {
  opacity: 0.8;
}
</code></pre>
<h4 id="adım-4-bileşeni-appjsye-dahil-etme"><a class="header" href="#adım-4-bileşeni-appjsye-dahil-etme">Adım 4: Bileşeni App.js'ye Dahil Etme</a></h4>
<p><code>src/App.js</code> dosyasını açın ve <code>Counter</code> bileşenini içeri aktararak kullanın:</p>
<pre><code class="language-jsx">import React from 'react';
import './App.css';
import Counter from './components/Counter';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Counter /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-effects"><a class="header" href="#working-with-effects">Working with Effects</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useeffect-kullanımı"><a class="header" href="#useeffect-kullanımı">useEffect Kullanımı</a></h1>
<p>Bu rehberde, React'in <code>useEffect</code> hook'unun nasıl kullanıldığını ayrıntılı bir şekilde ele alacağız. Bu kapsamlı rehber, yazılım geliştirme alanında beklenen titizlik ve standartları yansıtacak şekilde, <code>useEffect</code> hook'unun kullanımını, örneklerle destekleyerek anlatacaktır. Eğitim boyunca, kod parçacıkları iyi yapılandırılmış ve açıklamalarla zenginleştirilmiştir.</p>
<h2 id="giriş-13"><a class="header" href="#giriş-13">Giriş</a></h2>
<p><code>useEffect</code> hook'u, fonksiyonel bileşenlerde yan etkiler (side effects) gerçekleştirmek için kullanılan bir React hook'udur. Yan etkiler, veri çekme (data fetching), abonelikler (subscriptions) veya DOM'un manuel olarak değiştirilmesi gibi işlemler olabilir.</p>
<h2 id="temel-kullanım"><a class="header" href="#temel-kullanım">Temel Kullanım</a></h2>
<p><code>useEffect</code> hook'u, bir fonksiyon (etki) ve isteğe bağlı bir bağımlılıklar dizisi ile çağrılır. Bu hook iki argüman alır ve ikinci argüman isteğe bağlıdır.</p>
<h3 id="sözdizimi"><a class="header" href="#sözdizimi">Sözdizimi</a></h3>
<pre><code class="language-javascript">useEffect(effect, dependencies);
</code></pre>
<h2 id="Örnekler-ve-kullanım"><a class="header" href="#Örnekler-ve-kullanım">Örnekler ve Kullanım</a></h2>
<p>Aşağıdaki adımlarla <code>useEffect</code> hook'unun kullanımını daha iyi anlayalım:</p>
<h3 id="adım-1-proje-yapısını-hazırlama"><a class="header" href="#adım-1-proje-yapısını-hazırlama">Adım 1: Proje Yapısını Hazırlama</a></h3>
<p>Projenizin <code>src</code> dizininde, <code>components</code> adında bir klasör oluşturun (eğer zaten yoksa).</p>
<h3 id="adım-2-bileşen-dosyasını-oluşturma"><a class="header" href="#adım-2-bileşen-dosyasını-oluşturma">Adım 2: Bileşen Dosyasını Oluşturma</a></h3>
<p><code>components</code> klasörünün içinde, <code>EmployeeList.jsx</code> adında yeni bir dosya oluşturun. Bu dosya, API'den çalışan verilerini çeken <code>EmployeeList</code> bileşenimizi içerecektir.</p>
<h3 id="adım-3-gerekli-İthalatları-yapma"><a class="header" href="#adım-3-gerekli-İthalatları-yapma">Adım 3: Gerekli İthalatları Yapma</a></h3>
<p><code>EmployeeList.jsx</code> dosyasının içinde, React ve gerekli hook'ları içe aktarın:</p>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';
</code></pre>
<h3 id="adım-4-durum-yönetimi"><a class="header" href="#adım-4-durum-yönetimi">Adım 4: Durum Yönetimi</a></h3>
<p><code>EmployeeList</code> bileşeninin içinde, çalışan verilerini yönetmek için <code>useState</code> hook'unu kullanın:</p>
<pre><code class="language-javascript">const [employees, setEmployees] = useState([]);
</code></pre>
<h3 id="adım-5-useeffect-hookunu-kullanma"><a class="header" href="#adım-5-useeffect-hookunu-kullanma">Adım 5: <code>useEffect</code> Hook'unu Kullanma</a></h3>
<p>Bileşen montaj edildiğinde API'den çalışan verilerini çekmek için bir <code>useEffect</code> hook'u oluşturun:</p>
<pre><code class="language-javascript">useEffect(() =&gt; {
  fetch('https://api.example.com/employees')
    .then(response =&gt; response.json())
    .then(data =&gt; setEmployees(data));
}, []);
</code></pre>
<h3 id="adım-6-verilerin-görüntülenmesi"><a class="header" href="#adım-6-verilerin-görüntülenmesi">Adım 6: Verilerin Görüntülenmesi</a></h3>
<p><code>EmployeeList</code> bileşeninde, çalışan verilerini bir liste içinde render edin:</p>
<pre><code class="language-javascript">return (
  &lt;div&gt;
    &lt;h1&gt;Çalışan Listesi&lt;/h1&gt;
    &lt;ul&gt;
      {employees.map(employee =&gt; (
        &lt;li key={employee.id}&gt;{employee.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  &lt;/div&gt;
);
</code></pre>
<h3 id="adım-7-bileşeni-kullanma"><a class="header" href="#adım-7-bileşeni-kullanma">Adım 7: Bileşeni Kullanma</a></h3>
<p><code>App.js</code> dosyanızda, <code>EmployeeList</code> bileşenini içe aktarın ve kullanın:</p>
<pre><code class="language-javascript">import React from 'react';
import EmployeeList from './components/EmployeeList';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;EmployeeList /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-array-kullanımı"><a class="header" href="#dependency-array-kullanımı">Dependency Array Kullanımı</a></h1>
<p>React uygulamalarında <code>useEffect</code> kancası (hook) kullanılırken Dependency Array (Bağımlılık Dizisi), etkinin ne zaman çalıştırılacağını belirler. Bağımlılık dizisine ne geçirildiğine bağlı olarak, üç farklı şekilde davranabilir:</p>
<ol>
<li>Bağımlılık Dizisi Yok (No Dependency Array)</li>
<li>Boş Bağımlılık Dizisi (Empty Dependency Array)</li>
<li>Bağımlılıklarla Dizi (Array with Dependencies)</li>
</ol>
<h2 id="1-bağımlılık-dizisi-yok"><a class="header" href="#1-bağımlılık-dizisi-yok">1. Bağımlılık Dizisi Yok</a></h2>
<p>Eğer bir bağımlılık dizisi sağlamazsanız, etki her render işleminden sonra çalışır. Bu durumda <code>useEffect</code> her render sonrasında çalışacaktır.</p>
<p><strong>Sözdizimi:</strong></p>
<pre><code class="language-javascript">useEffect(() =&gt; {
  // Kodunuz burada çalışır
});
</code></pre>
<p><strong>Örnek:</strong></p>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log('Component rendered');
  });

  return (
    &lt;div&gt;
      &lt;p&gt;{count} defa tıklandı&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Tıkla&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Example;
</code></pre>
<p>Burada, <code>console.log</code> başlangıç render'ından sonra ve her sonraki render'dan sonra (yani her butona tıklandığında ve <code>count</code> değiştiğinde) çalışacaktır.</p>
<h2 id="2-boş-bağımlılık-dizisi"><a class="header" href="#2-boş-bağımlılık-dizisi">2. Boş Bağımlılık Dizisi</a></h2>
<p>Eğer bağımlılık olarak boş bir dizi <code>[]</code> sağlarsanız, etki yalnızca bir kez çalışır, yani sadece başlangıç render'ından sonra çalışır.</p>
<p><strong>Sözdizimi:</strong></p>
<pre><code class="language-javascript">useEffect(() =&gt; {
  // Kodunuz burada çalışır
}, []);
</code></pre>
<p><strong>Örnek:</strong></p>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log('This only logs once after initial render');
  }, []);

  return (
    &lt;div&gt;
      &lt;p&gt;{count} defa tıklandı&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Tıkla&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Example;
</code></pre>
<p>Bu örnekte, <code>console.log</code> sadece bileşen ilk render edildiğinde bir kez çalışacaktır, sonrasında yeniden render edilse bile çalışmaz.</p>
<h2 id="3-bağımlılıklarla-dizi"><a class="header" href="#3-bağımlılıklarla-dizi">3. Bağımlılıklarla Dizi</a></h2>
<p>Eğer dizinin içine bazı değerler sağlarsanız, etki başlangıç render'ından sonra ve bu değerler her değiştiğinde çalışır.</p>
<p><strong>Sözdizimi:</strong></p>
<pre><code class="language-javascript">useEffect(() =&gt; {
  // Kodunuz burada çalışır
}, [dep1, dep2]);
</code></pre>
<p><strong>Örnek:</strong></p>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log(`Count değişti: ${count}`);
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;{count} defa tıklandı&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Tıkla&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default Example;
</code></pre>
<p>Burada, <code>console.log</code> başlangıç render'ından sonra ve her <code>count</code> değeri değiştiğinde çalışacaktır (yani her butona tıklandığında).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effect-cleanup"><a class="header" href="#effect-cleanup">Effect Cleanup</a></h1>
<p>React uygulamalarında "effect cleanup" kullanımı, bellek sızıntılarını önlemek ve bir bileşen DOM'dan kaldırıldıktan sonra uygulamanızın doğru şekilde çalışmaya devam etmesini sağlamak için önemlidir. Ayrıca, bir bileşen güncellendiğinde, eski etkiyi temizleyip yeni etkiyi çalıştırmadan önce gereklidir. Bu eğitimde, effect cleanup kullanmanın önemini, kullanılmamasının sonuçlarını ve nasıl uygulanacağını ayrıntılı bir şekilde ele alacağız.</p>
<h2 id="neden-effect-cleanup-kullanmalıyız"><a class="header" href="#neden-effect-cleanup-kullanmalıyız">Neden Effect Cleanup Kullanmalıyız?</a></h2>
<ol>
<li>
<p><strong>Bellek Sızıntılarını Önlemek:</strong>
Effect cleanup, bir etkinin oluşturduğu kaynakları, olay dinleyicilerini, abonelikleri veya zamanlayıcıları temizlememizi sağlar. Bu, özellikle uzun ömürlü bileşenler veya sık sık monte edilip kaldırılan bileşenlerle çalışırken çok önemlidir.</p>
</li>
<li>
<p><strong>Efektler Arasında Çakışmaları Önlemek:</strong>
Bir bileşen güncellendiğinde ve yeni bir etki tetiklendiğinde, önceki etkiden gelen temizleme fonksiyonu, yeni etkiyi çalıştırmadan önce önceki durumu veya abonelikleri temizleyebilir.</p>
</li>
</ol>
<h2 id="effect-cleanup-kullanılmamasının-sonuçları"><a class="header" href="#effect-cleanup-kullanılmamasının-sonuçları">Effect Cleanup Kullanılmamasının Sonuçları</a></h2>
<p>Effect cleanup kullanılmadığında, aşağıdaki sorunlarla karşılaşabilirsiniz:</p>
<ul>
<li>
<p><strong>Bellek Sızıntıları:</strong>
Timer bileşeni kaldırıldığında veya güncellendiğinde, <code>setInterval</code> zamanlayıcısı çalışmaya devam eder. Bu, gereksiz kaynak tüketimine ve potansiyel bellek sızıntılarına yol açar.</p>
</li>
<li>
<p><strong>Yanlış Davranışlar:</strong>
Timer bileşeninden ayrıldığınızda ve tekrar döndüğünüzde, her montajda yeni bir <code>setInterval</code> zamanlayıcısı oluşturulur. Bu, aynı anda çalışan birden fazla zamanlayıcıya ve dolayısıyla yanlış sayımlara ve beklenmeyen davranışlara neden olur.</p>
</li>
</ul>
<h2 id="effect-cleanup-nasıl-uygulanır"><a class="header" href="#effect-cleanup-nasıl-uygulanır">Effect Cleanup Nasıl Uygulanır?</a></h2>
<h3 id="adım-adım-uygulama-1"><a class="header" href="#adım-adım-uygulama-1">Adım Adım Uygulama</a></h3>
<ol>
<li>
<p><strong>Proje Dizini:</strong>
Projenizin <code>src</code> dizini içinde, <code>components</code> adlı yeni bir klasör oluşturun (zaten mevcut değilse).</p>
</li>
<li>
<p><strong>Bileşen Oluşturma:</strong>
<code>components</code> klasörü içinde, <code>Timer.jsx</code> adlı yeni bir dosya oluşturun.</p>
</li>
<li>
<p><strong>Bileşeni Kullanma:</strong>
Timer bileşenini kullanmak için, <code>App.jsx</code> dosyanıza veya ihtiyacınız olan başka bir bileşene import edip render edin.</p>
</li>
</ol>
<h3 id="kod-parçacıkları-1"><a class="header" href="#kod-parçacıkları-1">Kod Parçacıkları</a></h3>
<p><strong>Timer.jsx:</strong></p>
<pre><code class="language-jsx">import React, { useState, useEffect } from 'react';

const Timer = () =&gt; {
    const [count, setCount] = useState(0);

    useEffect(() =&gt; {
        const timer = setInterval(() =&gt; {
            setCount(prevCount =&gt; prevCount + 1);
        }, 1000);

        return () =&gt; clearInterval(timer); // Cleanup function

    }, []);

    return (
        &lt;div&gt;
            &lt;h1&gt;Count: {count}&lt;/h1&gt;
        &lt;/div&gt;
    );
};

export default Timer;
</code></pre>
<p>Bu kod parçacığında, <code>useEffect</code> Hook'unun içine bir <code>setInterval</code> zamanlayıcısı yerleştirilmiştir. Ancak, zamanlayıcıyı temizlemek için bir cleanup fonksiyonu (<code>clearInterval(timer)</code>) eklenmiştir. Bu, bileşen kaldırıldığında veya güncellendiğinde zamanlayıcının düzgün şekilde temizlenmesini sağlar.</p>
<h2 id="neden-effect-cleanup-kullanmalıyız-devam"><a class="header" href="#neden-effect-cleanup-kullanmalıyız-devam">Neden Effect Cleanup Kullanmalıyız? (Devam)</a></h2>
<h3 id="bellek-sızıntılarını-Önlemek"><a class="header" href="#bellek-sızıntılarını-Önlemek">Bellek Sızıntılarını Önlemek</a></h3>
<p>Effect cleanup, etki tarafından oluşturulan kaynakların, olay dinleyicilerinin, aboneliklerin veya zamanlayıcıların düzgün şekilde temizlenmesini sağlar. Bu, özellikle uzun ömürlü bileşenler veya sık sık monte edilip kaldırılan bileşenlerle çalışırken önemlidir.</p>
<h3 id="efektler-arasında-Çakışmaları-Önlemek"><a class="header" href="#efektler-arasında-Çakışmaları-Önlemek">Efektler Arasında Çakışmaları Önlemek</a></h3>
<p>Bir bileşen güncellendiğinde ve yeni bir etki tetiklendiğinde, önceki etkiden gelen cleanup fonksiyonu, yeni etkiyi çalıştırmadan önce önceki durumu veya abonelikleri temizleyebilir.</p>
<h3 id="kaynak-kullanımını-optimize-etmek"><a class="header" href="#kaynak-kullanımını-optimize-etmek">Kaynak Kullanımını Optimize Etmek</a></h3>
<p>Kaynakları düzgün şekilde temizleyerek, zamanlayıcılar, olay dinleyiciler veya abonelikler gibi kaynakların artık ihtiyaç duyulmadığında serbest bırakılmasını sağlarız. Bu, kaynak kullanımını optimize eder ve uygulamanızın performansını artırır.</p>
<p>Bu eğitimde, React uygulamalarında effect cleanup kullanımının önemini ve nasıl uygulanacağını ayrıntılı bir şekilde ele aldık. Bu prensipleri uygulayarak, bellek sızıntılarını önleyebilir, beklenmeyen davranışları minimize edebilir ve uygulamanızın performansını optimize edebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uyruğu-tahmin-etme"><a class="header" href="#uyruğu-tahmin-etme">Uyruğu Tahmin Etme</a></h1>
<h2 id="amaç-2"><a class="header" href="#amaç-2"><strong>Amaç:</strong></a></h2>
<p>Bu görevin amacı, React hooks ve React uygulamalarında asenkron veri çekme konusundaki anlayışınızı geliştirmektir. Kullanıcı tarafından girilen bir ismin en olası uyruğunu tahmin eden bir "Uyruğu Tahmin Etme" uygulaması oluşturacaksınız. Üçüncü taraf bir API ile etkileşime girecek, yüklenme durumlarını yönetecek ve verileri kullanıcı dostu bir formatta <strong>Tailwind CSS</strong> kullanarak sunacaksınız.</p>
<h2 id="gereksinimler-6"><a class="header" href="#gereksinimler-6">Gereksinimler</a></h2>
<ol>
<li>
<p><strong>React Uygulaması:</strong> Bu uygulamayı oluşturmak için React.js kullanmalısınız. Bileşenler, props, state ve yaşam döngüsü metotlarının prensiplerini anlamalı ve kullanmalısınız.</p>
</li>
<li>
<p><strong>Hooks Kullanımı:</strong> Bileşeninizin durumu ve yan etkilerini yönetmek için <strong><code>useState</code></strong> ve <strong><code>useEffect</code></strong> gibi React hooks kullanın.</p>
</li>
<li>
<p><strong>Veri Çekme:</strong> Nationalize.io API'sinden veri çekmeli, yüklenme durumunu yönetmeli ve verileri kullanıcıya sunmalısınız.</p>
<p><strong>API -</strong> <a href="https://api.nationalize.io/?name=$%7Bname%7D">https://api.nationalize.io/?name=${name}</a></p>
</li>
<li>
<p><strong>Kullanıcı Girişi:</strong> Kullanıcı, bir metin alanına bir isim girebilmelidir.</p>
</li>
<li>
<p><strong>Kullanıcı Eylemi Üzerine Veri Çekme:</strong> Bir düğmeye tıklama ile, girilen ismin tahmin edilen uyruğunu API'den çekin.</p>
</li>
<li>
<p><strong>Yüklenme Durumunu Yönetme:</strong> Veriler çekilirken kullanıcıya "Yükleniyor..." mesajı gösterin.</p>
</li>
<li>
<p><strong>Verilerin Görüntülenmesi:</strong> Veriler çekildikten sonra, tahmin edilen uyruğu ve tahmin güvenini yüzde olarak kullanıcıya gösterin.</p>
</li>
<li>
<p><strong>Sıfırlama Fonksiyonu:</strong> Tüm görüntülenen verileri ve giriş alanını temizleyen bir sıfırlama düğmesi uygulayın.</p>
</li>
<li>
<p><strong>Hata Yönetimi:</strong> API tahmin edilen bir uyruğu döndürmezse, kullanıcıya dostça bir hata mesajı gösterin.</p>
</li>
<li>
<p><strong>Stil:</strong> Uygulama iyi tasarlanmış ve kullanıcı dostu olmalıdır. Uygulamanızı stilize etmek için CSS-in-JS veya harici bir stil dosyası kullanın.</p>
</li>
</ol>
<h2 id="teslimat-2"><a class="header" href="#teslimat-2">Teslimat</a></h2>
<ol>
<li>React projenizi barındırmak için bir GitHub deposu oluşturun.</li>
<li>Kodunuzu depoya commit ve push yapın.</li>
<li>Uygulamanızı nasıl çalıştıracağınıza dair talimatlar içeren bir README dosyası ekleyin.</li>
<li>Netlify veya GitHub Pages gibi bir platform kullanarak web sitenizin canlı bir demosunu sağlayın.</li>
</ol>
<h2 id="detaylı-eğitim"><a class="header" href="#detaylı-eğitim">Detaylı Eğitim</a></h2>
<h3 id="proje-kurulumu-1"><a class="header" href="#proje-kurulumu-1">Proje Kurulumu</a></h3>
<ol>
<li><strong>React Uygulamasını Oluşturma:</strong></li>
</ol>
<pre><code class="language-bash">npx create-react-app ulke-tahmin
cd ulke-tahmin
</code></pre>
<ol start="2">
<li><strong>Gerekli Kütüphanelerin Yüklenmesi:</strong></li>
</ol>
<pre><code class="language-bash">npm install axios
npm install tailwindcss
npx tailwindcss init
</code></pre>
<h3 id="tailwind-css-kurulumu"><a class="header" href="#tailwind-css-kurulumu">Tailwind CSS Kurulumu</a></h3>
<p><code>tailwind.config.js</code> dosyasını açın ve aşağıdaki şekilde yapılandırın:</p>
<pre><code class="language-js">module.exports = {
  purge: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
}
</code></pre>
<p><code>src/index.css</code> dosyasına Tailwind direktiflerini ekleyin:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h3 id="bileşenlerin-oluşturulması"><a class="header" href="#bileşenlerin-oluşturulması">Bileşenlerin Oluşturulması</a></h3>
<p><strong>App.js:</strong></p>
<pre><code class="language-jsx">import React, { useState } from 'react';
import axios from 'axios';
import './App.css';

function App() {
  const [name, setName] = useState('');
  const [nationality, setNationality] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchNationality = async () =&gt; {
    setLoading(true);
    setError(null);
    try {
      const response = await axios.get(`https://api.nationalize.io/?name=${name}`);
      if (response.data &amp;&amp; response.data.country &amp;&amp; response.data.country.length &gt; 0) {
        setNationality(response.data.country[0]);
      } else {
        setError('Tahmin edilemedi.');
      }
    } catch (err) {
      setError('Bir hata oluştu.');
    }
    setLoading(false);
  };

  const handleReset = () =&gt; {
    setName('');
    setNationality(null);
    setError(null);
  };

  return (
    &lt;div className="container mx-auto p-4"&gt;
      &lt;h1 className="text-2xl font-bold mb-4"&gt;Uyruğu Tahmin Etme&lt;/h1&gt;
      &lt;input
        type="text"
        value={name}
        onChange={(e) =&gt; setName(e.target.value)}
        className="border p-2 mb-4 w-full"
        placeholder="İsim giriniz"
      /&gt;
      &lt;button
        onClick={fetchNationality}
        className="bg-blue-500 text-white px-4 py-2 mb-4"
      &gt;
        Tahmin Et
      &lt;/button&gt;
      &lt;button
        onClick={handleReset}
        className="bg-red-500 text-white px-4 py-2 mb-4 ml-2"
      &gt;
        Sıfırla
      &lt;/button&gt;
      {loading &amp;&amp; &lt;p&gt;Yükleniyor...&lt;/p&gt;}
      {error &amp;&amp; &lt;p className="text-red-500"&gt;{error}&lt;/p&gt;}
      {nationality &amp;&amp; (
        &lt;div&gt;
          &lt;p&gt;Uyruğu: {nationality.country_id}&lt;/p&gt;
          &lt;p&gt;Güven: {Math.round(nationality.probability * 100)}%&lt;/p&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p><strong>App.css:</strong></p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;

.container {
  max-width: 600px;
  margin: 0 auto;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-rendering"><a class="header" href="#dynamic-rendering">Dynamic Rendering</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="liste-render-etme"><a class="header" href="#liste-render-etme">Liste Render Etme</a></h1>
<p>Bu eğitim, React kullanarak bir listeyi nasıl render edeceğinizi öğretmeyi amaçlamaktadır. Kod örnekleriyle birlikte adım adım ilerleyerek bir bileşen yapısının nasıl oluşturulacağını ve kullanılacağını öğreneceksiniz. Eğitim boyunca dikkat edilmesi gereken noktaları ve yaygın hataları ele alacağız.</p>
<h2 id="1-proje-yapısının-oluşturulması-1"><a class="header" href="#1-proje-yapısının-oluşturulması-1">1. Proje Yapısının Oluşturulması</a></h2>
<p>İlk olarak, bileşenlerimizi saklayacağımız bir klasör yapısı oluşturmamız gerekiyor.</p>
<ul>
<li>Proje dizininde <code>src</code> klasörü altında <code>components</code> adında yeni bir klasör oluşturun.</li>
</ul>
<h2 id="2-list-bileşeninin-oluşturulması"><a class="header" href="#2-list-bileşeninin-oluşturulması">2. List Bileşeninin Oluşturulması</a></h2>
<p>Yeni klasörümüzde <code>List.jsx</code> adında bir dosya oluşturacağız. Bu dosya, listeyi render eden bileşeni içerecek.</p>
<pre><code class="language-jsx">// src/components/List.jsx

import React from 'react';
import PropTypes from 'prop-types';

const List = ({ items }) =&gt; {
    return (
        &lt;ul&gt;
            {items.map((item, index) =&gt; (
                &lt;li key={index}&gt;{item}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
};

List.propTypes = {
    items: PropTypes.arrayOf(PropTypes.string).isRequired,
};

export default List;
</code></pre>
<h2 id="3-grocerylist-bileşeninin-oluşturulması"><a class="header" href="#3-grocerylist-bileşeninin-oluşturulması">3. GroceryList Bileşeninin Oluşturulması</a></h2>
<p><code>GroceryList.jsx</code> adında yeni bir bileşen oluşturacağız. Bu bileşen, <code>List</code> bileşenini veriyle besleyecek.</p>
<pre><code class="language-jsx">// src/components/GroceryList.jsx

import React from 'react';
import List from './List';

const GroceryList = () =&gt; {
    const groceries = ['Elma', 'Muz', 'Portakal', 'Çilek'];

    return (
        &lt;div&gt;
            &lt;h2&gt;Alışveriş Listesi&lt;/h2&gt;
            &lt;List items={groceries} /&gt;
        &lt;/div&gt;
    );
};

export default GroceryList;
</code></pre>
<h2 id="4-app-bileşenini-güncelleme"><a class="header" href="#4-app-bileşenini-güncelleme">4. App Bileşenini Güncelleme</a></h2>
<p><code>App</code> bileşenini güncelleyerek <code>GroceryList</code> bileşenini kullanacağız.</p>
<pre><code class="language-jsx">// src/App.js

import React from 'react';
import GroceryList from './components/GroceryList';

const App = () =&gt; {
    return (
        &lt;div&gt;
            &lt;h1&gt;React List Render Örneği&lt;/h1&gt;
            &lt;GroceryList /&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<h1 id="kritik-noktalar"><a class="header" href="#kritik-noktalar">Kritik Noktalar</a></h1>
<ul>
<li><strong>PropTypes Kullanımı</strong>: <code>List</code> bileşeninde <code>PropTypes</code> kullanarak <code>items</code> prop'unun bir dizi string olmasını zorunlu kıldık. Bu, bileşenin beklediği veri türlerini belirterek hataların önlenmesine yardımcı olur.</li>
<li><strong>Anahtarlar (Keys)</strong>: Liste öğelerini render ederken, her öğeye benzersiz bir <code>key</code> atanması önemlidir. Bu, React'in liste öğelerini doğru şekilde yönetmesini sağlar.</li>
<li><strong>Bileşen Yapısı</strong>: Bileşenleri küçük, yönetilebilir ve tekrar kullanılabilir parçalara bölmek, kodun okunabilirliğini ve bakımını kolaylaştırır.</li>
</ul>
<h1 id="yaygın-hatalar-ve-Çözümleri"><a class="header" href="#yaygın-hatalar-ve-Çözümleri">Yaygın Hatalar ve Çözümleri</a></h1>
<ul>
<li><strong>Anahtar Eksikliği</strong>: Liste öğelerine <code>key</code> verilmemesi, performans sorunlarına ve yanlış render edilmelere neden olabilir.
<ul>
<li>Çözüm: Her öğeye benzersiz bir <code>key</code> verin.</li>
</ul>
</li>
<li><strong>Yanlış Prop Türleri</strong>: Bileşenlerin beklediği prop türlerinin doğru belirtilmemesi, çalışma zamanı hatalarına yol açabilir.
<ul>
<li>Çözüm: <code>PropTypes</code> kullanarak prop türlerini açıkça belirtin.</li>
</ul>
</li>
</ul>
<p>Bu eğitimde, React kullanarak bir liste bileşenini nasıl oluşturacağınızı ve render edeceğinizi öğrendiniz. Bu yapı, uygulamanızda tekrar tekrar kullanabileceğiniz esnek ve genişletilebilir bir temel sağlar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="koşullu-rendering"><a class="header" href="#koşullu-rendering">Koşullu Rendering</a></h1>
<p>React'te koşullu rendering, belirli koşullar veya kriterler temelinde bileşenleri veya öğeleri görüntülemenize olanak tanıyan bir desendir. Uygulamanızın her durumu için ayrı görünümler veya bileşenler oluşturmak yerine, mevcut durum veya bileşenlerin propslarına bağlı olarak içeriği dinamik olarak görüntülemek için koşullu rendering kullanabilirsiniz.</p>
<h2 id="koşullu-rendering-yöntemleri"><a class="header" href="#koşullu-rendering-yöntemleri">Koşullu Rendering Yöntemleri</a></h2>
<h3 id="1-ternary-conditional-operator-Üçlü-koşul-operatörü"><a class="header" href="#1-ternary-conditional-operator-Üçlü-koşul-operatörü">1. Ternary Conditional Operator (Üçlü Koşul Operatörü)</a></h3>
<p>Üçlü koşul operatörü, bir bileşeni veya öğeyi koşullu olarak render etmenin özlü bir yoludur. Bu operatör <code>?</code> ve <code>:</code> işaretleri kullanılarak uygulanır.</p>
<h4 id="Örnek-3"><a class="header" href="#Örnek-3">Örnek:</a></h4>
<p>Aşağıdaki örnekte, <code>UserList</code> adında bir bileşen oluşturulmuştur. Bu bileşen, bir <code>users</code> listesini props olarak alır. Liste boş değilse, kullanıcıları bir liste formatında görüntüler. Liste boşsa, "No users found" mesajını görüntüler.</p>
<pre><code class="language-javascript">import React from 'react';

const UserList = ({ users }) =&gt; {
  return (
    &lt;div&gt;
      {users.length &gt; 0 ? (
        &lt;ul&gt;
          {users.map(user =&gt; (
            &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      ) : (
        &lt;p&gt;No users found&lt;/p&gt;
      )}
    &lt;/div&gt;
  );
};

export default UserList;
</code></pre>
<h3 id="2-logical--operator-mantıksal--operatörü"><a class="header" href="#2-logical--operator-mantıksal--operatörü">2. Logical &amp;&amp; Operator (Mantıksal &amp;&amp; Operatörü)</a></h3>
<p>Mantıksal <code>&amp;&amp;</code> operatörü, yalnızca bir koşul doğru olduğunda bir şeyin render edilmesini istediğinizde kullanışlıdır. Koşul doğruysa, <code>&amp;&amp;</code> operatörünün sağındaki ifade render edilir.</p>
<h4 id="Örnek-4"><a class="header" href="#Örnek-4">Örnek:</a></h4>
<p>Aşağıda, kullanıcıların sayısını gösteren bir bileşen bulunmaktadır. Kullanıcı sayısı 0'dan büyükse, kullanıcıların sayısını görüntüler.</p>
<pre><code class="language-javascript">import React from 'react';

const UserCount = ({ users }) =&gt; {
  return (
    &lt;div&gt;
      {users.length &gt; 0 &amp;&amp; &lt;p&gt;Number of users: {users.length}&lt;/p&gt;}
    &lt;/div&gt;
  );
};

export default UserCount;
</code></pre>
<h3 id="3-if-else-statement-if-else-deyimi"><a class="header" href="#3-if-else-statement-if-else-deyimi">3. If-Else Statement (If-Else Deyimi)</a></h3>
<p>Daha geleneksel koşullu rendering, bileşen fonksiyonları içinde if-else deyimleri kullanılarak yapılabilir. Bu yaklaşım, daha karmaşık koşulların işlenmesi gerektiğinde faydalıdır.</p>
<h4 id="Örnek-5"><a class="header" href="#Örnek-5">Örnek:</a></h4>
<p>Aşağıda, bir kullanıcı bilgisi bileşeni bulunmaktadır. Kullanıcı bilgileri mevcutsa, bilgileri görüntüler; değilse, "User not found" mesajını görüntüler.</p>
<pre><code class="language-javascript">import React from 'react';

const UserInfo = ({ user }) =&gt; {
  if (user) {
    return (
      &lt;div&gt;
        &lt;h2&gt;{user.name}&lt;/h2&gt;
        &lt;p&gt;Email: {user.email}&lt;/p&gt;
        &lt;p&gt;Age: {user.age}&lt;/p&gt;
      &lt;/div&gt;
    );
  } else {
    return &lt;p&gt;User not found&lt;/p&gt;;
  }
};

export default UserInfo;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline--operatörü"><a class="header" href="#inline--operatörü">Inline &amp;&amp; Operatörü</a></h1>
<p>Bu eğitimde, React uygulamalarında inline if ifadeleriyle <code>&amp;&amp;</code> (mantıksal ve) operatörünün nasıl kullanılacağını detaylı bir şekilde ele alacağız. Bu teknik, belirli bir duruma bağlı olarak bileşenlerin JSX içinde koşullu olarak render edilmesini sağlar. React bileşenlerinde bu yöntemi kullanarak öğeleri durumlarına göre görüntüleyebilir veya gizleyebilirsiniz.</p>
<h2 id="adım-adım-uygulama-2"><a class="header" href="#adım-adım-uygulama-2">Adım Adım Uygulama</a></h2>
<h3 id="1-bileşenler-İçin-yeni-klasör-oluşturma"><a class="header" href="#1-bileşenler-İçin-yeni-klasör-oluşturma">1. Bileşenler İçin Yeni Klasör Oluşturma</a></h3>
<p>Projenizin <code>src</code> dizininde, bileşenlerinizi yerleştireceğiniz bir <code>components</code> klasörü oluşturun. Bu, projeyi daha düzenli ve yönetilebilir hale getirecektir.</p>
<h3 id="2-conditionaldisplay-bileşenini-oluşturma"><a class="header" href="#2-conditionaldisplay-bileşenini-oluşturma">2. <code>ConditionalDisplay</code> Bileşenini Oluşturma</a></h3>
<p><code>components</code> klasörü içinde <code>ConditionalDisplay.jsx</code> adlı bir JSX dosyası oluşturun ve basit bir fonksiyonel bileşen tanımlayın.</p>
<pre><code class="language-jsx">// components/ConditionalDisplay.jsx
import React from 'react';

const ConditionalDisplay = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Conditional Display Component&lt;/h1&gt;
    &lt;/div&gt;
  );
};

export default ConditionalDisplay;
</code></pre>
<h3 id="3-durum-değişkeni-kurulumu"><a class="header" href="#3-durum-değişkeni-kurulumu">3. Durum Değişkeni Kurulumu</a></h3>
<p><code>ConditionalDisplay</code> bileşeni içinde, <code>useState</code> hook'unu kullanarak <code>isShown</code> adlı bir durum değişkeni oluşturun. Bu değişken, belirli bir öğenin gösterilip gösterilmeyeceğini belirleyecektir.</p>
<pre><code class="language-jsx">import React, { useState } from 'react';

const ConditionalDisplay = () =&gt; {
  const [isShown, setIsShown] = useState(false);

  return (
    &lt;div&gt;
      &lt;h1&gt;Conditional Display Component&lt;/h1&gt;
    &lt;/div&gt;
  );
};

export default ConditionalDisplay;
</code></pre>
<h3 id="4-görüntüleme-durumunu-değiştirmek-İçin-buton-ekleyin"><a class="header" href="#4-görüntüleme-durumunu-değiştirmek-İçin-buton-ekleyin">4. Görüntüleme Durumunu Değiştirmek İçin Buton Ekleyin</a></h3>
<p>Bileşenin JSX'inde, <code>isShown</code> durumunu tıklamayla değiştiren bir buton öğesi oluşturun.</p>
<pre><code class="language-jsx">import React, { useState } from 'react';

const ConditionalDisplay = () =&gt; {
  const [isShown, setIsShown] = useState(false);

  const toggleDisplay = () =&gt; {
    setIsShown(!isShown);
  };

  return (
    &lt;div&gt;
      &lt;h1&gt;Conditional Display Component&lt;/h1&gt;
      &lt;button onClick={toggleDisplay}&gt;
        Toggle display
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default ConditionalDisplay;
</code></pre>
<h3 id="5-inline-if-ile--operatörünü-kullanarak-Öğeyi-koşullu-olarak-render-edin"><a class="header" href="#5-inline-if-ile--operatörünü-kullanarak-Öğeyi-koşullu-olarak-render-edin">5. Inline if ile <code>&amp;&amp;</code> Operatörünü Kullanarak Öğeyi Koşullu Olarak Render Edin</a></h3>
<p>JSX içinde, <code>isShown</code> değişkenine bağlı olarak bir paragraf öğesini koşullu olarak render edin.</p>
<pre><code class="language-jsx">import React, { useState } from 'react';

const ConditionalDisplay = () =&gt; {
  const [isShown, setIsShown] = useState(false);

  const toggleDisplay = () =&gt; {
    setIsShown(!isShown);
  };

  return (
    &lt;div&gt;
      &lt;h1&gt;Conditional Display Component&lt;/h1&gt;
      &lt;button onClick={toggleDisplay}&gt;
        Toggle display
      &lt;/button&gt;
      {isShown &amp;&amp; &lt;p&gt;This is a conditionally rendered paragraph.&lt;/p&gt;}
    &lt;/div&gt;
  );
};

export default ConditionalDisplay;
</code></pre>
<h3 id="6-conditionaldisplay-bileşenini-İçeri-aktarma-ve-kullanma"><a class="header" href="#6-conditionaldisplay-bileşenini-İçeri-aktarma-ve-kullanma">6. <code>ConditionalDisplay</code> Bileşenini İçeri Aktarma ve Kullanma</a></h3>
<p>Ana bileşeninizde veya <code>App.jsx</code> dosyanızda <code>ConditionalDisplay</code> bileşenini içe aktarın ve JSX içine dahil edin.</p>
<pre><code class="language-jsx">// src/App.jsx
import React from 'react';
import ConditionalDisplay from './components/ConditionalDisplay';

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;ConditionalDisplay /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<h3 id="sonuç-18"><a class="header" href="#sonuç-18">Sonuç</a></h3>
<p>Uygulamayı çalıştırdığınızda ve "Toggle display" butonuna tıkladığınızda, paragraf öğesinin <code>isShown</code> durumuna bağlı olarak gösterileceğini veya gizleneceğini göreceksiniz. Bu, React'te <code>&amp;&amp;</code> operatörünü kullanarak öğeleri koşullu olarak render etmenin temel bir örneğidir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-if-else-Şablonları"><a class="header" href="#react-if-else-Şablonları">React If-Else Şablonları</a></h1>
<p>Bu eğitimde, React bileşenlerinde koşullu render işlemlerini ele alacağız. React'te koşullu render işlemleri, belirli koşullara bağlı olarak elemanların görüntülenmesini veya gizlenmesini sağlar. Bu süreçte kullanılan iki temel teknik, "Mantıksal &amp;&amp; operatörü ile Inline if" ve "JSX'te If-Else" teknikleridir. Bu tekniklerin nasıl çalıştığını ve hangi durumlarda tercih edilmesi gerektiğini ayrıntılı olarak inceleyeceğiz.</p>
<h2 id="mantıksal--operatörü-ile-inline-if"><a class="header" href="#mantıksal--operatörü-ile-inline-if">Mantıksal &amp;&amp; Operatörü ile Inline if</a></h2>
<p>Mantıksal &amp;&amp; operatörü, koşullu render işlemleri için kısa devre değerlendirmesi (short-circuit evaluation) yapar. Bu operatör kullanılarak şu işlemler gerçekleştirilir:</p>
<ul>
<li>&amp;&amp; operatörünün sol tarafındaki koşul doğru olduğunda, sağ taraftaki eleman render edilir.</li>
<li>&amp;&amp; operatörünün sol tarafındaki koşul yanlış olduğunda, hiçbir şey render edilmez.</li>
<li>Bu teknik, sadece belirli bir koşulun sağlanması durumunda bir elemanı render etmeniz gerektiğinde basit ve etkili bir çözümdür.</li>
</ul>
<h2 id="kod-Örneği-1"><a class="header" href="#kod-Örneği-1">Kod Örneği</a></h2>
<pre><code class="language-jsx">const Greeting = ({ isLoggedIn }) =&gt; (
  &lt;div&gt;
    {isLoggedIn &amp;&amp; &lt;h1&gt;Welcome back!&lt;/h1&gt;}
  &lt;/div&gt;
);
</code></pre>
<h2 id="jsxte-if-else-kullanımı"><a class="header" href="#jsxte-if-else-kullanımı">JSX'te If-Else Kullanımı</a></h2>
<p>JSX'te if-else kullanımı, JavaScript'in if-else ifadeleri ile JSX içinde elemanları koşullu olarak render etme tekniğidir. Bu teknik, daha esnek olup, birden fazla koşul veya dallanma gerektiğinde kullanılır.</p>
<ul>
<li>If-else ifadeleri bir fonksiyon içinde veya hemen çağrılan bir fonksiyon ifadesi (IIFE) kullanılarak JSX içinde yer alır.</li>
<li>Daha karmaşık durumlarda birden fazla eleman veya kod dalının render edilmesi gerektiğinde kullanılır.</li>
</ul>
<h2 id="adım-adım-jsxte-if-else-kullanımı"><a class="header" href="#adım-adım-jsxte-if-else-kullanımı">Adım Adım JSX'te If-Else Kullanımı</a></h2>
<h3 id="1-bileşenler-İçin-yeni-klasör-oluşturma-1"><a class="header" href="#1-bileşenler-İçin-yeni-klasör-oluşturma-1">1. Bileşenler İçin Yeni Klasör Oluşturma</a></h3>
<p>Projenizin <code>src</code> dizini içinde <code>components</code> adında yeni bir klasör oluşturun.</p>
<h3 id="2-conditionalgreeting-bileşenini-oluşturma"><a class="header" href="#2-conditionalgreeting-bileşenini-oluşturma">2. ConditionalGreeting Bileşenini Oluşturma</a></h3>
<p><code>components</code> klasörü içinde <code>ConditionalGreeting.jsx</code> adında yeni bir JSX dosyası oluşturun ve basit bir fonksiyonel bileşen tanımlayın.</p>
<pre><code class="language-jsx">import React, { useState } from 'react';

const ConditionalGreeting = () =&gt; {
  const [isMorning, setIsMorning] = useState(true);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setIsMorning(!isMorning)}&gt;
        Toggle Greeting
      &lt;/button&gt;
      {(() =&gt; {
        if (isMorning) {
          return &lt;h1&gt;Good Morning!&lt;/h1&gt;;
        } else {
          return &lt;h1&gt;Good Evening!&lt;/h1&gt;;
        }
      })()}
    &lt;/div&gt;
  );
};

export default ConditionalGreeting;
</code></pre>
<h3 id="3-state-değişkenini-ayarlama"><a class="header" href="#3-state-değişkenini-ayarlama">3. State Değişkenini Ayarlama</a></h3>
<p><code>ConditionalGreeting</code> bileşeni içinde <code>useState</code> kancası kullanarak <code>isMorning</code> adında bir state değişkeni oluşturun. Bu değişken, hangi selamlamanın görüntüleneceğini belirleyecektir.</p>
<h3 id="4-selamlamayı-değiştiren-buton-eklemek"><a class="header" href="#4-selamlamayı-değiştiren-buton-eklemek">4. Selamlamayı Değiştiren Buton Eklemek</a></h3>
<p>Bileşenin JSX kısmında, tıklandığında <code>isMorning</code> durumunu değiştiren bir buton elementi oluşturun.</p>
<h3 id="5-if-else-İfadesi-kullanarak-elemanları-koşullu-olarak-render-etme"><a class="header" href="#5-if-else-İfadesi-kullanarak-elemanları-koşullu-olarak-render-etme">5. If-Else İfadesi Kullanarak Elemanları Koşullu Olarak Render Etme</a></h3>
<p>JSX içinde if-else ifadelerini kullanabilmek için koşullu mantığı bir fonksiyon içine sarın veya hemen çağrılan bir fonksiyon ifadesi (IIFE) kullanın. Bu örnekte, IIFE kullanacağız.</p>
<h3 id="6-conditionalgreeting-bileşenini-İthal-etme-ve-kullanma"><a class="header" href="#6-conditionalgreeting-bileşenini-İthal-etme-ve-kullanma">6. ConditionalGreeting Bileşenini İthal Etme ve Kullanma</a></h3>
<p>Ana bileşen veya <code>App.jsx</code> dosyasında <code>ConditionalGreeting</code> bileşenini ithal edin ve JSX içinde kullanın.</p>
<pre><code class="language-jsx">import React from 'react';
import ConditionalGreeting from './components/ConditionalGreeting';

const App = () =&gt; (
  &lt;div&gt;
    &lt;ConditionalGreeting /&gt;
  &lt;/div&gt;
);

export default App;
</code></pre>
<h2 id="sonuç-19"><a class="header" href="#sonuç-19">Sonuç</a></h2>
<p>Bu eğitimde, React bileşenlerinde koşullu render işlemleri için kullanılan iki temel teknik olan mantıksal &amp;&amp; operatörü ile inline if ve JSX'te if-else ifadelerini inceledik. Her iki tekniğin de avantajları ve kullanım durumlarına göre tercih edilmesi gereken senaryoları ele aldık. Uygulamalı örneklerle, bu tekniklerin nasıl uygulanacağını gösterdik.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ile-görev-yöneticisi-uygulaması-geliştirme"><a class="header" href="#react-ile-görev-yöneticisi-uygulaması-geliştirme">React ile Görev Yöneticisi Uygulaması Geliştirme</a></h1>
<h2 id="giriş-14"><a class="header" href="#giriş-14">Giriş</a></h2>
<p>Bu eğitim, React kullanarak bir Görev Yöneticisi uygulaması oluşturmayı amaçlamaktadır. Uygulama, kullanıcıların görev ekleyip yönetebileceği, görevlerin durumunu değiştirebileceği ve görevleri silebileceği bir yapı sunacaktır. Eğitim boyunca, React bileşenlerinin, durum yönetiminin ve koşullu render işlemlerinin nasıl kullanılacağını öğreneceksiniz. Ayrıca, Tailwind CSS kullanarak uygulamanın stilini oluşturacağız.</p>
<h2 id="gereksinimler-7"><a class="header" href="#gereksinimler-7">Gereksinimler</a></h2>
<ol>
<li><strong>React Uygulaması</strong>: Bu uygulamayı React.js kullanarak oluşturmalısınız. Bileşenler, durum (state) ve özellikler (props) prensiplerini anlamalı ve kullanmalısınız.</li>
<li><strong>Görev Yöneticisi Bileşeni</strong>: Görevlerin durumunu yönetecek ve görev yönetimi için gerekli işlevselliği sağlayacak bir Görev Yöneticisi bileşeni oluşturun.</li>
<li><strong>Görev Formu</strong>: Kullanıcıların yeni görevler ekleyebileceği bir form dahil edin. Form, görev başlığı ve açıklaması için giriş alanları içermelidir.</li>
<li><strong>Görev Listesi</strong>: Görev listesini <code>map</code> fonksiyonunu kullanarak dinamik olarak görüntüleyin. Her görev, bir kart veya liste öğesi olarak render edilmelidir. Görev başlığını ve açıklamasını gösterin.</li>
<li><strong>Koşullu Render</strong>: Görevlerin farklı durumlarını ele almak için koşullu render işlemini uygulayın. Örneğin, görev olmadığında bir mesaj gösterin veya tamamlanmış görevler için "tamamlandı" durumu gösterin.</li>
<li><strong>Görev İşlemleri</strong>: Görevleri tamamlanmış olarak işaretleme, görevleri silme veya görev bilgilerini güncelleme işlevselliği sağlayın.</li>
<li><strong>Tailwind CSS ile Stil Verme</strong>: Uygulamanızın stilini Tailwind CSS kullanarak oluşturun. Çeşitli yardımcı sınıfları, özel stilleri ve duyarlı tasarım prensiplerini kullanarak çekici ve kullanıcı dostu bir arayüz oluşturun.</li>
</ol>
<h2 id="uygulama-adımları-1"><a class="header" href="#uygulama-adımları-1">Uygulama Adımları</a></h2>
<h3 id="1-proje-yapısının-oluşturulması-2"><a class="header" href="#1-proje-yapısının-oluşturulması-2">1. Proje Yapısının Oluşturulması</a></h3>
<p>Projenizi başlatmak için React uygulamasını oluşturun ve gerekli bağımlılıkları yükleyin:</p>
<pre><code class="language-bash">npx create-react-app task-manager
cd task-manager
npm install tailwindcss
npx tailwindcss init
</code></pre>
<p><code>tailwind.config.js</code> dosyasını aşağıdaki gibi yapılandırın:</p>
<pre><code class="language-javascript">module.exports = {
  purge: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'],
  darkMode: false,
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>
<p><code>src/index.css</code> dosyasını aşağıdaki gibi düzenleyin:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h3 id="2-görev-yöneticisi-bileşeninin-oluşturulması"><a class="header" href="#2-görev-yöneticisi-bileşeninin-oluşturulması">2. Görev Yöneticisi Bileşeninin Oluşturulması</a></h3>
<p>Görev Yöneticisi bileşenini oluşturun ve gerekli durumu yönetin:</p>
<pre><code class="language-javascript">import React, { useState } from 'react';

const TaskManager = () =&gt; {
  const [tasks, setTasks] = useState([]);
  const [taskTitle, setTaskTitle] = useState('');
  const [taskDescription, setTaskDescription] = useState('');

  const addTask = () =&gt; {
    setTasks([...tasks, { title: taskTitle, description: taskDescription, completed: false }]);
    setTaskTitle('');
    setTaskDescription('');
  };

  const deleteTask = (index) =&gt; {
    const newTasks = tasks.filter((_, i) =&gt; i !== index);
    setTasks(newTasks);
  };

  const completeTask = (index) =&gt; {
    const newTasks = tasks.map((task, i) =&gt; 
      i === index ? { ...task, completed: !task.completed } : task
    );
    setTasks(newTasks);
  };

  return (
    &lt;div className="p-4"&gt;
      &lt;h1 className="text-2xl font-bold mb-4"&gt;Görev Yöneticisi&lt;/h1&gt;
      &lt;div className="mb-4"&gt;
        &lt;input 
          type="text" 
          placeholder="Görev Başlığı" 
          value={taskTitle}
          onChange={(e) =&gt; setTaskTitle(e.target.value)}
          className="border p-2 mr-2"
        /&gt;
        &lt;input 
          type="text" 
          placeholder="Görev Açıklaması" 
          value={taskDescription}
          onChange={(e) =&gt; setTaskDescription(e.target.value)}
          className="border p-2"
        /&gt;
        &lt;button onClick={addTask} className="bg-blue-500 text-white p-2 ml-2"&gt;Görev Ekle&lt;/button&gt;
      &lt;/div&gt;
      &lt;TaskList tasks={tasks} deleteTask={deleteTask} completeTask={completeTask} /&gt;
    &lt;/div&gt;
  );
};

const TaskList = ({ tasks, deleteTask, completeTask }) =&gt; {
  if (tasks.length === 0) {
    return &lt;p className="text-gray-500"&gt;Henüz eklenmiş bir görev yok.&lt;/p&gt;;
  }

  return (
    &lt;ul&gt;
      {tasks.map((task, index) =&gt; (
        &lt;li key={index} className={`p-4 border-b ${task.completed ? 'bg-green-100' : ''}`}&gt;
          &lt;h2 className="text-xl font-bold"&gt;{task.title}&lt;/h2&gt;
          &lt;p&gt;{task.description}&lt;/p&gt;
          &lt;button onClick={() =&gt; completeTask(index)} className="bg-green-500 text-white p-2 mr-2"&gt;
            {task.completed ? 'Tamamlandı' : 'Tamamla'}
          &lt;/button&gt;
          &lt;button onClick={() =&gt; deleteTask(index)} className="bg-red-500 text-white p-2"&gt;
            Sil
          &lt;/button&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};

export default TaskManager;
</code></pre>
<h3 id="3-stil-uygulama"><a class="header" href="#3-stil-uygulama">3. Stil Uygulama</a></h3>
<p>Tailwind CSS'i kullanarak bileşenlerinizi stilize edin. Örneğin:</p>
<pre><code class="language-javascript">&lt;div className="p-4"&gt;
  &lt;h1 className="text-2xl font-bold mb-4"&gt;Görev Yöneticisi&lt;/h1&gt;
  &lt;div className="mb-4"&gt;
    &lt;input 
      type="text" 
      placeholder="Görev Başlığı" 
      value={taskTitle}
      onChange={(e) =&gt; setTaskTitle(e.target.value)}
      className="border p-2 mr-2"
    /&gt;
    &lt;input 
      type="text" 
      placeholder="Görev Açıklaması" 
      value={taskDescription}
      onChange={(e) =&gt; setTaskDescription(e.target.value)}
      className="border p-2"
    /&gt;
    &lt;button onClick={addTask} className="bg-blue-500 text-white p-2 ml-2"&gt;Görev Ekle&lt;/button&gt;
  &lt;/div&gt;
  &lt;TaskList tasks={tasks} deleteTask={deleteTask} completeTask={completeTask} /&gt;
&lt;/div&gt;
</code></pre>
<h3 id="4-proje-dağıtımı"><a class="header" href="#4-proje-dağıtımı">4. Proje Dağıtımı</a></h3>
<p>Projenizi GitHub'a yükleyin ve bir canlı demo sağlayın. Aşağıdaki adımları izleyin:</p>
<ol>
<li>
<p>GitHub'da yeni bir depo oluşturun.</p>
</li>
<li>
<p>Projenizi bu depoya yükleyin:</p>
<pre><code class="language-bash">git init
git add .
git commit -m "İlk commit"
git remote add origin &lt;depo-url'si&gt;
git push -u origin master
</code></pre>
</li>
<li>
<p>Netlify veya GitHub Pages kullanarak canlı demoyu sağlayın.</p>
</li>
</ol>
<h3 id="sonuç-20"><a class="header" href="#sonuç-20">Sonuç</a></h3>
<p>Bu eğitim, React ve Tailwind CSS kullanarak bir Görev Yöneticisi uygulamasının nasıl geliştirileceğini kapsamaktadır. Bileşenlerin nasıl oluşturulacağını, durum yönetiminin nasıl yapılacağını ve koşullu render işlemlerinin nasıl uygulanacağını öğrendiniz. Ayrıca, uygulamanın stilini Tailwind CSS kullanarak nasıl oluşturabileceğinizi de gördünüz. Projeyi GitHub'da barındırarak ve bir canlı demo sağlayarak yazılım geliştirme standartlarına uygun bir şekilde tamamlamış oldunuz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ile-kontrollü-ve-kontrolsüz-bileşenler"><a class="header" href="#react-ile-kontrollü-ve-kontrolsüz-bileşenler">React ile Kontrollü ve Kontrolsüz Bileşenler</a></h1>
<h2 id="giriş-15"><a class="header" href="#giriş-15">Giriş</a></h2>
<p>React'te bileşenlerin yönetimi, kullanıcı etkileşimlerini ve durum değişikliklerini nasıl işlediğinizi önemli ölçüde etkiler. Bu eğitimde, kontrollü ve kontrolsüz bileşenlerin ne olduğunu, bunları nasıl kullanacağınızı ve hangi durumlarda hangisinin tercih edilmesi gerektiğini inceleyeceğiz. Tüm konuları detaylı ve titizlikle ele alarak, kod parçacıkları ile destekleyeceğiz.</p>
<h2 id="kontrollü-bileşenler"><a class="header" href="#kontrollü-bileşenler">Kontrollü Bileşenler</a></h2>
<h3 id="tanım"><a class="header" href="#tanım">Tanım</a></h3>
<p>Kontrollü bileşenlerde form verileri React tarafından yönetilir. Bileşenin durumu (state) formun değerini depolar ve bu değer, olay işleyicileri aracılığıyla güncellenir. Bileşen, güncellenen değerle yeniden render edilir ve form verileri üzerinde tam kontrol sağlanır.</p>
<h3 id="kullanım"><a class="header" href="#kullanım">Kullanım</a></h3>
<h4 id="temel-Örnek"><a class="header" href="#temel-Örnek">Temel Örnek</a></h4>
<pre><code class="language-jsx">import React, { useState } from 'react';

function ControlledComponent() {
  const [inputValue, setInputValue] = useState('');

  const handleChange = (event) =&gt; {
    setInputValue(event.target.value);
  };

  return (
    &lt;div&gt;
      &lt;label&gt;
        Controlled Input:
        &lt;input type="text" value={inputValue} onChange={handleChange} /&gt;
      &lt;/label&gt;
      &lt;p&gt;Current Value: {inputValue}&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default ControlledComponent;
</code></pre>
<h3 id="avantajlar"><a class="header" href="#avantajlar">Avantajlar</a></h3>
<ol>
<li><strong>Veri Kontrolü</strong>: Veriler tamamen React tarafından yönetilir, bu da veri akışını ve kontrolünü kolaylaştırır.</li>
<li><strong>Öngörülebilirlik</strong>: Bileşen her değişiklikte yeniden render edildiği için, uygulamanın durumu daha öngörülebilir olur.</li>
<li><strong>Kolay Doğrulama ve Formatlama</strong>: Kullanıcı girdileri üzerinde anında doğrulama ve formatlama yapabilirsiniz.</li>
</ol>
<h2 id="kontrolsüz-bileşenler"><a class="header" href="#kontrolsüz-bileşenler">Kontrolsüz Bileşenler</a></h2>
<h3 id="tanım-1"><a class="header" href="#tanım-1">Tanım</a></h3>
<p>Kontrolsüz bileşenlerde form verileri DOM tarafından yönetilir. Form girdisinin değeri doğrudan DOM'dan referanslar veya diğer yöntemler kullanılarak erişilir. React değeri kontrol etmez ve değişiklikler, yeniden render işlemi tetiklenmeden DOM tarafından işlenir.</p>
<h3 id="kullanım-1"><a class="header" href="#kullanım-1">Kullanım</a></h3>
<h4 id="temel-Örnek-1"><a class="header" href="#temel-Örnek-1">Temel Örnek</a></h4>
<pre><code class="language-jsx">import React, { useRef } from 'react';

function UncontrolledComponent() {
  const inputRef = useRef(null);

  const handleSubmit = (event) =&gt; {
    event.preventDefault();
    alert(`Uncontrolled Input Value: ${inputRef.current.value}`);
  };

  return (
    &lt;div&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;label&gt;
          Uncontrolled Input:
          &lt;input type="text" ref={inputRef} /&gt;
        &lt;/label&gt;
        &lt;button type="submit"&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}

export default UncontrolledComponent;
</code></pre>
<h3 id="avantajlar-1"><a class="header" href="#avantajlar-1">Avantajlar</a></h3>
<ol>
<li><strong>Basitlik</strong>: Daha az kod yazılması ve state yönetimi gerektirmemesi nedeniyle kullanımı daha basittir.</li>
<li><strong>Performans</strong>: Büyük formlar ve sık güncellemeler için daha performanslı olabilir, çünkü yeniden render işlemi tetiklenmez.</li>
</ol>
<h2 id="karşılaştırma-ve-kullanım-durumları"><a class="header" href="#karşılaştırma-ve-kullanım-durumları">Karşılaştırma ve Kullanım Durumları</a></h2>
<h3 id="kontrollü-bileşenler-ne-zaman-kullanılmalı"><a class="header" href="#kontrollü-bileşenler-ne-zaman-kullanılmalı">Kontrollü Bileşenler Ne Zaman Kullanılmalı?</a></h3>
<ul>
<li>Form verilerini sıkça güncellemek ve izlemek gerektiğinde.</li>
<li>Kullanıcı girdilerini doğrulamak veya anında geri bildirim sağlamak gerektiğinde.</li>
<li>Form verilerinin başka bileşenlerle paylaşılması veya global state'e eklenmesi gerektiğinde.</li>
</ul>
<h3 id="kontrolsüz-bileşenler-ne-zaman-kullanılmalı"><a class="header" href="#kontrolsüz-bileşenler-ne-zaman-kullanılmalı">Kontrolsüz Bileşenler Ne Zaman Kullanılmalı?</a></h3>
<ul>
<li>Basit formlar ve düşük öncelikli girişler için.</li>
<li>Performansın kritik olduğu durumlarda ve sık yeniden render işlemlerinin önlenmesi gerektiğinde.</li>
<li>Daha az karmaşıklık ve yönetim gerektiren projelerde.</li>
</ul>
<h2 id="kritik-değerlendirme-ve-hatalar"><a class="header" href="#kritik-değerlendirme-ve-hatalar">Kritik Değerlendirme ve Hatalar</a></h2>
<ul>
<li><strong>Kontrollü Bileşenler</strong>: Karmaşık formlarda, her giriş için state yönetimi ek kod ve karmaşıklık yaratabilir. Ancak, veri kontrolü ve doğrulama gerektiren durumlarda gereklidir.</li>
<li><strong>Kontrolsüz Bileşenler</strong>: Doğrulama ve kontrol eksikliği, kullanıcının beklenmedik girişler yapmasına neden olabilir. Bu durumlarda ek doğrulama adımları eklemek gerekebilir.</li>
</ul>
<h2 id="sonuç-21"><a class="header" href="#sonuç-21">Sonuç</a></h2>
<p>Kontrollü ve kontrolsüz bileşenler, React ile form yönetiminin temel taşlarını oluşturur. Hangi yöntemin kullanılacağını belirlerken, projenin gereksinimlerini ve performans ihtiyaçlarını dikkatle değerlendirmek gerekir. Bu eğitim, her iki yaklaşımı da derinlemesine ele alarak, yazılım geliştirme süreçlerinde bu bilgileri etkili bir şekilde kullanmanıza yardımcı olacaktır.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="durum-kullanarak-form-girdilerini-yönetmek"><a class="header" href="#durum-kullanarak-form-girdilerini-yönetmek">Durum Kullanarak Form Girdilerini Yönetmek</a></h1>
<p>Bu eğitimde, React bileşenleri içinde form girdilerini durum (state) kullanarak nasıl yöneteceğinizi ayrıntılı bir şekilde ele alacağız. Form elemanlarının değerlerini React bileşenleri tarafından yönetmek, form işlemlerinin daha kontrollü ve güvenilir olmasını sağlar. Bu yöntem, "Controlled Components" olarak bilinir ve HTML formlarının varsayılan davranışlarına güvenmek yerine, form elemanlarının değerlerini doğrudan bileşen durumunda yönetir.</p>
<h2 id="controlled-components-oluşturma-adımları"><a class="header" href="#controlled-components-oluşturma-adımları">Controlled Components Oluşturma Adımları</a></h2>
<p><strong>1. Bileşenler Klasörü Oluşturma:</strong>
<code>src</code> dizininde yeni bir <code>components</code> adlı klasör oluşturun. Bu klasör, bileşen dosyalarınızı düzenlemek için kullanılacaktır.</p>
<p><strong>2. Bileşen Dosyası Oluşturma:</strong>
<code>components</code> klasörü içinde <code>ControlledForm.jsx</code> adında yeni bir dosya oluşturun. Bu dosya, kontrol edilen bileşenimizi içerecektir.</p>
<p><strong>3. Gerekli Paketleri İçe Aktarma:</strong>
<code>ControlledForm.jsx</code> dosyasının içine <code>React</code> ve <code>useState</code> kancasını (hook) içe aktarın.</p>
<pre><code class="language-javascript">import React, { useState } from 'react';
</code></pre>
<p><strong>4. Durumu Başlatma:</strong>
Fonksiyonel bir bileşen oluşturun ve form elemanlarınız için durumu başlatmak üzere <code>useState</code> kancasını kullanın.</p>
<pre><code class="language-javascript">const ControlledForm = () =&gt; {
    const [inputValue, setInputValue] = useState('');
</code></pre>
<p><strong>5. Form Elemanlarını Render Etme:</strong>
Fonksiyonel bileşenin içinde, form elemanlarınızın JSX'ini döndürün.</p>
<pre><code class="language-javascript">    return (
        &lt;form&gt;
            &lt;label&gt;
                Input:
                &lt;input 
                    type="text" 
                    value={inputValue} 
                    onChange={(e) =&gt; setInputValue(e.target.value)} 
                /&gt;
            &lt;/label&gt;
        &lt;/form&gt;
    );
</code></pre>
<p><strong>6. Değer Özelliğini Duruma Bağlama:</strong>
Form elemanının <code>value</code> özelliğini, karşılık gelen durum değişkenine ayarlayın, böylece React, giriş değerini tam olarak kontrol eder.</p>
<pre><code class="language-javascript">                &lt;input 
                    type="text" 
                    value={inputValue} 
                    onChange={(e) =&gt; setInputValue(e.target.value)} 
                /&gt;
</code></pre>
<p><strong>7. Olay İşleyicilerini Ayarlama:</strong>
<code>onChange</code> olayı için bir olay işleyici fonksiyonu yazın, bu fonksiyon kullanıcı form elemanları ile etkileşime geçtiğinde çağrılacaktır.</p>
<pre><code class="language-javascript">                    onChange={(e) =&gt; setInputValue(e.target.value)} 
</code></pre>
<p><strong>8. Kullanıcı Etkileşiminde Durumu Güncelleme:</strong>
Olay işleyicinin içinde, yeni giriş değeri ile ilgili durum değişkenini güncelleyin.</p>
<pre><code class="language-javascript">                    onChange={(e) =&gt; setInputValue(e.target.value)} 
</code></pre>
<p><strong>9. Form Gönderimini Yönetme:</strong>
Form gönderim olayını yönetmek için bir <code>handleSubmit</code> fonksiyonu oluşturun.</p>
<pre><code class="language-javascript">    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        // form verilerini işleyin
    };
</code></pre>
<p><strong>10. Gönderimden Önce Veriyi Doğrulama veya Manipüle Etme:</strong>
<code>handleSubmit</code> fonksiyonunda, form verilerini göndermeden önce doğrulayabilir veya manipüle edebilirsiniz.</p>
<pre><code class="language-javascript">    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        // Veriyi doğrulayın veya manipüle edin
        console.log(inputValue);
    };
</code></pre>
<p><strong>11. Yan Etkileri Gerçekleştirme ve Bileşeni Dışa Aktarma:</strong>
Veriyi doğruladıktan veya manipüle ettikten sonra, API çağrıları gibi yan etkileri gerçekleştirebilirsiniz. Bileşeni uygulamanızın diğer bölümlerinde kullanmak üzere dışa aktarın.</p>
<pre><code class="language-javascript">    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        // Veriyi doğrulayın veya manipüle edin
        console.log(inputValue);
        // API çağrıları yapın
    };

    export default ControlledForm;
</code></pre>
<h1 id="tam-kod-Örneği"><a class="header" href="#tam-kod-Örneği">Tam Kod Örneği</a></h1>
<p>Aşağıda, yukarıda açıklanan adımları içeren tam kod örneğini bulabilirsiniz:</p>
<pre><code class="language-javascript">import React, { useState } from 'react';

const ControlledForm = () =&gt; {
    const [inputValue, setInputValue] = useState('');

    const handleChange = (e) =&gt; {
        setInputValue(e.target.value);
    };

    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        // Veriyi doğrulayın veya manipüle edin
        console.log(inputValue);
        // API çağrıları yapın
    };

    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;label&gt;
                Input:
                &lt;input 
                    type="text" 
                    value={inputValue} 
                    onChange={handleChange} 
                /&gt;
            &lt;/label&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    );
};

export default ControlledForm;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactte-olay-yönetimi-eğitimi"><a class="header" href="#reactte-olay-yönetimi-eğitimi">React'te Olay Yönetimi Eğitimi</a></h1>
<h2 id="1-olay-yönetim-söz-dizimi"><a class="header" href="#1-olay-yönetim-söz-dizimi">1. Olay Yönetim Söz Dizimi</a></h2>
<p>React bileşenlerinde olay yöneticileri (event handlers), kullanıcı etkileşimlerine (tıklamalar, tuş vuruşları, form gönderimleri vb.) yanıt vermenizi sağlar. Olay yöneticileri JSX elemanları üzerinde props olarak yazılır ve belirli bir söz dizimini takip eder. Genellikle bileşen içerisinde fonksiyonlar olarak tanımlanırlar.</p>
<h3 id="Örnek-kod-parçası-basit-bir-tıklama-olayı"><a class="header" href="#Örnek-kod-parçası-basit-bir-tıklama-olayı">Örnek Kod Parçası: Basit Bir Tıklama Olayı</a></h3>
<pre><code class="language-jsx">import React from 'react';

class ClickComponent extends React.Component {
  handleClick() {
    console.log('Button was clicked');
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}

export default ClickComponent;
</code></pre>
<h2 id="2-olay-yöneticilerini-bağlama"><a class="header" href="#2-olay-yöneticilerini-bağlama">2. Olay Yöneticilerini Bağlama</a></h2>
<p>Olay yöneticileri, özellikle <code>this</code> anahtar kelimesi fonksiyon içinde kullanıldığında, bileşen örneğine (instance) bağlanmalıdır. Olay yöneticilerini bağlamak için birden fazla yöntem vardır, örneğin <code>bind()</code> metodunu kullanarak veya ok fonksiyonları (arrow functions) kullanarak.</p>
<h3 id="Örnek-kod-parçası-bind-metodu-ile-bağlama"><a class="header" href="#Örnek-kod-parçası-bind-metodu-ile-bağlama">Örnek Kod Parçası: bind() Metodu ile Bağlama</a></h3>
<pre><code class="language-jsx">import React from 'react';

class ClickComponent extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    console.log('Button was clicked');
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}

export default ClickComponent;
</code></pre>
<h3 id="Örnek-kod-parçası-ok-fonksiyonları-ile-bağlama"><a class="header" href="#Örnek-kod-parçası-ok-fonksiyonları-ile-bağlama">Örnek Kod Parçası: Ok Fonksiyonları ile Bağlama</a></h3>
<pre><code class="language-jsx">import React from 'react';

class ClickComponent extends React.Component {
  handleClick = () =&gt; {
    console.log('Button was clicked');
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}

export default ClickComponent;
</code></pre>
<h2 id="3-olay-nesnesi"><a class="header" href="#3-olay-nesnesi">3. Olay Nesnesi</a></h2>
<p>Bir olay gerçekleştiğinde, React olay yöneticisi fonksiyonuna bir olay nesnesi (event object) sağlar. Bu olay nesnesi, olayla ilgili hedef eleman ve olay türü gibi yararlı bilgiler içerir.</p>
<h3 id="Örnek-kod-parçası-olay-nesnesinin-kullanımı"><a class="header" href="#Örnek-kod-parçası-olay-nesnesinin-kullanımı">Örnek Kod Parçası: Olay Nesnesinin Kullanımı</a></h3>
<pre><code class="language-jsx">import React from 'react';

class ClickComponent extends React.Component {
  handleClick(event) {
    console.log('Button was clicked');
    console.log(event.target); // Tıklanan elemanı döndürür
  }

  render() {
    return (
      &lt;button onClick={this.handleClick.bind(this)}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}

export default ClickComponent;
</code></pre>
<h2 id="4-varsayılan-davranışın-Önlenmesi"><a class="header" href="#4-varsayılan-davranışın-Önlenmesi">4. Varsayılan Davranışın Önlenmesi</a></h2>
<p>Bazı durumlarda, belirli olayların varsayılan davranışını önlemek isteyebilirsiniz, örneğin form gönderimleri veya link tıklamaları. Varsayılan davranışı önlemek için olay nesnesi üzerinde <code>preventDefault()</code> metodunu çağırabilirsiniz.</p>
<h3 id="Örnek-kod-parçası-form-gönderiminin-Önlenmesi"><a class="header" href="#Örnek-kod-parçası-form-gönderiminin-Önlenmesi">Örnek Kod Parçası: Form Gönderiminin Önlenmesi</a></h3>
<pre><code class="language-jsx">import React from 'react';

class FormComponent extends React.Component {
  handleSubmit(event) {
    event.preventDefault();
    console.log('Form was submitted');
  }

  render() {
    return (
      &lt;form onSubmit={this.handleSubmit.bind(this)}&gt;
        &lt;button type="submit"&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    );
  }
}

export default FormComponent;
</code></pre>
<h2 id="5-olay-yayılması"><a class="header" href="#5-olay-yayılması">5. Olay Yayılması</a></h2>
<p>React, olayların en üst seviyede işlendiği ve ardından belirli bileşene yayıldığı sentetik olay sistemini (synthetic event system) takip eder. Eğer olay yayılmasını durdurmanız gerekiyorsa (örneğin, olayın üst bileşenlere yayılmasını engellemek için), olay nesnesi üzerinde <code>stopPropagation()</code> metodunu çağırabilirsiniz.</p>
<h3 id="Örnek-kod-parçası-olay-yayılmasının-durdurulması"><a class="header" href="#Örnek-kod-parçası-olay-yayılmasının-durdurulması">Örnek Kod Parçası: Olay Yayılmasının Durdurulması</a></h3>
<pre><code class="language-jsx">import React from 'react';

class ClickComponent extends React.Component {
  handleClick(event) {
    event.stopPropagation();
    console.log('Button was clicked');
  }

  render() {
    return (
      &lt;div onClick={() =&gt; console.log('Div clicked')}&gt;
        &lt;button onClick={this.handleClick.bind(this)}&gt;
          Click me
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default ClickComponent;
</code></pre>
<p>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ile-etkinlik-yöneticilerine-argüman-geçirme-eğitimi"><a class="header" href="#react-ile-etkinlik-yöneticilerine-argüman-geçirme-eğitimi">React ile Etkinlik Yöneticilerine Argüman Geçirme Eğitimi</a></h1>
<p>Bu eğitimde, React'te etkinlik yöneticilerine nasıl argüman geçireceğinizi öğreneceksiniz. Bu, belirli bilgilere dayalı eylemleri gerçekleştirmek için faydalıdır ve etkinlik veya bileşenle ilgili belirli bilgileri işlemek gerektiğinde kullanılır. Eğitim boyunca, kod parçacıkları iyi yapılandırılmış ve titiz olacaktır.</p>
<h2 id="adım-1-bileşenler-İçin-yeni-bir-klasör-oluşturma"><a class="header" href="#adım-1-bileşenler-İçin-yeni-bir-klasör-oluşturma">Adım 1: Bileşenler İçin Yeni Bir Klasör Oluşturma</a></h2>
<p>Projenizin <code>src</code> dizini içinde, bileşenleriniz için <code>components</code> adlı yeni bir klasör oluşturun. Bu klasör, projenizin bileşenlerini düzenli ve yönetilebilir tutmak için kullanılacaktır.</p>
<pre><code class="language-sh">mkdir src/components
</code></pre>
<h2 id="adım-2-button-bileşeni-oluşturma"><a class="header" href="#adım-2-button-bileşeni-oluşturma">Adım 2: Button Bileşeni Oluşturma</a></h2>
<p><code>components</code> klasörü içinde, <code>ButtonWithArgs.jsx</code> adlı yeni bir JSX dosyası oluşturun ve basit bir fonksiyonel bileşen tanımlayın.</p>
<pre><code class="language-jsx">// src/components/ButtonWithArgs.jsx
import React from 'react';

const ButtonWithArgs = () =&gt; {
    return (
        &lt;button&gt;Click me&lt;/button&gt;
    );
};

export default ButtonWithArgs;
</code></pre>
<h2 id="adım-3-etkinlik-yöneticisi-fonksiyonu-oluşturma"><a class="header" href="#adım-3-etkinlik-yöneticisi-fonksiyonu-oluşturma">Adım 3: Etkinlik Yöneticisi Fonksiyonu Oluşturma</a></h2>
<p><code>ButtonWithArgs</code> bileşeni içinde, bir tıklama etkinliğini yönetecek ve bir argüman alacak bir fonksiyon tanımlayın.</p>
<pre><code class="language-jsx">// src/components/ButtonWithArgs.jsx
import React from 'react';

const ButtonWithArgs = () =&gt; {
    const handleClick = (message) =&gt; {
        alert(message);
    };

    return (
        &lt;button onClick={() =&gt; handleClick('Button clicked!')}&gt;Click me&lt;/button&gt;
    );
};

export default ButtonWithArgs;
</code></pre>
<h2 id="adım-4-etkinlik-yöneticisini-bir-argümanla-bir-elemana-bağlama"><a class="header" href="#adım-4-etkinlik-yöneticisini-bir-argümanla-bir-elemana-bağlama">Adım 4: Etkinlik Yöneticisini Bir Argümanla Bir Elemana Bağlama</a></h2>
<p>Bileşenin JSX kısmında, bir buton elementi oluşturun ve handleClick etkinlik yöneticisini bir argümanla bağlamak için bir ok fonksiyonu kullanın.</p>
<pre><code class="language-jsx">// src/components/ButtonWithArgs.jsx
import React from 'react';

const ButtonWithArgs = () =&gt; {
    const handleClick = (message) =&gt; {
        alert(message);
    };

    return (
        &lt;button onClick={() =&gt; handleClick('Button clicked!')}&gt;Click me&lt;/button&gt;
    );
};

export default ButtonWithArgs;
</code></pre>
<h2 id="adım-5-buttonwithargs-bileşenini-İçe-aktarma-ve-kullanma"><a class="header" href="#adım-5-buttonwithargs-bileşenini-İçe-aktarma-ve-kullanma">Adım 5: ButtonWithArgs Bileşenini İçe Aktarma ve Kullanma</a></h2>
<p>Parent bileşeninizde veya <code>App.jsx</code> dosyasında, <code>ButtonWithArgs</code> bileşenini içe aktarın ve JSX içinde kullanın.</p>
<pre><code class="language-jsx">// src/App.jsx
import React from 'react';
import ButtonWithArgs from './components/ButtonWithArgs';

const App = () =&gt; {
    return (
        &lt;div&gt;
            &lt;ButtonWithArgs /&gt;
        &lt;/div&gt;
    );
};

export default App;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-events-ve-kullanımı"><a class="header" href="#common-events-ve-kullanımı">Common Events ve Kullanımı</a></h1>
<h2 id="giriş-16"><a class="header" href="#giriş-16">Giriş</a></h2>
<p>React, tarayıcıların yerel olay sistemini saran sentetik bir olay sistemi sağlar. Bu, farklı tarayıcılarda uyumluluğu ve tutarlı bir arayüzü garanti eder. Bu eğitimde, React'te en yaygın kullanılan ve önemli olayları ele alacağız. Kod parçacıkları ve örneklerle, her olayın nasıl kullanılacağını ayrıntılı bir şekilde açıklayacağız.</p>
<h2 id="1-fare-mouse-olayları"><a class="header" href="#1-fare-mouse-olayları">1. Fare (Mouse) Olayları</a></h2>
<h3 id="onclick"><a class="header" href="#onclick">onClick</a></h3>
<p>Bir fare tıklaması gerçekleştiğinde tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function ClickExample() {
  const handleClick = () =&gt; {
    alert('Element clicked!');
  };

  return (
    &lt;button onClick={handleClick}&gt;
      Click me
    &lt;/button&gt;
  );
}

export default ClickExample;
</code></pre>
<h3 id="ondoubleclick"><a class="header" href="#ondoubleclick">onDoubleClick</a></h3>
<p>Bir fare çift tıklaması gerçekleştiğinde tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function DoubleClickExample() {
  const handleDoubleClick = () =&gt; {
    alert('Element double-clicked!');
  };

  return (
    &lt;button onDoubleClick={handleDoubleClick}&gt;
      Double Click me
    &lt;/button&gt;
  );
}

export default DoubleClickExample;
</code></pre>
<h3 id="onmouseenter-ve-onmouseleave"><a class="header" href="#onmouseenter-ve-onmouseleave">onMouseEnter ve onMouseLeave</a></h3>
<p>Fare imleci elementin üzerine geldiğinde ve ayrıldığında tetiklenir.</p>
<pre><code class="language-jsx">import React, { useState } from 'react';

function MouseEnterLeaveExample() {
  const [isHovered, setIsHovered] = useState(false);

  return (
    &lt;div 
      onMouseEnter={() =&gt; setIsHovered(true)} 
      onMouseLeave={() =&gt; setIsHovered(false)}
      style={{ backgroundColor: isHovered ? 'yellow' : 'white' }}
    &gt;
      Hover over me
    &lt;/div&gt;
  );
}

export default MouseEnterLeaveExample;
</code></pre>
<h3 id="onmousedown-ve-onmouseup"><a class="header" href="#onmousedown-ve-onmouseup">onMouseDown ve onMouseUp</a></h3>
<p>Fare butonu basıldığında ve bırakıldığında tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function MouseDownUpExample() {
  const handleMouseDown = () =&gt; {
    console.log('Mouse button pressed down');
  };

  const handleMouseUp = () =&gt; {
    console.log('Mouse button released');
  };

  return (
    &lt;button onMouseDown={handleMouseDown} onMouseUp={handleMouseUp}&gt;
      Press and Release
    &lt;/button&gt;
  );
}

export default MouseDownUpExample;
</code></pre>
<h2 id="2-klavye-keyboard-olayları"><a class="header" href="#2-klavye-keyboard-olayları">2. Klavye (Keyboard) Olayları</a></h2>
<h3 id="onkeydown"><a class="header" href="#onkeydown">onKeyDown</a></h3>
<p>Bir tuşa basıldığında tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function KeyDownExample() {
  const handleKeyDown = (event) =&gt; {
    console.log(`Key pressed: ${event.key}`);
  };

  return (
    &lt;input type="text" onKeyDown={handleKeyDown} /&gt;
  );
}

export default KeyDownExample;
</code></pre>
<h3 id="onkeypress"><a class="header" href="#onkeypress">onKeyPress</a></h3>
<p>Bir tuşa basılıp bırakıldığında tetiklenir. Özellikle harfler ve sayılar için kullanışlıdır.</p>
<pre><code class="language-jsx">import React from 'react';

function KeyPressExample() {
  const handleKeyPress = (event) =&gt; {
    console.log(`Key pressed: ${event.key}`);
  };

  return (
    &lt;input type="text" onKeyPress={handleKeyPress} /&gt;
  );
}

export default KeyPressExample;
</code></pre>
<h3 id="onkeyup"><a class="header" href="#onkeyup">onKeyUp</a></h3>
<p>Bir tuş bırakıldığında tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function KeyUpExample() {
  const handleKeyUp = (event) =&gt; {
    console.log(`Key released: ${event.key}`);
  };

  return (
    &lt;input type="text" onKeyUp={handleKeyUp} /&gt;
  );
}

export default KeyUpExample;
</code></pre>
<h2 id="3-form-olayları"><a class="header" href="#3-form-olayları">3. Form Olayları</a></h2>
<h3 id="onchange"><a class="header" href="#onchange">onChange</a></h3>
<p>Bir input, select veya textarea değeri değiştiğinde tetiklenir.</p>
<pre><code class="language-jsx">import React, { useState } from 'react';

function ChangeExample() {
  const [value, setValue] = useState('');

  const handleChange = (event) =&gt; {
    setValue(event.target.value);
  };

  return (
    &lt;input type="text" value={value} onChange={handleChange} /&gt;
  );
}

export default ChangeExample;
</code></pre>
<h3 id="onsubmit"><a class="header" href="#onsubmit">onSubmit</a></h3>
<p>Bir form gönderildiğinde tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function SubmitExample() {
  const handleSubmit = (event) =&gt; {
    event.preventDefault();
    alert('Form submitted!');
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}

export default SubmitExample;
</code></pre>
<h3 id="onfocus-ve-onblur"><a class="header" href="#onfocus-ve-onblur">onFocus ve onBlur</a></h3>
<p>Bir element odaklandığında ve odağını kaybettiğinde tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function FocusBlurExample() {
  const handleFocus = () =&gt; {
    console.log('Input focused');
  };

  const handleBlur = () =&gt; {
    console.log('Input blurred');
  };

  return (
    &lt;input type="text" onFocus={handleFocus} onBlur={handleBlur} /&gt;
  );
}

export default FocusBlurExample;
</code></pre>
<h2 id="4-dokunma-touch-olayları"><a class="header" href="#4-dokunma-touch-olayları">4. Dokunma (Touch) Olayları</a></h2>
<h3 id="ontouchstart-ontouchmove-ve-ontouchend"><a class="header" href="#ontouchstart-ontouchmove-ve-ontouchend">onTouchStart, onTouchMove ve onTouchEnd</a></h3>
<p>Dokunma noktası yerleştirildiğinde, hareket ettiğinde ve kaldırıldığında tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function TouchExample() {
  const handleTouchStart = () =&gt; {
    console.log('Touch started');
  };

  const handleTouchMove = () =&gt; {
    console.log('Touch moved');
  };

  const handleTouchEnd = () =&gt; {
    console.log('Touch ended');
  };

  return (
    &lt;div 
      onTouchStart={handleTouchStart} 
      onTouchMove={handleTouchMove} 
      onTouchEnd={handleTouchEnd}
      style={{ width: '200px', height: '200px', backgroundColor: 'lightblue' }}
    &gt;
      Touch me
    &lt;/div&gt;
  );
}

export default TouchExample;
</code></pre>
<h2 id="5-ui-olayları"><a class="header" href="#5-ui-olayları">5. UI Olayları</a></h2>
<h3 id="onscroll"><a class="header" href="#onscroll">onScroll</a></h3>
<p>Bir elementin kaydırma çubuğu kaydırıldığında tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function ScrollExample() {
  const handleScroll = (event) =&gt; {
    console.log('Element scrolled', event.target.scrollTop);
  };

  return (
    &lt;div 
      onScroll={handleScroll} 
      style={{ overflowY: 'scroll', height: '100px' }}
    &gt;
      &lt;div style={{ height: '300px' }}&gt;
        Scroll me
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default ScrollExample;
</code></pre>
<h2 id="6-sürükleme-drag-olayları"><a class="header" href="#6-sürükleme-drag-olayları">6. Sürükleme (Drag) Olayları</a></h2>
<h3 id="ondrag-ondragend-ve-ondrop"><a class="header" href="#ondrag-ondragend-ve-ondrop">onDrag, onDragEnd ve onDrop</a></h3>
<p>Bir element sürüklendiğinde, sürükleme işlemi tamamlandığında ve bir hedefe bırakıldığında tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function DragDropExample() {
  const handleDrag = () =&gt; {
    console.log('Element being dragged');
  };

  const handleDragEnd = () =&gt; {
    console.log('Drag operation ended');
  };

  const handleDrop = (event) =&gt; {
    event.preventDefault();
    console.log('Element dropped');
  };

  const handleDragOver = (event) =&gt; {
    event.preventDefault();
  };

  return (
    &lt;div 
      draggable 
      onDrag={handleDrag} 
      onDragEnd={handleDragEnd}
      style={{ width: '100px', height: '100px', backgroundColor: 'coral', margin: '20px' }}
    &gt;
      Drag me
    &lt;/div&gt;
    &lt;div 
      onDrop={handleDrop} 
      onDragOver={handleDragOver}
      style={{ width: '200px', height: '200px', backgroundColor: 'lightgray', margin: '20px' }}
    &gt;
      Drop here
    &lt;/div&gt;
  );
}

export default DragDropExample;
</code></pre>
<h2 id="7-pano-clipboard-olayları"><a class="header" href="#7-pano-clipboard-olayları">7. Pano (Clipboard) Olayları</a></h2>
<h3 id="oncopy-oncut-ve-onpaste"><a class="header" href="#oncopy-oncut-ve-onpaste">onCopy, onCut ve onPaste</a></h3>
<p>Bir içerik bir elementten kopyalandığında, kesildiğinde ve yapıştırıldığında tetiklenir.</p>
<pre><code class="language-jsx">import React from 'react';

function ClipboardExample() {
  const handleCopy = () =&gt; {
    console.log('Content copied');
  };

  const handleCut = () =&gt; {
    console.log('Content cut');
  };

  const handlePaste = () =&gt; {
    console.log('Content pasted');
  };

  return (
    &lt;div 
      contentEditable 
      onCopy={handleCopy} 
      onCut={handleCut} 
      onPaste={handlePaste}
      style={{ border: '1px solid black', padding: '10px' }}
    &gt;
      Copy, Cut, or Paste here
    &lt;/div&gt;
  );
}

export default ClipboardExample;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-form-wizard"><a class="header" href="#react-form-wizard">React Form Wizard</a></h1>
<h2 id="giriş-17"><a class="header" href="#giriş-17">Giriş</a></h2>
<p>Bu eğitimde, React kullanarak bir form sihirbazı oluşturma sürecini ele alacağız. Form sihirbazı, kullanıcıların adım adım bilgi girmesine olanak tanır ve her adımda farklı türde giriş alanları içerir. Formun tamamlanmasının ardından, kullanıcıyı doldurulan verilerin gösterildiği bir profil sayfasına yönlendireceğiz. Bu proje, Tailwind CSS kullanılarak görsel olarak da çekici hale getirilecektir.</p>
<h2 id="gereksinimler-8"><a class="header" href="#gereksinimler-8">Gereksinimler</a></h2>
<ol>
<li><strong>React fonksiyonel bileşenlerini kullanarak çok adımlı bir form sihirbazı oluşturun.</strong></li>
<li><strong>Her form adımı/sekmesi için ayrı bileşenler oluşturun.</strong></li>
<li><strong>Aşağıdaki giriş alanlarını ekleyin:</strong>
<ul>
<li>Metin kutuları (ad, e-posta ve diğer ilgili bilgiler için)</li>
<li>Şifre alanı (şifre oluşturmak için)</li>
<li>Seçim kutusu (ülke veya bölge seçimi için)</li>
<li>Açılır menü (ilgi alanları veya kategoriler için)</li>
<li>Metin alanı (ek yorumlar veya açıklamalar için)</li>
<li>Dosya yükleme (profil resmi yüklemek için)</li>
</ul>
</li>
<li><strong>Form girişlerini doğrulayın ve gerekli alanların doldurulmasını sağlayın.</strong></li>
<li><strong>Form ve profil sayfasını Tailwind CSS kullanarak stilize edin.</strong></li>
<li><strong>Form gönderimini işleyin ve girilen verileri saklayın.</strong></li>
<li><strong>Form gönderildikten sonra kullanıcıyı doldurulan verilerin gösterildiği bir profil sayfasına yönlendirin.</strong></li>
</ol>
<h2 id="kurulum-ve-projeye-başlama"><a class="header" href="#kurulum-ve-projeye-başlama">Kurulum ve Projeye Başlama</a></h2>
<p>Proje oluşturma ve Tailwind CSS'in eklenmesi için aşağıdaki adımları takip edin.</p>
<h3 id="1-react-projesinin-oluşturulması"><a class="header" href="#1-react-projesinin-oluşturulması">1. React Projesinin Oluşturulması</a></h3>
<pre><code class="language-bash">npx create-react-app form-wizard
cd form-wizard
</code></pre>
<h3 id="2-tailwind-cssin-eklenmesi"><a class="header" href="#2-tailwind-cssin-eklenmesi">2. Tailwind CSS'in Eklenmesi</a></h3>
<p>Tailwind CSS'i projeye eklemek için gerekli paketleri yükleyin.</p>
<pre><code class="language-bash">npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init
</code></pre>
<p>Tailwind CSS'i yapılandırın (<code>tailwind.config.js</code>):</p>
<pre><code class="language-javascript">module.exports = {
  purge: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
};
</code></pre>
<p><code>src/index.css</code> dosyasını şu şekilde güncelleyin:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h2 id="Çok-adımlı-form-sihirbazı-bileşenlerinin-oluşturulması"><a class="header" href="#Çok-adımlı-form-sihirbazı-bileşenlerinin-oluşturulması">Çok Adımlı Form Sihirbazı Bileşenlerinin Oluşturulması</a></h2>
<h3 id="1-form-sihirbazı-ana-bileşeni"><a class="header" href="#1-form-sihirbazı-ana-bileşeni">1. Form Sihirbazı Ana Bileşeni</a></h3>
<p><code>src/components/FormWizard.js</code> dosyasını oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-javascript">import React, { useState } from 'react';
import StepOne from './StepOne';
import StepTwo from './StepTwo';
import StepThree from './StepThree';

const FormWizard = () =&gt; {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    country: '',
    interests: '',
    comments: '',
    profileImage: null,
  });

  const nextStep = () =&gt; setStep(step + 1);
  const prevStep = () =&gt; setStep(step - 1);

  const handleChange = (input) =&gt; (e) =&gt; {
    setFormData({ ...formData, [input]: e.target.value });
  };

  const handleFileChange = (e) =&gt; {
    setFormData({ ...formData, profileImage: e.target.files[0] });
  };

  switch (step) {
    case 1:
      return &lt;StepOne nextStep={nextStep} handleChange={handleChange} values={formData} /&gt;;
    case 2:
      return &lt;StepTwo nextStep={nextStep} prevStep={prevStep} handleChange={handleChange} values={formData} /&gt;;
    case 3:
      return &lt;StepThree prevStep={prevStep} handleChange={handleChange} handleFileChange={handleFileChange} values={formData} /&gt;;
    default:
      return &lt;div&gt;Form is submitted&lt;/div&gt;;
  }
};

export default FormWizard;
</code></pre>
<h3 id="2-form-adımı-bileşenleri"><a class="header" href="#2-form-adımı-bileşenleri">2. Form Adımı Bileşenleri</a></h3>
<p><strong>Adım 1: Kişisel Bilgiler</strong></p>
<p><code>src/components/StepOne.js</code> dosyasını oluşturun:</p>
<pre><code class="language-javascript">import React from 'react';

const StepOne = ({ nextStep, handleChange, values }) =&gt; {
  return (
    &lt;div className="p-4"&gt;
      &lt;h2 className="text-2xl mb-4"&gt;Kişisel Bilgiler&lt;/h2&gt;
      &lt;input
        type="text"
        name="name"
        value={values.name}
        onChange={handleChange('name')}
        placeholder="Adınız"
        className="mb-4 p-2 border border-gray-300"
      /&gt;
      &lt;input
        type="email"
        name="email"
        value={values.email}
        onChange={handleChange('email')}
        placeholder="E-posta"
        className="mb-4 p-2 border border-gray-300"
      /&gt;
      &lt;button onClick={nextStep} className="px-4 py-2 bg-blue-500 text-white"&gt;
        İleri
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default StepOne;
</code></pre>
<p><strong>Adım 2: Şifre ve Seçimler</strong></p>
<p><code>src/components/StepTwo.js</code> dosyasını oluşturun:</p>
<pre><code class="language-javascript">import React from 'react';

const StepTwo = ({ nextStep, prevStep, handleChange, values }) =&gt; {
  return (
    &lt;div className="p-4"&gt;
      &lt;h2 className="text-2xl mb-4"&gt;Şifre ve Seçimler&lt;/h2&gt;
      &lt;input
        type="password"
        name="password"
        value={values.password}
        onChange={handleChange('password')}
        placeholder="Şifre"
        className="mb-4 p-2 border border-gray-300"
      /&gt;
      &lt;select
        name="country"
        value={values.country}
        onChange={handleChange('country')}
        className="mb-4 p-2 border border-gray-300"
      &gt;
        &lt;option value=""&gt;Ülke Seçin&lt;/option&gt;
        &lt;option value="tr"&gt;Türkiye&lt;/option&gt;
        &lt;option value="us"&gt;Amerika&lt;/option&gt;
      &lt;/select&gt;
      &lt;button onClick={prevStep} className="px-4 py-2 bg-gray-500 text-white mr-2"&gt;
        Geri
      &lt;/button&gt;
      &lt;button onClick={nextStep} className="px-4 py-2 bg-blue-500 text-white"&gt;
        İleri
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default StepTwo;
</code></pre>
<p><strong>Adım 3: Ek Bilgiler ve Dosya Yükleme</strong></p>
<p><code>src/components/StepThree.js</code> dosyasını oluşturun:</p>
<pre><code class="language-javascript">import React from 'react';

const StepThree = ({ prevStep, handleChange, handleFileChange, values }) =&gt; {
  return (
    &lt;div className="p-4"&gt;
      &lt;h2 className="text-2xl mb-4"&gt;Ek Bilgiler ve Dosya Yükleme&lt;/h2&gt;
      &lt;textarea
        name="comments"
        value={values.comments}
        onChange={handleChange('comments')}
        placeholder="Yorumlar"
        className="mb-4 p-2 border border-gray-300"
      /&gt;
      &lt;input
        type="file"
        name="profileImage"
        onChange={handleFileChange}
        className="mb-4 p-2 border border-gray-300"
      /&gt;
      &lt;button onClick={prevStep} className="px-4 py-2 bg-gray-500 text-white mr-2"&gt;
        Geri
      &lt;/button&gt;
      &lt;button type="submit" className="px-4 py-2 bg-blue-500 text-white"&gt;
        Gönder
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default StepThree;
</code></pre>
<h2 id="form-verilerinin-gösterildiği-profil-sayfası"><a class="header" href="#form-verilerinin-gösterildiği-profil-sayfası">Form Verilerinin Gösterildiği Profil Sayfası</a></h2>
<p>Kullanıcının doldurduğu bilgileri göstermek için <code>ProfilePage</code> bileşenini oluşturun:</p>
<p><code>src/components/ProfilePage.js</code> dosyasını oluşturun:</p>
<pre><code class="language-javascript">import React from 'react';

const ProfilePage = ({ data }) =&gt; {
  return (
    &lt;div className="p-4"&gt;
      &lt;h2 className="text-2xl mb-4"&gt;Profil Sayfası&lt;/h2&gt;
      &lt;p&gt;&lt;strong&gt;Ad:&lt;/strong&gt; {data.name}&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;E-posta:&lt;/strong&gt; {data.email}&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;Ülke:&lt;/strong&gt; {data.country}&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;Yorumlar:&lt;/strong&gt; {data.comments}&lt;/p&gt;
      {data.profileImage &amp;&amp; (
        &lt;div&gt;
          &lt;strong&gt;Profil Resmi:&lt;/strong&gt;
          &lt;img src={URL.createObjectURL(data.profileImage)} alt="Profile" className="mt-4" /&gt;
        &lt;/div&gt;
      )}
    &lt;/

div&gt;
  );
};

export default ProfilePage;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routing-in-react"><a class="header" href="#routing-in-react">Routing in React</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-router"><a class="header" href="#react-router">React Router</a></h1>
<h2 id="giriş-18"><a class="header" href="#giriş-18">Giriş</a></h2>
<p>React Router, React uygulamalarında istemci tarafı yönlendirme (routing) için kullanılan popüler bir kütüphanedir. URL'ye dayalı olarak bileşenlerin gezinme ve render edilmesini yönetmek için güçlü ve esnek bir yol sağlar.</p>
<h2 id="1-react-router-nedir"><a class="header" href="#1-react-router-nedir">1. React Router Nedir?</a></h2>
<p>React Router, React ekosisteminde önemli bir yer tutar ve SPA (Single Page Application) yapılarında URL yönetimini kolaylaştırır. Bu kütüphane, kullanıcıların uygulama içinde farklı URL'ler arasında geçiş yaparken sayfanın yeniden yüklenmesini gerektirmeden farklı bileşenlerin render edilmesini sağlar.</p>
<h2 id="11-temel-kavramlar"><a class="header" href="#11-temel-kavramlar">1.1 Temel Kavramlar</a></h2>
<ul>
<li><strong>Router</strong>: Uygulamanın yönlendirme mantığını kapsayan bileşen.</li>
<li><strong>Route</strong>: URL ile eşleşen bileşeni belirleyen yapı.</li>
<li><strong>Link</strong>: Kullanıcıları farklı rotalara yönlendirmek için kullanılan bileşen.</li>
</ul>
<h2 id="2-react-router-kurulumu"><a class="header" href="#2-react-router-kurulumu">2. React Router Kurulumu</a></h2>
<p>React Router'ı kullanmaya başlamak için ilk adım, gerekli paketlerin projeye dahil edilmesidir. Aşağıdaki komut ile React Router paketini yükleyebilirsiniz:</p>
<pre><code class="language-bash">npm install react-router-dom
</code></pre>
<h2 id="3-temel-kullanım"><a class="header" href="#3-temel-kullanım">3. Temel Kullanım</a></h2>
<p>React Router'ın temel bileşenleri ve kullanımı aşağıda açıklanmıştır.</p>
<h2 id="31-router-bileşeni"><a class="header" href="#31-router-bileşeni">3.1 Router Bileşeni</a></h2>
<p><code>Router</code> bileşeni, uygulamanın tamamını sarmalar ve yönlendirme işlemlerini yönetir. Genellikle <code>BrowserRouter</code> veya <code>HashRouter</code> bileşenleri kullanılır.</p>
<pre><code class="language-jsx">import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';

function App() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;Navigation /&gt;
        &lt;Switch&gt;
          &lt;Route path="/" exact component={Home} /&gt;
          &lt;Route path="/about" component={About} /&gt;
          &lt;Route path="/contact" component={Contact} /&gt;
        &lt;/Switch&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  );
}
</code></pre>
<h2 id="32-route-bileşeni"><a class="header" href="#32-route-bileşeni">3.2 Route Bileşeni</a></h2>
<p><code>Route</code> bileşeni, belirli bir URL ile eşleştiğinde render edilecek bileşeni belirler. <code>path</code> prop'u, URL yolunu belirtir, <code>component</code> prop'u ise render edilecek bileşeni belirler.</p>
<pre><code class="language-jsx">&lt;Route path="/example" component={ExampleComponent} /&gt;
</code></pre>
<h2 id="33-link-bileşeni"><a class="header" href="#33-link-bileşeni">3.3 Link Bileşeni</a></h2>
<p><code>Link</code> bileşeni, kullanıcıların uygulama içinde farklı rotalara yönlendirilmesini sağlar. <code>to</code> prop'u, yönlendirilecek URL'yi belirtir.</p>
<pre><code class="language-jsx">import { Link } from 'react-router-dom';

function Navigation() {
  return (
    &lt;nav&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to="/"&gt;Home&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to="/about"&gt;About&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to="/contact"&gt;Contact&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/nav&gt;
  );
}
</code></pre>
<h2 id="4-gelişmiş-kullanım"><a class="header" href="#4-gelişmiş-kullanım">4. Gelişmiş Kullanım</a></h2>
<p>React Router, daha karmaşık yönlendirme ihtiyaçlarını karşılamak için çeşitli ek özellikler sunar.</p>
<h2 id="41-dinamik-rotalar"><a class="header" href="#41-dinamik-rotalar">4.1 Dinamik Rotalar</a></h2>
<p>URL parametreleri ile çalışan dinamik rotalar oluşturabilirsiniz. Bu, URL'deki belirli segmentlere bağlı olarak farklı bileşenlerin render edilmesini sağlar.</p>
<pre><code class="language-jsx">&lt;Route path="/user/:id" component={UserProfile} /&gt;
</code></pre>
<p>Bileşen içinde <code>useParams</code> hook'u ile URL parametrelerine erişilebilir.</p>
<pre><code class="language-jsx">import { useParams } from 'react-router-dom';

function UserProfile() {
  let { id } = useParams();
  return &lt;div&gt;User ID: {id}&lt;/div&gt;;
}
</code></pre>
<h2 id="42-redirect-bileşeni"><a class="header" href="#42-redirect-bileşeni">4.2 Redirect Bileşeni</a></h2>
<p><code>Redirect</code> bileşeni, kullanıcıları belirli bir rotadan başka bir rotaya yönlendirmek için kullanılır.</p>
<pre><code class="language-jsx">import { Redirect } from 'react-router-dom';

function App() {
  return (
    &lt;Router&gt;
      &lt;Switch&gt;
        &lt;Route path="/old-path" exact&gt;
          &lt;Redirect to="/new-path" /&gt;
        &lt;/Route&gt;
        &lt;Route path="/new-path" component={NewComponent} /&gt;
      &lt;/Switch&gt;
    &lt;/Router&gt;
  );
}
</code></pre>
<h2 id="5-performans-ve-optimizasyon"><a class="header" href="#5-performans-ve-optimizasyon">5. Performans ve Optimizasyon</a></h2>
<p>Büyük ve karmaşık uygulamalarda performansı artırmak için React Router'ın çeşitli optimizasyon teknikleri kullanılabilir.</p>
<h2 id="51-lazy-loading"><a class="header" href="#51-lazy-loading">5.1 Lazy Loading</a></h2>
<p>React Router ile bileşenleri dinamik olarak yüklemek için <code>React.lazy</code> ve <code>Suspense</code> kullanılır.</p>
<pre><code class="language-jsx">import React, { lazy, Suspense } from 'react';

const Home = lazy(() =&gt; import('./Home'));
const About = lazy(() =&gt; import('./About'));

function App() {
  return (
    &lt;Router&gt;
      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;Switch&gt;
          &lt;Route path="/" exact component={Home} /&gt;
          &lt;Route path="/about" component={About} /&gt;
        &lt;/Switch&gt;
      &lt;/Suspense&gt;
    &lt;/Router&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<h2 id="giriş-19"><a class="header" href="#giriş-19">Giriş</a></h2>
<p>React, kullanıcı arayüzleri oluşturmak için kullanılan popüler bir JavaScript kütüphanesidir. React, bileşen (component) tabanlı yapısıyla, yeniden kullanılabilir ve yönetilebilir kodlar yazmayı kolaylaştırır. Bu eğitimde, React ve React Router'ın kurulum ve kullanım süreçlerini ayrıntılı bir şekilde ele alacağız.</p>
<h2 id="kurulum-1"><a class="header" href="#kurulum-1">Kurulum</a></h2>
<h3 id="react-kurulumu-1"><a class="header" href="#react-kurulumu-1">React Kurulumu</a></h3>
<p>Öncelikle, React kütüphanesini kurmamız gerekmektedir. Bunun için npm (Node Package Manager) veya yarn kullanabilirsiniz. Aşağıdaki komutu terminalde çalıştırarak React ve React DOM paketlerini kurabilirsiniz:</p>
<pre><code class="language-bash">npx create-react-app my-app
cd my-app
</code></pre>
<p>Yukarıdaki komut, <code>create-react-app</code> aracıyla yeni bir React projesi oluşturur ve gerekli bağımlılıkları yükler.</p>
<h3 id="react-router-kurulumu"><a class="header" href="#react-router-kurulumu">React Router Kurulumu</a></h3>
<p>React Router, React uygulamaları için yönlendirme (routing) sağlar. React Router'ı kurmak için npm veya yarn kullanabilirsiniz. Aşağıdaki komutu terminalde çalıştırarak React Router paketini kurabilirsiniz:</p>
<pre><code class="language-bash">npm install react-router-dom
</code></pre>
<p>Yarn kullanıyorsanız, şu komutu çalıştırabilirsiniz:</p>
<pre><code class="language-bash">yarn add react-router-dom
</code></pre>
<p>React Router kurulumunun ardından, yönlendirme yapılandırmasına geçebiliriz.</p>
<h2 id="react-router-yapılandırması"><a class="header" href="#react-router-yapılandırması">React Router Yapılandırması</a></h2>
<p>React Router'ı kullanarak basit bir yönlendirme yapılandırması oluşturacağız. İlk olarak, <code>index.js</code> dosyanızda <code>BrowserRouter</code> bileşenini ekleyin:</p>
<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter } from 'react-router-dom';
import App from './App';

ReactDOM.render(
  &lt;BrowserRouter&gt;
    &lt;App /&gt;
  &lt;/BrowserRouter&gt;,
  document.getElementById('root')
);
</code></pre>
<h3 id="yönlendirme-tanımları"><a class="header" href="#yönlendirme-tanımları">Yönlendirme Tanımları</a></h3>
<p><code>App.js</code> dosyasında yönlendirme yapılandırmasını tanımlayalım:</p>
<pre><code class="language-javascript">import React from 'react';
import { Routes, Route } from 'react-router-dom';
import Home from './components/Home';
import About from './components/About';

function App() {
  return (
    &lt;Routes&gt;
      &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
      &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
    &lt;/Routes&gt;
  );
}

export default App;
</code></pre>
<p>Bu yapılandırmada, <code>/</code> yoluna gidildiğinde <code>Home</code> bileşeni, <code>/about</code> yoluna gidildiğinde ise <code>About</code> bileşeni render edilecektir.</p>
<h3 id="bileşenlerin-oluşturulması-1"><a class="header" href="#bileşenlerin-oluşturulması-1">Bileşenlerin Oluşturulması</a></h3>
<p><code>Home</code> ve <code>About</code> bileşenlerini oluşturalım. <code>src/components</code> dizini altında <code>Home.js</code> ve <code>About.js</code> dosyalarını oluşturun.</p>
<p><code>Home.js</code> dosyasının içeriği:</p>
<pre><code class="language-javascript">import React from 'react';

function Home() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Home Page&lt;/h1&gt;
      &lt;p&gt;Welcome to the Home Page!&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default Home;
</code></pre>
<p><code>About.js</code> dosyasının içeriği:</p>
<pre><code class="language-javascript">import React from 'react';

function About() {
  return (
    &lt;div&gt;
      &lt;h1&gt;About Page&lt;/h1&gt;
      &lt;p&gt;Learn more about us on this page.&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default About;
</code></pre>
<p>Bu bileşenler basit içeriklerle oluşturulmuştur ve ilgili rotalar çağrıldığında görüntülenecektir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-router-1"><a class="header" href="#react-router-1">React Router</a></h1>
<p>Bu eğitimde, React Router'ın temel kavramlarını ve kullanımını kapsamlı bir şekilde ele alacağız. Amacımız, React uygulamalarında istemci taraflı yönlendirme (client-side routing) sağlamak için <code>react-router-dom</code> kütüphanesini kullanarak profesyonel bir yapı oluşturmaktır.</p>
<h2 id="1-react-router-nedir-1"><a class="header" href="#1-react-router-nedir-1">1. React Router Nedir?</a></h2>
<p><code>react-router-dom</code>, React uygulamalarında istemci taraflı yönlendirme sağlamak için kullanılan popüler bir yönlendirme kütüphanesidir. Bu kütüphane, tek sayfa uygulamalarda (SPA) farklı URL'lere sahip bileşenleri yüklemek için kullanılır.</p>
<h2 id="2-gerekli-kurulumlar-ve-başlangıç"><a class="header" href="#2-gerekli-kurulumlar-ve-başlangıç">2. Gerekli Kurulumlar ve Başlangıç</a></h2>
<p>React Router'ı kullanmaya başlamak için öncelikle gerekli kütüphaneyi projemize dahil etmemiz gerekiyor.</p>
<pre><code class="language-bash">npm install react-router-dom
</code></pre>
<p>Kurulum tamamlandıktan sonra, React Router bileşenlerini kullanarak bir yönlendirme sistemi oluşturabiliriz.</p>
<h2 id="3-temel-bileşenler-ve-kullanımları"><a class="header" href="#3-temel-bileşenler-ve-kullanımları">3. Temel Bileşenler ve Kullanımları</a></h2>
<h3 id="browserrouter"><a class="header" href="#browserrouter">BrowserRouter</a></h3>
<p><code>BrowserRouter</code>, HTML5 tarihçesi API'sını (<code>pushState</code>, <code>replaceState</code>, ve <code>popstate</code> olayı) kullanarak URL ile kullanıcı arayüzünüzü senkronize eden bir router implementasyonudur. Tüm route tanımlarınızı sararak temel yönlendirme yeteneklerini sağlar.</p>
<pre><code class="language-jsx">import { BrowserRouter } from 'react-router-dom';

function App() {
  return (
    &lt;BrowserRouter&gt;
      {/* Route tanımları burada olacak */}
    &lt;/BrowserRouter&gt;
  );
}
</code></pre>
<h3 id="routes"><a class="header" href="#routes">Routes</a></h3>
<p><code>Routes</code> bileşeni, birden fazla <code>Route</code> bileşeni için bir sarmalayıcıdır. Konumla eşleşen ilk <code>Route</code> çocuğunu render eder. Bu bileşen, hangi bileşen veya elemanların tanımlanan route'lara göre görüntüleneceğine karar verme sürecinde yardımcı olur.</p>
<pre><code class="language-jsx">import { Routes, Route } from 'react-router-dom';

function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
        &lt;Route path="/contact" element={&lt;Contact /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
}
</code></pre>
<h3 id="route"><a class="header" href="#route">Route</a></h3>
<p><code>Route</code> bileşeni, yolları mevcut URL ile eşleştiğinde UI bileşenlerini render etmekten sorumludur. Bir <code>path</code> özelliği alır ve bu özellik, route'un eşleşeceği yolu tanımlar (örneğin, <code>/</code>, <code>/about</code>, <code>/contact</code>). Ayrıca bir <code>element</code> özelliği alır ve bu özellik aktif olduğunda render edilecek React elemanıdır.</p>
<pre><code class="language-jsx">function Home() {
  return &lt;h1&gt;Home Page&lt;/h1&gt;;
}

function About() {
  return &lt;h1&gt;About Page&lt;/h1&gt;;
}

function Contact() {
  return &lt;h1&gt;Contact Page&lt;/h1&gt;;
}
</code></pre>
<h3 id="link"><a class="header" href="#link">Link</a></h3>
<p><code>Link</code> bileşeni, uygulamanız için yönlendirme bağlantıları oluşturmak amacıyla kullanılır. Bir kullanıcı <code>Link</code> bileşenine tıkladığında, tarayıcının URL'si güncellenir ve ilgili <code>Route</code> bileşeni render edilir.</p>
<pre><code class="language-jsx">import { Link } from 'react-router-dom';

function Navbar() {
  return (
    &lt;nav&gt;
      &lt;Link to="/"&gt;Home&lt;/Link&gt;
      &lt;Link to="/about"&gt;About&lt;/Link&gt;
      &lt;Link to="/contact"&gt;Contact&lt;/Link&gt;
    &lt;/nav&gt;
  );
}
</code></pre>
<h2 id="4-Örnek-proje-temel-bir-react-router-uygulaması"><a class="header" href="#4-Örnek-proje-temel-bir-react-router-uygulaması">4. Örnek Proje: Temel Bir React Router Uygulaması</a></h2>
<p>Bu bölümde, yukarıda açıklanan bileşenleri kullanarak basit bir React Router uygulaması oluşturacağız.</p>
<h3 id="proje-yapısı-1"><a class="header" href="#proje-yapısı-1">Proje Yapısı</a></h3>
<pre><code>src/
  ├── components/
  │   ├── Home.jsx
  │   ├── About.jsx
  │   └── Contact.jsx
  ├── App.js
  └── index.js
</code></pre>
<h3 id="homejsx"><a class="header" href="#homejsx">Home.jsx</a></h3>
<pre><code class="language-jsx">import React from 'react';

function Home() {
  return &lt;h1&gt;Home Page&lt;/h1&gt;;
}

export default Home;
</code></pre>
<h3 id="aboutjsx"><a class="header" href="#aboutjsx">About.jsx</a></h3>
<pre><code class="language-jsx">import React from 'react';

function About() {
  return &lt;h1&gt;About Page&lt;/h1&gt;;
}

export default About;
</code></pre>
<h3 id="contactjsx"><a class="header" href="#contactjsx">Contact.jsx</a></h3>
<pre><code class="language-jsx">import React from 'react';

function Contact() {
  return &lt;h1&gt;Contact Page&lt;/h1&gt;;
}

export default Contact;
</code></pre>
<h3 id="appjs-1"><a class="header" href="#appjs-1">App.js</a></h3>
<pre><code class="language-jsx">import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Home from './components/Home';
import About from './components/About';
import Contact from './components/Contact';
import Navbar from './components/Navbar';

function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;Navbar /&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
        &lt;Route path="/contact" element={&lt;Contact /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
}

export default App;
</code></pre>
<h3 id="navbarjs"><a class="header" href="#navbarjs">Navbar.js</a></h3>
<pre><code class="language-jsx">import React from 'react';
import { Link } from 'react-router-dom';

function Navbar() {
  return (
    &lt;nav&gt;
      &lt;Link to="/"&gt;Home&lt;/Link&gt;
      &lt;Link to="/about"&gt;About&lt;/Link&gt;
      &lt;Link to="/contact"&gt;Contact&lt;/Link&gt;
    &lt;/nav&gt;
  );
}

export default Navbar;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-uygulamalarında-İç-İçe-rotalar-nested-routes"><a class="header" href="#react-uygulamalarında-İç-İçe-rotalar-nested-routes">React Uygulamalarında İç İçe Rotalar (Nested Routes)</a></h1>
<p>Bu eğitimde, React uygulamalarında React Router kullanarak iç içe rotaların nasıl tanımlanacağını detaylı ve kapsamlı bir şekilde ele alacağız. İç içe rotalama, daha karmaşık navigasyon senaryolarını ele almak için rotaların hiyerarşik bir yapıda tanımlanmasını sağlar. Bu eğitim, sağlam ve bilimsel bir yaklaşımla hazırlanmış olup, yanlış bilgi veya hatalı yaklaşımlara eleştirel bir gözle bakılarak sunulmaktadır.</p>
<h2 id="1-proje-yapısının-oluşturulması-3"><a class="header" href="#1-proje-yapısının-oluşturulması-3">1. Proje Yapısının Oluşturulması</a></h2>
<p>İlk olarak, projenizin <code>src</code> dizini içerisinde <code>components</code> adlı yeni bir klasör oluşturun. Bu klasör, uygulamanızdaki bileşenleri barındıracaktır.</p>
<pre><code class="language-bash">mkdir src/components
</code></pre>
<h2 id="2-bileşenlerin-oluşturulması"><a class="header" href="#2-bileşenlerin-oluşturulması">2. Bileşenlerin Oluşturulması</a></h2>
<p><code>components</code> klasörünün içinde iki yeni dosya oluşturun: <code>CodingStella.jsx</code> ve <code>ProductDetail.jsx</code>. Bu dosyaların her biri uygulamamızda bir sayfayı temsil eden basit bir bileşen içerecektir.</p>
<h3 id="codingstellajsx"><a class="header" href="#codingstellajsx">CodingStella.jsx</a></h3>
<pre><code class="language-jsx">import React from 'react';

const CodingStella = () =&gt; {
    return (
        &lt;div&gt;
            &lt;h2&gt;Coding Stella Page&lt;/h2&gt;
            &lt;p&gt;Welcome to the Coding Stella page!&lt;/p&gt;
        &lt;/div&gt;
    );
};

export default CodingStella;
</code></pre>
<h3 id="productdetailjsx"><a class="header" href="#productdetailjsx">ProductDetail.jsx</a></h3>
<pre><code class="language-jsx">import React from 'react';

const ProductDetail = () =&gt; {
    return (
        &lt;div&gt;
            &lt;h2&gt;Product Detail Page&lt;/h2&gt;
            &lt;p&gt;Here are the details of the product.&lt;/p&gt;
        &lt;/div&gt;
    );
};

export default ProductDetail;
</code></pre>
<h2 id="3-uygulama-rotalarının-güncellenmesi"><a class="header" href="#3-uygulama-rotalarının-güncellenmesi">3. Uygulama Rotalarının Güncellenmesi</a></h2>
<p><code>App.js</code> dosyasını güncelleyerek uygulamanın rotalarını tanımlayın. React Router'ı kullanarak iç içe rotaları oluşturacağız.</p>
<h3 id="appjs-2"><a class="header" href="#appjs-2">App.js</a></h3>
<p>Öncelikle, gerekli bağımlılıkları ekleyin:</p>
<pre><code class="language-bash">npm install react-router-dom
</code></pre>
<p>Ardından <code>App.js</code> dosyasını aşağıdaki gibi güncelleyin:</p>
<pre><code class="language-jsx">import React from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import CodingStella from './components/CodingStella';
import ProductDetail from './components/ProductDetail';

const App = () =&gt; {
    return (
        &lt;Router&gt;
            &lt;div&gt;
                &lt;h1&gt;My React App&lt;/h1&gt;
                &lt;Switch&gt;
                    &lt;Route path="/coding-stella" component={CodingStella} /&gt;
                    &lt;Route path="/product/:id" component={ProductDetail} /&gt;
                &lt;/Switch&gt;
            &lt;/div&gt;
        &lt;/Router&gt;
    );
};

export default App;
</code></pre>
<h2 id="4-uygulamanın-Çalıştırılması"><a class="header" href="#4-uygulamanın-Çalıştırılması">4. Uygulamanın Çalıştırılması</a></h2>
<p>Uygulamayı çalıştırmak için aşağıdaki komutu kullanın:</p>
<pre><code class="language-bash">npm start
</code></pre>
<h1 id="sonuç-22"><a class="header" href="#sonuç-22">Sonuç</a></h1>
<p>Bu eğitimde, React uygulamalarında iç içe rotaların nasıl oluşturulacağını ve kullanılması gereken en iyi yöntemleri inceledik. Sağlam kod yapıları ve iyi planlanmış rotalar ile, uygulamalarınızın kullanıcı deneyimini önemli ölçüde geliştirebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kitapçı-web-sitesi-oluşturma"><a class="header" href="#kitapçı-web-sitesi-oluşturma">Kitapçı Web Sitesi Oluşturma</a></h1>
<h2 id="giriş-20"><a class="header" href="#giriş-20">Giriş</a></h2>
<p>Bu eğitim, React Router ve Link bileşenlerini kullanarak dinamik, tek sayfalık bir uygulama (SPA) oluşturma becerilerinizi pekiştirmeyi amaçlamaktadır. Eğitimde, modern ve kullanıcı dostu bir arayüze sahip bir kitapçı web sitesi geliştirilecektir. Bu süreçte, Tailwind CSS kullanarak stil verme ve kullanıcı deneyimini iyileştirme konuları da ele alınacaktır.</p>
<h2 id="eğitim-İçeriği-1"><a class="header" href="#eğitim-İçeriği-1">Eğitim İçeriği</a></h2>
<ol>
<li>
<p><strong>Projenin Genel Görünümü</strong></p>
<ul>
<li>Amacımız, bir ana sayfa, kitap listeleme sayfası ve her kitap için ayrı detay sayfalarından oluşan bir kitapçı web sitesi oluşturmaktır.</li>
<li>Web sitesi, React Router kullanarak farklı 'sayfalar' arasında gezinmeyi sağlayacaktır.</li>
</ul>
</li>
<li>
<p><strong>Gereksinimler</strong></p>
<ul>
<li>Modern ve kullanıcı dostu bir arayüz tasarımı.</li>
<li>React Router ile sayfalar arası geçiş.</li>
<li>Link bileşenleri ile navigasyon.</li>
<li>Statik veri kullanarak kitap listesi oluşturma.</li>
<li>404 Hata Sayfası ile hatalı URL yönetimi.</li>
<li>Tailwind CSS ile sayfa stilleri.</li>
</ul>
</li>
<li>
<p><strong>Proje Yapısı</strong></p>
<ul>
<li><code>/</code>: Ana sayfa</li>
<li><code>/books</code>: Kitap listeleme sayfası</li>
<li><code>/books/:id</code>: Kitap detay sayfası</li>
<li>Hatalı URL’ler için 404 Sayfası</li>
</ul>
</li>
</ol>
<h2 id="adım-adım-uygulama-3"><a class="header" href="#adım-adım-uygulama-3">Adım Adım Uygulama</a></h2>
<ol>
<li>
<p><strong>Proje Kurulumu</strong></p>
<pre><code class="language-bash">npx create-react-app bookstore
cd bookstore
npm install react-router-dom tailwindcss
npx tailwindcss init
</code></pre>
</li>
<li>
<p><strong>Tailwind CSS Yapılandırması</strong>
Tailwind CSS'i <code>tailwind.config.js</code> ve <code>src/index.css</code> dosyalarında yapılandırın.</p>
<pre><code class="language-javascript">// tailwind.config.js
module.exports = {
  purge: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'],
  darkMode: false,
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
}
</code></pre>
<pre><code class="language-css">/* src/index.css */
@import "tailwindcss/base";
@import "tailwindcss/components";
@import "tailwindcss/utilities";
</code></pre>
</li>
<li>
<p><strong>React Router Yapılandırması</strong>
<code>src/App.js</code> dosyasında React Router yapılandırmasını yapın.</p>
<pre><code class="language-javascript">import React from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import Home from './components/Home';
import BookList from './components/BookList';
import BookDetail from './components/BookDetail';
import NotFound from './components/NotFound';

function App() {
  return (
    &lt;Router&gt;
      &lt;Switch&gt;
        &lt;Route exact path="/" component={Home} /&gt;
        &lt;Route path="/books" component={BookList} /&gt;
        &lt;Route path="/book/:id" component={BookDetail} /&gt;
        &lt;Route component={NotFound} /&gt;
      &lt;/Switch&gt;
    &lt;/Router&gt;
  );
}

export default App;
</code></pre>
</li>
<li>
<p><strong>Bileşenlerin Oluşturulması</strong></p>
<ul>
<li>
<p><strong>Ana Sayfa (Home) Bileşeni</strong></p>
<pre><code class="language-javascript">// src/components/Home.js
import React from 'react';
import { Link } from 'react-router-dom';

function Home() {
  return (
    &lt;div className="container mx-auto p-4"&gt;
      &lt;h1 className="text-3xl font-bold"&gt;Kitapçıya Hoşgeldiniz&lt;/h1&gt;
      &lt;Link to="/books" className="text-blue-500"&gt;Kitapları Gör&lt;/Link&gt;
    &lt;/div&gt;
  );
}

export default Home;
</code></pre>
</li>
<li>
<p><strong>Kitap Listeleme (BookList) Bileşeni</strong></p>
<pre><code class="language-javascript">// src/components/BookList.js
import React from 'react';
import { Link } from 'react-router-dom';
import books from '../data/books';

function BookList() {
  return (
    &lt;div className="container mx-auto p-4"&gt;
      &lt;h1 className="text-3xl font-bold"&gt;Kitap Listesi&lt;/h1&gt;
      &lt;ul&gt;
        {books.map(book =&gt; (
          &lt;li key={book.id}&gt;
            &lt;Link to={`/book/${book.id}`} className="text-blue-500"&gt;
              {book.title}
            &lt;/Link&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

export default BookList;
</code></pre>
</li>
<li>
<p><strong>Kitap Detay (BookDetail) Bileşeni</strong></p>
<pre><code class="language-javascript">// src/components/BookDetail.js
import React from 'react';
import { useParams } from 'react-router-dom';
import books from '../data/books';

function BookDetail() {
  const { id } = useParams();
  const book = books.find(book =&gt; book.id === parseInt(id));

  if (!book) {
    return &lt;h2&gt;Kitap Bulunamadı&lt;/h2&gt;;
  }

  return (
    &lt;div className="container mx-auto p-4"&gt;
      &lt;h1 className="text-3xl font-bold"&gt;{book.title}&lt;/h1&gt;
      &lt;img src={book.image} alt={book.title} /&gt;
      &lt;p&gt;{book.description}&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default BookDetail;
</code></pre>
</li>
<li>
<p><strong>404 Sayfası (NotFound) Bileşeni</strong></p>
<pre><code class="language-javascript">// src/components/NotFound.js
import React from 'react';

function NotFound() {
  return (
    &lt;div className="container mx-auto p-4"&gt;
      &lt;h1 className="text-3xl font-bold"&gt;Sayfa Bulunamadı&lt;/h1&gt;
      &lt;p&gt;Üzgünüz, aradığınız sayfa mevcut değil.&lt;/p&gt;
    &lt;/div&gt;
  );
}

export default NotFound;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Veri Dosyasının Oluşturulması</strong></p>
<pre><code class="language-javascript">// src/data/books.js
const books = [
  { id: 1, title: 'Kitap 1', description: 'Kitap 1 Açıklaması', image: 'link_to_image_1' },
  { id: 2, title: 'Kitap 2', description: 'Kitap 2 Açıklaması', image: 'link_to_image_2' },
  // Diğer kitaplar...
];

export default books;
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-components-in-react"><a class="header" href="#class-components-in-react">Class Components in React</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-sınıf-bileşenleri"><a class="header" href="#react-sınıf-bileşenleri">React Sınıf Bileşenleri</a></h1>
<h2 id="giriş-21"><a class="header" href="#giriş-21">Giriş</a></h2>
<p>React, kullanıcı arayüzleri oluşturmak için popüler bir JavaScript kütüphanesidir. Bu eğitimde, React'te sınıf bileşenlerinin (class components) nasıl oluşturulacağını ve kullanılacağını öğreneceksiniz. Eğitim boyunca kullanılan terminoloji ve kavramlar güncel yazılım geliştirme standartlarına uygun olarak sunulmuştur.</p>
<h2 id="sınıf-bileşeni-oluşturma"><a class="header" href="#sınıf-bileşeni-oluşturma">Sınıf Bileşeni Oluşturma</a></h2>
<p>Bir React bileşeni oluştururken bileşenin adı büyük harfle başlamalıdır. Bileşen, <code>React.Component</code> sınıfını genişleterek (extend) yazılır ve bu şekilde React.Component'ın işlevlerine erişim sağlanır. Ayrıca bileşen, HTML döndüren bir <code>render()</code> yöntemine ihtiyaç duyar.</p>
<h3 id="adım-adım-sınıf-bileşeni-oluşturma"><a class="header" href="#adım-adım-sınıf-bileşeni-oluşturma">Adım Adım Sınıf Bileşeni Oluşturma</a></h3>
<ol>
<li>
<p><strong>Proje Dizini:</strong> Projenizin <code>src</code> dizini içinde <code>components</code> adlı yeni bir klasör oluşturun. Eğer bu klasör mevcutsa, yeni bir klasör oluşturmanıza gerek yoktur.</p>
</li>
<li>
<p><strong>Yeni Dosya:</strong> <code>components</code> klasörü içinde <code>MyComponent.jsx</code> adında yeni bir dosya oluşturun.</p>
</li>
<li>
<p><strong>React ve Component İçe Aktarma:</strong></p>
<pre><code class="language-javascript">import React, { Component } from 'react';
</code></pre>
</li>
<li>
<p><strong>Yeni Bir Sınıf Oluşturma:</strong></p>
<pre><code class="language-javascript">class MyComponent extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;Hello, World!&lt;/h1&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>
</li>
<li>
<p><strong>Bileşeni İhraç Etme:</strong></p>
<pre><code class="language-javascript">export default MyComponent;
</code></pre>
</li>
<li>
<p><strong>Bileşeni Kullanma:</strong> Başka bir dosyada bu bileşeni kullanmak için <code>import</code> ederek dahil edin. Örneğin, <code>App.js</code> dosyasını güncelleyin:</p>
<pre><code class="language-javascript">import React from 'react';
import MyComponent from './components/MyComponent';

function App() {
    return (
        &lt;div&gt;
            &lt;MyComponent /&gt;
        &lt;/div&gt;
    );
}

export default App;
</code></pre>
</li>
<li>
<p><strong>Sunucuyu Çalıştırma:</strong> Proje kök dizininde komut satırını açarak sunucuyu çalıştırın:</p>
<pre><code class="language-bash">npm start
</code></pre>
</li>
</ol>
<h2 id="kritik-İnceleme"><a class="header" href="#kritik-İnceleme">Kritik İnceleme</a></h2>
<p>Bu eğitimde, sınıf bileşenlerinin oluşturulması adım adım ele alınmıştır. Modern React uygulamalarında fonksiyon bileşenleri ve Hook'lar daha yaygın olarak kullanılmakla birlikte, sınıf bileşenlerinin anlaşılması önemlidir. Sınıf bileşenleri, bileşen durumu (state) ve yaşam döngüsü yöntemlerini kullanma konusunda daha detaylı kontrol sağlar. Ancak, yeni projelerde fonksiyon bileşenlerinin ve Hook'ların kullanılması önerilir.</p>
<h2 id="kod-parçacıkları-2"><a class="header" href="#kod-parçacıkları-2">Kod Parçacıkları</a></h2>
<p>Aşağıda, yukarıda belirtilen adımların tam kod parçacıklarını bulabilirsiniz:</p>
<ol>
<li>
<p><strong>MyComponent.jsx:</strong></p>
<pre><code class="language-javascript">import React, { Component } from 'react';

class MyComponent extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;Hello, World!&lt;/h1&gt;
            &lt;/div&gt;
        );
    }
}

export default MyComponent;
</code></pre>
</li>
<li>
<p><strong>App.js:</strong></p>
<pre><code class="language-javascript">import React from 'react';
import MyComponent from './components/MyComponent';

function App() {
    return (
        &lt;div&gt;
            &lt;MyComponent /&gt;
        &lt;/div&gt;
    );
}

export default App;
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-component-constructor"><a class="header" href="#react-component-constructor">React Component Constructor</a></h1>
<p>Bu eğitim, React bileşenlerinde constructor() fonksiyonunun nasıl kullanılacağını ve bileşenlerin durumlarının nasıl başlatılacağını kapsamlı ve ayrıntılı bir şekilde açıklamaktadır. İçerik, yazılım geliştirme alanında beklenen titizlik ve standartları yansıtacak şekilde düzenlenmiştir.</p>
<h2 id="1-bileşen-klasörü-oluşturma-1"><a class="header" href="#1-bileşen-klasörü-oluşturma-1">1. Bileşen Klasörü Oluşturma</a></h2>
<p>Projenizin <code>src</code> dizininde bileşenlerinizi düzenli tutmak için yeni bir <code>components</code> klasörü oluşturun. Eğer bu klasör zaten mevcutsa, bu adımı atlayabilirsiniz.</p>
<pre><code class="language-bash">mkdir src/components
</code></pre>
<h2 id="2-bileşen-dosyasını-oluşturma"><a class="header" href="#2-bileşen-dosyasını-oluşturma">2. Bileşen Dosyasını Oluşturma</a></h2>
<p><code>components</code> klasörünün içinde, <code>WelcomeMessage.jsx</code> adında yeni bir dosya oluşturun. Bu dosya, sınıf tabanlı bileşeninizi içerecektir.</p>
<pre><code class="language-bash">touch src/components/WelcomeMessage.jsx
</code></pre>
<h2 id="3-reactı-İçe-aktarma"><a class="header" href="#3-reactı-İçe-aktarma">3. React'ı İçe Aktarma</a></h2>
<p><code>WelcomeMessage.jsx</code> dosyasını favori metin düzenleyicinizde açın ve React'ı içe aktararak başlayın.</p>
<pre><code class="language-javascript">import React, { Component } from 'react';
</code></pre>
<h2 id="4-sınıf-tabanlı-bileşen-oluşturma"><a class="header" href="#4-sınıf-tabanlı-bileşen-oluşturma">4. Sınıf Tabanlı Bileşen Oluşturma</a></h2>
<p><code>Component</code> sınıfından türeyen yeni bir <code>WelcomeMessage</code> sınıf bileşeni oluşturun.</p>
<pre><code class="language-javascript">class WelcomeMessage extends Component {
  constructor(props) {
    super(props);
    this.state = {
      message: 'Hoş geldiniz'
    };
  }

  render() {
    return (
      &lt;div&gt;
        {this.state.message}
      &lt;/div&gt;
    );
  }
}

export default WelcomeMessage;
</code></pre>
<h2 id="5-bileşenin-başlatılması"><a class="header" href="#5-bileşenin-başlatılması">5. Bileşenin Başlatılması</a></h2>
<p>Bileşen başlatıldığında çağrılan <code>constructor()</code> fonksiyonunu ekleyin ve bileşenin durumlarını bu fonksiyon içinde başlatın.</p>
<pre><code class="language-javascript">constructor(props) {
  super(props);
  this.state = {
    message: 'Hoş geldiniz'
  };
}
</code></pre>
<h2 id="6-durum-değişkenini-başlatma"><a class="header" href="#6-durum-değişkenini-başlatma">6. Durum Değişkenini Başlatma</a></h2>
<p><code>constructor</code> içinde bir <code>message</code> durumu başlatın.</p>
<pre><code class="language-javascript">this.state = {
  message: 'Hoş geldiniz'
};
</code></pre>
<h2 id="7-render-metodunu-ekleyin"><a class="header" href="#7-render-metodunu-ekleyin">7. Render Metodunu Ekleyin</a></h2>
<p>Bileşen içinde hoş geldiniz mesajını görüntülemek için bir <code>render</code> metodu ekleyin.</p>
<pre><code class="language-javascript">render() {
  return (
    &lt;div&gt;
      {this.state.message}
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="8-bileşeni-kullanma"><a class="header" href="#8-bileşeni-kullanma">8. Bileşeni Kullanma</a></h2>
<p>Başka bir bileşen veya uygulama dosyasında bu bileşeni kullanmak için içe aktarın ve dahil edin. Örneğin, <code>App.js</code> dosyasını güncelleyebilirsiniz.</p>
<pre><code class="language-javascript">import React from 'react';
import WelcomeMessage from './components/WelcomeMessage';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;WelcomeMessage /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fonksiyonel-bileşenler-ve-sınıf-bileşenleri"><a class="header" href="#fonksiyonel-bileşenler-ve-sınıf-bileşenleri">Fonksiyonel Bileşenler ve Sınıf Bileşenleri</a></h1>
<h2 id="giriş-22"><a class="header" href="#giriş-22">Giriş</a></h2>
<p>Bu eğitimde, React'te fonksiyonel bileşenler ve sınıf bileşenleri arasındaki farkları detaylı bir şekilde inceleyeceğiz. Eğitim boyunca, kod parçacıkları ve örnekler ile konuyu açıklayacağız. React uygulamalarında bileşenlerin nasıl tanımlandığını, durum yönetimini ve yaşam döngüsü metodlarını ele alacağız.</p>
<h2 id="sınıf-bileşenleri"><a class="header" href="#sınıf-bileşenleri">Sınıf Bileşenleri</a></h2>
<h3 id="tanım-2"><a class="header" href="#tanım-2">Tanım</a></h3>
<p>React'te sınıf bileşenleri, ES6 sınıfları kullanılarak tanımlanır. Bu bileşenler, durum yönetimi ve yaşam döngüsü metodlarını kullanma imkanı sağlar.</p>
<h3 id="Özellikler"><a class="header" href="#Özellikler">Özellikler</a></h3>
<ol>
<li>
<p><strong>Yaşam Döngüsü Metodları</strong>: Sınıf bileşenleri, bileşenin yaşam döngüsünün farklı aşamalarında kontrol sağlamanıza olanak tanıyan metodlar içerir. Örneğin:</p>
<ul>
<li><code>componentDidMount</code></li>
<li><code>componentDidUpdate</code></li>
<li><code>componentWillUnmount</code></li>
</ul>
<p>Bu metodlar, bileşenin başlatılması, güncellenmesi ve yıkılması gibi aşamalarda ne olacağını kontrol etmenizi sağlar.</p>
</li>
<li>
<p><strong>Durum Yönetimi</strong>: Sınıf bileşenleri, yerel durum (state) tutabilir ve yönetebilir. Bunun için <code>this.state</code> ve <code>this.setState()</code> metodları kullanılır.</p>
</li>
<li>
<p><strong>Kapsam</strong>: Sınıf bileşenlerinde <code>this</code> anahtar kelimesi, özellikler, durum ve metodlara erişim için kullanılır.</p>
</li>
<li>
<p><strong>Ayrıntılı Yapı</strong>: Sınıf bileşenleri, ek sözdizimi gereksinimleri nedeniyle daha ayrıntılı ve uzun olabilir. Örneğin, metod tanımlamaları ve <code>this</code> bağlamı.</p>
</li>
</ol>
<h3 id="Örnek-6"><a class="header" href="#Örnek-6">Örnek</a></h3>
<p>Aşağıda bir sınıf bileşeninin basit bir örneği bulunmaktadır:</p>
<pre><code class="language-jsx">import React, { Component } from 'react';

class Greeting extends Component {
  constructor(props) {
    super(props);
    this.state = {
      message: 'Merhaba, React!'
    };
  }

  componentDidMount() {
    console.log('Bileşen yüklendi.');
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;{this.state.message}&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}

export default Greeting;
</code></pre>
<h2 id="fonksiyonel-bileşenler"><a class="header" href="#fonksiyonel-bileşenler">Fonksiyonel Bileşenler</a></h2>
<h3 id="tanım-3"><a class="header" href="#tanım-3">Tanım</a></h3>
<p>Fonksiyonel bileşenler, sadece bir fonksiyon olarak tanımlanan bileşenlerdir. React 16.8 ile birlikte gelen Hooks sayesinde, fonksiyonel bileşenler durum yönetimi ve yaşam döngüsü metodlarını kullanabilir hale gelmiştir.</p>
<h3 id="Özellikler-1"><a class="header" href="#Özellikler-1">Özellikler</a></h3>
<ol>
<li>
<p><strong>Durum ve Hooks</strong>: Fonksiyonel bileşenler, <code>useState</code> ve <code>useEffect</code> gibi Hook'lar kullanarak durum yönetimi ve yaşam döngüsü olaylarını yönetebilir.</p>
</li>
<li>
<p><strong>Basit Sözdizimi</strong>: Fonksiyonel bileşenler, daha basit ve az ayrıntılı bir sözdizimine sahiptir. Sadece bir JavaScript fonksiyonu olarak tanımlanırlar.</p>
</li>
<li>
<p><strong>Performans</strong>: Fonksiyonel bileşenler, sınıf bileşenlerine göre daha az kaynak tüketebilir, çünkü sınıf örneklemesi gerektirmezler. Ancak, bu fark çoğu uygulamada minimaldir.</p>
</li>
<li>
<p><strong>Kapsam Yok</strong>: Fonksiyonel bileşenler <code>this</code> anahtar kelimesini kullanmazlar. Tüm özellikler ve metodlar fonksiyon parametreleri ve Hook'lar aracılığıyla yönetilir.</p>
</li>
</ol>
<h3 id="Örnek-7"><a class="header" href="#Örnek-7">Örnek</a></h3>
<p>Aşağıda bir fonksiyonel bileşenin basit bir örneği bulunmaktadır:</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from 'react';

const Greeting = () =&gt; {
  const [message, setMessage] = useState('Merhaba, React!');

  useEffect(() =&gt; {
    console.log('Bileşen yüklendi.');
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;{message}&lt;/h1&gt;
    &lt;/div&gt;
  );
};

export default Greeting;
</code></pre>
<h2 id="karşılaştırma"><a class="header" href="#karşılaştırma">Karşılaştırma</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Özellikler</th><th>Sınıf Bileşenleri</th><th>Fonksiyonel Bileşenler</th></tr></thead><tbody>
<tr><td>Tanımlama</td><td>ES6 sınıfları kullanılarak tanımlanır</td><td>JavaScript fonksiyonları kullanılarak tanımlanır</td></tr>
<tr><td>Durum Yönetimi</td><td><code>this.state</code> ve <code>this.setState()</code> ile yönetilir</td><td><code>useState</code> Hook'u ile yönetilir</td></tr>
<tr><td>Yaşam Döngüsü Metodları</td><td><code>componentDidMount</code>, <code>componentDidUpdate</code> vb.</td><td><code>useEffect</code> Hook'u ile yönetilir</td></tr>
<tr><td>Sözdizimi</td><td>Daha ayrıntılı ve uzun</td><td>Daha basit ve kısa</td></tr>
<tr><td>Performans</td><td>Biraz daha fazla kaynak tüketebilir</td><td>Daha az kaynak tüketir, ancak fark genelde minimaldir</td></tr>
<tr><td>Kapsam</td><td><code>this</code> kullanılır</td><td><code>this</code> kullanılmaz</td></tr>
</tbody></table>
</div>
<h2 id="sonuç-23"><a class="header" href="#sonuç-23">Sonuç</a></h2>
<p>React bileşenlerinin fonksiyonel veya sınıf bileşenleri olarak tanımlanması, geliştirme sürecinde önemli bir rol oynar. Fonksiyonel bileşenler, Hook'ların tanıtılmasıyla birlikte daha esnek ve kullanımı kolay hale gelmiştir. React, yeni bileşenler için fonksiyonel bileşenlerin ve Hook'ların kullanılmasını önermektedir, ancak bazı durumlarda sınıf bileşenleri hala tercih edilebilir.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="react-sınıf-bileşenlerinde-props-kullanımı"><a class="header" href="#react-sınıf-bileşenlerinde-props-kullanımı">React Sınıf Bileşenlerinde Props Kullanımı</a></h2>
<p>Bu eğitim, React sınıf bileşenlerinde props kullanımını kapsamlı ve ayrıntılı bir şekilde ele alacaktır. İçeriğin ciddi ve bilimsel olmasını sağlayacak ve yazılım geliştirme alanında beklenen titizlik ve standartları yansıtacak şekilde hazırlanmıştır.</p>
<h3 id="1-bileşenler-İçin-klasör-oluşturma"><a class="header" href="#1-bileşenler-İçin-klasör-oluşturma">1. Bileşenler İçin Klasör Oluşturma</a></h3>
<p>İlk olarak, proje dosya yapısını organize etmek için <code>src</code> dizininde yeni bir <code>components</code> adlı klasör oluşturun. Eğer bu klasör zaten mevcutsa, bu adımı atlayabilirsiniz.</p>
<h3 id="2-bileşen-dosyalarını-oluşturma"><a class="header" href="#2-bileşen-dosyalarını-oluşturma">2. Bileşen Dosyalarını Oluşturma</a></h3>
<p><code>components</code> klasörü içerisinde <code>ParentComponent.jsx</code> ve <code>ChildComponent.jsx</code> adında iki yeni dosya oluşturun.</p>
<h3 id="3-parentcomponentjsx-dosyasını-yazma"><a class="header" href="#3-parentcomponentjsx-dosyasını-yazma">3. ParentComponent.jsx Dosyasını Yazma</a></h3>
<p><code>ParentComponent.jsx</code> dosyasını açın ve aşağıdaki kodu yazın:</p>
<pre><code class="language-jsx">import React, { Component } from 'react';
import ChildComponent from './ChildComponent';

class ParentComponent extends Component {
  render() {
    const message = "Merhaba, bu bir props mesajıdır!";
    return (
      &lt;div&gt;
        &lt;h1&gt;Parent Component&lt;/h1&gt;
        &lt;ChildComponent greeting={message} /&gt;
      &lt;/div&gt;
    );
  }
}

export default ParentComponent;
</code></pre>
<p>Bu kodda, bir <code>div</code> içinde bir <code>h1</code> elementi oluşturuyoruz ve <code>ChildComponent</code> bileşenini kullanıyoruz. Bu sırada <code>greeting</code> propunu <code>message</code> değeriyle geçiriyoruz.</p>
<h3 id="4-childcomponentjsx-dosyasını-yazma"><a class="header" href="#4-childcomponentjsx-dosyasını-yazma">4. ChildComponent.jsx Dosyasını Yazma</a></h3>
<p><code>ChildComponent.jsx</code> dosyasını açın ve aşağıdaki kodu yazın:</p>
<pre><code class="language-jsx">import React, { Component } from 'react';

class ChildComponent extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;{this.props.greeting}&lt;/p&gt;
      &lt;/div&gt;
    );
  }
}

export default ChildComponent;
</code></pre>
<p>Bu kodda, <code>ParentComponent</code> render edildiğinde, <code>ChildComponent</code> bileşeni de render edilir ve <code>greeting</code> propunu alır. <code>ChildComponent</code>, bu propun değerini bir <code>p</code> elementi içinde görüntüler. Prop, temel olarak veriyi ebeveyn bileşenden çocuk bileşene aktarmanın bir yoludur.</p>
<h3 id="5-appjs-dosyasına-parentcomponenti-dahil-etme"><a class="header" href="#5-appjs-dosyasına-parentcomponenti-dahil-etme">5. App.js Dosyasına ParentComponent'i Dahil Etme</a></h3>
<p>Şimdi, <code>src/App.js</code> dosyasını açın ve <code>ParentComponent</code> bileşenini import edin:</p>
<pre><code class="language-jsx">import React from 'react';
import ParentComponent from './components/ParentComponent';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;ParentComponent /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<h3 id="6-uygulamayı-Çalıştırma"><a class="header" href="#6-uygulamayı-Çalıştırma">6. Uygulamayı Çalıştırma</a></h3>
<p>Tüm bileşenleri oluşturduktan ve gerekli dosyaları düzenledikten sonra, uygulamanızı çalıştırın. Terminalde <code>npm start</code> komutunu kullanarak uygulamanızı başlatabilirsiniz. Tarayıcınızda, <code>ParentComponent</code> bileşeninin render edildiğini ve <code>ChildComponent</code> bileşenine props ile geçirilen mesajı görüntülediğini göreceksiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-class-bileşenlerinde-durum-yönetimi"><a class="header" href="#react-class-bileşenlerinde-durum-yönetimi">React Class Bileşenlerinde Durum Yönetimi</a></h1>
<p>Bu eğitimde, React sınıf bileşenlerinde durumun (state) nasıl yönetileceğini ele alacağız. Durum, bileşen içindeki verilerin zamanla değişebileceği bir nesnedir. React, durum değiştiğinde bileşeni yeniden render ederek güncellenmiş verileri yansıtır.</p>
<h2 id="adım-1-proje-yapısını-oluşturma"><a class="header" href="#adım-1-proje-yapısını-oluşturma">Adım 1: Proje Yapısını Oluşturma</a></h2>
<p>Öncelikle, bileşenlerinizi düzenli tutmak için projenizin <code>src</code> dizininde <code>components</code> adlı bir klasör oluşturun. Bu klasör zaten mevcutsa, bu adımı atlayabilirsiniz.</p>
<pre><code class="language-bash">mkdir src/components
</code></pre>
<h2 id="adım-2-counter-bileşeni-oluşturma"><a class="header" href="#adım-2-counter-bileşeni-oluşturma">Adım 2: Counter Bileşeni Oluşturma</a></h2>
<p><code>components</code> klasörünün içinde <code>Counter.jsx</code> adında bir dosya oluşturun ve aşağıdaki kodu ekleyin.</p>
<pre><code class="language-jsx">import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  increment = () =&gt; {
    this.setState((prevState) =&gt; ({
      count: prevState.count + 1
    }));
  };

  decrement = () =&gt; {
    this.setState((prevState) =&gt; ({
      count: prevState.count - 1
    }));
  };

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Counter: {this.state.count}&lt;/h1&gt;
        &lt;button onClick={this.increment}&gt;Increment&lt;/button&gt;
        &lt;button onClick={this.decrement}&gt;Decrement&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default Counter;
</code></pre>
<h2 id="adım-3-counter-bileşenini-kullanma"><a class="header" href="#adım-3-counter-bileşenini-kullanma">Adım 3: Counter Bileşenini Kullanma</a></h2>
<p>Şimdi <code>src/App.js</code> dosyasını açın ve <code>Counter</code> bileşenini içe aktararak kullanın.</p>
<pre><code class="language-jsx">import React from 'react';
import Counter from './components/Counter';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;Counter /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<h2 id="adım-4-uygulamayı-Çalıştırma"><a class="header" href="#adım-4-uygulamayı-Çalıştırma">Adım 4: Uygulamayı Çalıştırma</a></h2>
<p>Uygulamanızı çalıştırarak <code>Counter</code> bileşeninin doğru şekilde çalıştığını kontrol edin.</p>
<pre><code class="language-bash">npm start
</code></pre>
<h2 id="durumun-değiştirilmesi-ve-render-süreci"><a class="header" href="#durumun-değiştirilmesi-ve-render-süreci">Durumun Değiştirilmesi ve Render Süreci</a></h2>
<p>Yukarıdaki örnekte, <code>Counter</code> bileşeni iki butona sahiptir: <code>Increment</code> ve <code>Decrement</code>. Her iki buton da bileşenin durumunu değiştirir ve <code>setState</code> yöntemi ile durumu günceller. React, durum değişikliği olduğunda bileşeni yeniden render ederek ekrandaki verilerin güncellenmesini sağlar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ile-bir-film-rezervasyon-mağazası-oluşturun"><a class="header" href="#react-ile-bir-film-rezervasyon-mağazası-oluşturun">React ile Bir Film Rezervasyon Mağazası Oluşturun</a></h1>
<h4 id="amaç-3"><a class="header" href="#amaç-3"><strong>Amaç:</strong></a></h4>
<p>Bu görevin amacı, React'teki sınıf bileşenleri ile props ve state kullanımını derinlemesine anlamanızı sağlamaktır. Kullanıcıların koltuk seçip film biletleri rezerve edebileceği bir film rezervasyon sistemi oluşturacaksınız. Ayrıca, kullanıcı arayüzünü geliştirmek ve görsel olarak çekici bir deneyim sunmak için <strong>Tailwind CSS</strong> kullanacaksınız.</p>
<h4 id="gereksinimler-9"><a class="header" href="#gereksinimler-9"><strong>Gereksinimler:</strong></a></h4>
<ol>
<li>Bir sinema salonu oturma düzenini temsil eden bir kullanıcı arayüzü tasarlayın. Koltukları konumlandırmak ve stil vermek için CSS ve Tailwind CSS sınıflarını kullanarak sezgisel ve görsel olarak çekici bir düzen oluşturun.</li>
<li>"Seat" bileşeni içinde koltuk bilgilerini görüntüleyin ve koltuğun rezerve edilip edilmediğine bağlı olarak Tailwind CSS sınıfları kullanarak stil verin.</li>
<li>"MovieBookingSystem" adlı bir ana bileşen oluşturun.</li>
<li>"MovieBookingSystem" bileşeni içinde bir koltuk nesneleri dizisi tanımlayın. Her koltuk nesnesi aşağıdaki özelliklere sahip olmalıdır:
<ul>
<li><strong><code>id</code></strong> (string veya numara): Koltuğun benzersiz tanımlayıcısı.</li>
<li><strong><code>row</code></strong> (string): Koltuğun sıra numarası veya harfi.</li>
<li><strong><code>column</code></strong> (string veya numara): Koltuğun sütun numarası veya harfi.</li>
<li><strong><code>isBooked</code></strong> (boolean): Koltuğun zaten rezerve edilip edilmediğini belirtir.</li>
<li><strong><code>shouldExclude:</code></strong>(boolean): Koltuğun dahil edilip edilmediğini belirtir.</li>
</ul>
</li>
<li>"MovieBookingSystem" bileşeni içinde, her koltuk nesnesini props olarak geçirerek birden fazla "Seat" bileşeni örneği oluşturun.</li>
<li>Her "Seat" bileşeninin doğru koltuk bilgilerini görüntülediğinden ve tıklandığında rezervasyon durumunu doğru şekilde güncellediğinden emin olun.</li>
<li>"MovieBookingSystem" bileşenine, seçilen koltukları ve detaylarını (örneğin sıra, sütun) görüntüleyen bir özet bölümü ekleyin.</li>
<li>Özet bölümünde, rezervasyon işlemine devam etmek için bir düğme ekleyin.</li>
<li>Rezervasyon düğmesine tıklandığında, "MovieBookingSystem" bileşeninin state'ini seçilen koltukları depolayacak şekilde güncelleyin ve rezervasyon işlemini tamamlamak için gerekli işlemleri (örneğin, API çağrıları, hesaplamalar) gerçekleştirin.</li>
<li>Film rezervasyon sisteminin genel görünümünü geliştirmek için Tailwind CSS sınıflarını ve özel stilleri uygulayın.</li>
<li>Uygulamanın props, state, koltuk seçimi ve rezervasyon işlemlerinin beklendiği gibi çalıştığını doğrulamak için test edin.</li>
</ol>
<h3 id="adım-adım-uygulama-4"><a class="header" href="#adım-adım-uygulama-4">Adım Adım Uygulama</a></h3>
<h4 id="1-proje-kurulumu"><a class="header" href="#1-proje-kurulumu">1. Proje Kurulumu</a></h4>
<p>Öncelikle, React projenizi oluşturun ve gerekli bağımlılıkları kurun.</p>
<pre><code class="language-bash">npx create-react-app movie-booking-store
cd movie-booking-store
npm install tailwindcss
npx tailwindcss init
</code></pre>
<p><code>tailwind.config.js</code> dosyasını aşağıdaki gibi yapılandırın:</p>
<pre><code class="language-javascript">module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</code></pre>
<p><code>src/index.css</code> dosyasını aşağıdaki gibi güncelleyin:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h4 id="2-bileşenler-ve-state-yönetimi"><a class="header" href="#2-bileşenler-ve-state-yönetimi">2. Bileşenler ve State Yönetimi</a></h4>
<p><code>src</code> klasöründe <code>components</code> adlı bir klasör oluşturun ve <code>MovieBookingSystem.js</code> ve <code>Seat.js</code> dosyalarını ekleyin.</p>
<p><strong><code>Seat.js</code></strong></p>
<pre><code class="language-jsx">import React from 'react';

class Seat extends React.Component {
  handleClick = () =&gt; {
    this.props.onClick(this.props.seat.id);
  };

  render() {
    const { row, column, isBooked } = this.props.seat;
    const seatClass = isBooked ? 'bg-red-500' : 'bg-green-500';

    return (
      &lt;div
        className={`seat ${seatClass} m-2 p-4 text-white`}
        onClick={this.handleClick}
      &gt;
        {row}{column}
      &lt;/div&gt;
    );
  }
}

export default Seat;
</code></pre>
<p><strong><code>MovieBookingSystem.js</code></strong></p>
<pre><code class="language-jsx">import React from 'react';
import Seat from './Seat';

class MovieBookingSystem extends React.Component {
  state = {
    seats: [
      { id: 1, row: 'A', column: 1, isBooked: false },
      { id: 2, row: 'A', column: 2, isBooked: false },
      // Diğer koltuk nesneleri
    ],
    selectedSeats: []
  };

  handleSeatClick = (seatId) =&gt; {
    this.setState(prevState =&gt; {
      const updatedSeats = prevState.seats.map(seat =&gt;
        seat.id === seatId ? { ...seat, isBooked: !seat.isBooked } : seat
      );
      const selectedSeats = updatedSeats.filter(seat =&gt; seat.isBooked);
      return { seats: updatedSeats, selectedSeats };
    });
  };

  handleBooking = () =&gt; {
    console.log("Seçilen Koltuklar:", this.state.selectedSeats);
    // API çağrısı veya diğer işlemler
  };

  render() {
    return (
      &lt;div className="movie-booking-system"&gt;
        &lt;div className="seats grid grid-cols-5 gap-4"&gt;
          {this.state.seats.map(seat =&gt; (
            &lt;Seat
              key={seat.id}
              seat={seat}
              onClick={this.handleSeatClick}
            /&gt;
          ))}
        &lt;/div&gt;
        &lt;div className="summary mt-4"&gt;
          &lt;h2&gt;Seçilen Koltuklar&lt;/h2&gt;
          &lt;ul&gt;
            {this.state.selectedSeats.map(seat =&gt; (
              &lt;li key={seat.id}&gt;{seat.row}{seat.column}&lt;/li&gt;
            ))}
          &lt;/ul&gt;
          &lt;button
            className="booking-button mt-2 p-2 bg-blue-500 text-white"
            onClick={this.handleBooking}
          &gt;
            Rezervasyonu Tamamla
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

export default MovieBookingSystem;
</code></pre>
<h4 id="3-uygulamayı-test-etme"><a class="header" href="#3-uygulamayı-test-etme">3. Uygulamayı Test Etme</a></h4>
<p>Projeyi çalıştırarak uygulamanızı test edin:</p>
<pre><code class="language-bash">npm start
</code></pre>
<p>Koltukların seçilebildiğini ve seçilen koltukların özet bölümünde listelendiğini doğrulayın. Rezervasyon butonuna tıkladığınızda konsolda seçilen koltukların göründüğünden emin olun.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-lifecycle-methods"><a class="header" href="#react-lifecycle-methods">React Lifecycle Methods</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-bileşen-yaşam-döngüsü"><a class="header" href="#react-bileşen-yaşam-döngüsü">React Bileşen Yaşam Döngüsü</a></h1>
<p>React'te her bileşenin yaşam döngüsü vardır ve bu döngüyü üç ana aşamada izleyebilir ve yönetebilirsiniz:</p>
<ul>
<li><strong>Montaj (Mounting)</strong></li>
<li><strong>Güncelleme (Updating)</strong></li>
<li><strong>Demontaj (Unmounting)</strong></li>
</ul>
<p>Bu eğitimde, her aşamanın ne olduğunu, nasıl çalıştığını ve bunları nasıl yönetebileceğinizi ayrıntılı olarak ele alacağız.</p>
<h2 id="montaj-mounting"><a class="header" href="#montaj-mounting">Montaj (Mounting)</a></h2>
<p>Montaj aşaması, bileşenin DOM'a yerleştirildiği aşamadır. Bu aşamada aşağıdaki yöntemler sırasıyla çağrılır:</p>
<ol>
<li><strong>constructor()</strong>: Bileşen başlatıldığında çağrılır.</li>
<li><strong>static getDerivedStateFromProps()</strong>: State, props'tan türetilir.</li>
<li><strong>render()</strong>: JSX'i DOM'a yerleştirmek için çağrılır.</li>
<li><strong>componentDidMount()</strong>: Bileşen DOM'a monte edildikten sonra çağrılır.</li>
</ol>
<pre><code class="language-jsx">class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      // Başlangıç state
    };
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    // props'tan state türetmek için kullanılır
    return null; // state değişikliği yoksa null döndür
  }

  componentDidMount() {
    // Bileşen DOM'a monte edildiğinde çalışır
  }

  render() {
    return (
      &lt;div&gt;
        {/* JSX içeriği */}
      &lt;/div&gt;
    );
  }
}
</code></pre>
<h2 id="güncelleme-updating"><a class="header" href="#güncelleme-updating">Güncelleme (Updating)</a></h2>
<p>Güncelleme aşaması, bileşenin state veya props değişiklikleri nedeniyle yeniden render edilmesi gerektiğinde gerçekleşir. Bu aşamada aşağıdaki yöntemler sırasıyla çağrılır:</p>
<ol>
<li><strong>static getDerivedStateFromProps()</strong>: State, props'tan türetilir.</li>
<li><strong>shouldComponentUpdate()</strong>: Bileşenin yeniden render edilip edilmeyeceğini belirler.</li>
<li><strong>render()</strong>: JSX'i DOM'a yeniden yerleştirmek için çağrılır.</li>
<li><strong>getSnapshotBeforeUpdate()</strong>: DOM güncellemesinden hemen önce çağrılır.</li>
<li><strong>componentDidUpdate()</strong>: Bileşen DOM güncellemesinden sonra çağrılır.</li>
</ol>
<pre><code class="language-jsx">class MyComponent extends React.Component {
  static getDerivedStateFromProps(nextProps, prevState) {
    return null;
  }

  shouldComponentUpdate(nextProps, nextState) {
    // Bileşenin yeniden render edilip edilmeyeceğine karar verilir
    return true;
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // DOM güncellemesinden hemen önce bir değer döndürür
    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    // Bileşen DOM güncellemesinden sonra çalışır
  }

  render() {
    return (
      &lt;div&gt;
        {/* JSX içeriği */}
      &lt;/div&gt;
    );
  }
}
</code></pre>
<h2 id="demontaj-unmounting"><a class="header" href="#demontaj-unmounting">Demontaj (Unmounting)</a></h2>
<p>Demontaj aşaması, bileşenin DOM'dan kaldırıldığı aşamadır. Bu aşamada yalnızca bir yöntem çağrılır:</p>
<ol>
<li><strong>componentWillUnmount()</strong>: Bileşen DOM'dan kaldırılmadan hemen önce çağrılır.</li>
</ol>
<pre><code class="language-jsx">class MyComponent extends React.Component {
  componentWillUnmount() {
    // Bileşen DOM'dan kaldırılmadan önce çalışır
  }

  render() {
    return (
      &lt;div&gt;
        {/* JSX içeriği */}
      &lt;/div&gt;
    );
  }
}
</code></pre>
<h2 id="sonuç-24"><a class="header" href="#sonuç-24">Sonuç</a></h2>
<p>React bileşenlerinin yaşam döngüsü, bileşenlerin belirli olaylar sırasında belirli işlemler gerçekleştirmesine olanak tanır. Bu yaşam döngüsü yöntemlerini doğru ve verimli bir şekilde kullanarak uygulamalarınızın performansını ve bakımını iyileştirebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-bileşenlerinin-mounting-montaj"><a class="header" href="#react-bileşenlerinin-mounting-montaj">React Bileşenlerinin Mounting (Montaj)</a></h1>
<h2 id="giriş-23"><a class="header" href="#giriş-23">Giriş</a></h2>
<p>React, modern web geliştirme dünyasında popüler bir JavaScript kütüphanesidir. Bu eğitimde, React bileşenlerinin montaj (Mount) aşamasını ayrıntılı bir şekilde ele alacağız. Montaj (Mount), bir bileşenin oluşturulup DOM'a eklenme sürecidir. Bu süreç, bileşenin yaşam döngüsünün ilk aşamasını temsil eder ve belirli yaşam döngüsü yöntemlerinin sırasıyla çağrılmasıyla karakterize edilir.</p>
<h2 id="yaşam-döngüsü-yöntemleri"><a class="header" href="#yaşam-döngüsü-yöntemleri">Yaşam Döngüsü Yöntemleri</a></h2>
<p>Montaj(Mount) aşamasında çağrılan yaşam döngüsü yöntemleri sırasıyla şunlardır:</p>
<ol>
<li><code>constructor(props)</code></li>
<li><code>static getDerivedStateFromProps(props, state)</code></li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ol>
<h3 id="1-constructorprops"><a class="header" href="#1-constructorprops">1. Constructor(props)</a></h3>
<p><strong><code>constructor()</code></strong> yöntemi, bileşen başlatıldığında ilk olarak çağrılır. Bu yöntem, başlangıç durumunu (state) ve diğer başlangıç değerlerini ayarlamak için doğal bir yerdir.</p>
<pre><code class="language-javascript">class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
  }
}
</code></pre>
<h3 id="2-static-getderivedstatefrompropsprops-state"><a class="header" href="#2-static-getderivedstatefrompropsprops-state">2. static getDerivedStateFromProps(props, state)</a></h3>
<p><strong><code>getDerivedStateFromProps()</code></strong> yöntemi, DOM'a eleman(lar)ın render edilmesinden hemen önce çağrılır. Bu yöntem, başlangıç <code>props</code>larına dayalı olarak <code>state</code> nesnesini ayarlamak için doğal bir yerdir. <code>state</code>'i bir argüman olarak alır ve <code>state</code>'te yapılacak değişiklikleri içeren bir nesne döner.</p>
<pre><code class="language-javascript">static getDerivedStateFromProps(props, state) {
  if (props.resetCount) {
    return {
      count: 0,
    };
  }
  return null;
}
</code></pre>
<h3 id="3-render"><a class="header" href="#3-render">3. render()</a></h3>
<p><strong><code>render()</code></strong> yöntemi gereklidir ve HTML'yi DOM'a gerçekten çıktısını veren yöntemdir.</p>
<pre><code class="language-javascript">render() {
  return (
    &lt;div&gt;
      &lt;h1&gt;{this.state.count}&lt;/h1&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="4-componentdidmount"><a class="header" href="#4-componentdidmount">4. componentDidMount()</a></h3>
<p><strong><code>componentDidMount()</code></strong> yöntemi, bileşen render edildikten sonra çağrılır. Bu yöntem, DOM'a erişim veya bir API çağrısı gibi yan etkiler oluşturmak için idealdir.</p>
<pre><code class="language-javascript">componentDidMount() {
  fetch('https://api.example.com/data')
    .then(response =&gt; response.json())
    .then(data =&gt; this.setState({ data }));
}
</code></pre>
<h2 id="sonuç-25"><a class="header" href="#sonuç-25">Sonuç</a></h2>
<p>React bileşenlerinin montaj aşaması, bileşenlerin DOM'a eklenmeden önce ve eklendikten hemen sonra çağrılan belirli yaşam döngüsü yöntemlerini içerir. Bu yöntemler, bileşenin başlangıç durumunu ayarlamak, bileşeni DOM'a eklemek ve gerekli yan etkileri yönetmek için kullanılır. Bu eğitimde, her yöntemin ne zaman ve nasıl kullanıldığını örneklerle inceledik.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-bileşeni-demonstrasyon"><a class="header" href="#react-bileşeni-demonstrasyon">React Bileşeni Demonstrasyon</a></h1>
<p>Bu eğitimde, React bileşeninin montaj aşamalarını adım adım ele alacağız. Her adımda ilgili kod parçacıklarını ve açıklamalarını bulacaksınız. Bu sayede bileşenin montaj(Mounting) sürecini ve bu süreçte kullanılan lifecycle metodlarını derinlemesine anlamış olacaksınız.</p>
<h2 id="1-yeni-dosya-oluşturma"><a class="header" href="#1-yeni-dosya-oluşturma">1. Yeni Dosya Oluşturma</a></h2>
<p>Öncelikle, <code>components</code> klasörü içinde <code>MountingExample.jsx</code> adında yeni bir dosya oluşturun.</p>
<h2 id="2-gerekli-modülleri-İçe-aktarma"><a class="header" href="#2-gerekli-modülleri-İçe-aktarma">2. Gerekli Modülleri İçe Aktarma</a></h2>
<p><code>MountingExample.jsx</code> dosyasında gerekli modülleri içe aktararak başlayın:</p>
<pre><code class="language-jsx">import React, { Component } from 'react';
</code></pre>
<h2 id="3-sınıf-bileşeni-oluşturma"><a class="header" href="#3-sınıf-bileşeni-oluşturma">3. Sınıf Bileşeni Oluşturma</a></h2>
<p><code>Component</code> sınıfını genişleten <code>MountingExample</code> adında bir sınıf bileşeni oluşturun:</p>
<pre><code class="language-jsx">class MountingExample extends Component {
  constructor(props) {
    super(props);
    this.state = {
      text: ''
    };
    console.log('constructor');
  }

  static getDerivedStateFromProps(props, state) {
    console.log('getDerivedStateFromProps');
    if (props.inputText !== state.text) {
      return {
        text: props.inputText
      };
    }
    return null;
  }

  render() {
    console.log('render');
    return (
      &lt;div&gt;
        &lt;p&gt;{this.state.text}&lt;/p&gt;
      &lt;/div&gt;
    );
  }

  componentDidMount() {
    console.log('componentDidMount');
  }
}

export default MountingExample;
</code></pre>
<h2 id="4-montaj-aşamalarının-açıklaması"><a class="header" href="#4-montaj-aşamalarının-açıklaması">4. Montaj Aşamalarının Açıklaması</a></h2>
<p>Bu örnekte, <code>MountingExample</code> bileşeni render edildiğinde montaj aşamaları sırasıyla şu şekilde gerçekleşir:</p>
<ol>
<li><strong>constructor</strong>: Bileşen oluşturulurken çalışır ve başlangıç durumu (<code>state</code>) tanımlar.</li>
<li><strong>getDerivedStateFromProps</strong>: Bileşen, props'lardan türetilmiş durumu günceller.</li>
<li><strong>render</strong>: Bileşen, JSX'i DOM'a render eder.</li>
<li><strong>componentDidMount</strong>: Bileşen, DOM'a monte edildikten hemen sonra çalışır.</li>
</ol>
<p>Her aşama, bileşenin yaşam döngüsünün önemli bir parçasıdır ve sırasıyla çağrılarak bileşenin doğru şekilde monte edilmesini sağlar.</p>
<h2 id="5-bileşeni-kullanma"><a class="header" href="#5-bileşeni-kullanma">5. Bileşeni Kullanma</a></h2>
<p><code>App.js</code> dosyasında <code>MountingExample</code> bileşenini kullanarak montaj aşamalarını gözlemleyin:</p>
<pre><code class="language-jsx">import React from 'react';
import MountingExample from './components/MountingExample';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;MountingExample inputText="Hello, React!" /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<h2 id="sonuç-26"><a class="header" href="#sonuç-26">Sonuç</a></h2>
<p>Bu örneği çalıştırdığınızda, montaj aşamalarının sırasıyla konsola loglandığını göreceksiniz:</p>
<pre><code>constructor
getDerivedStateFromProps
render
componentDidMount
</code></pre>
<h2 id="cheatsheet"><a class="header" href="#cheatsheet">Cheatsheet</a></h2>
<ul>
<li><strong>constructor</strong>: Başlangıç durumunu (<code>state</code>) tanımlar.</li>
<li><strong>getDerivedStateFromProps</strong>: Props'lardan türetilmiş durumu günceller.</li>
<li><strong>render</strong>: JSX'i DOM'a render eder.</li>
<li><strong>componentDidMount</strong>: Bileşen, DOM'a monte edildikten sonra çalışır.</li>
</ul>
<p>Bu eğitim, React bileşenlerinin montaj sürecini anlamanızı ve ilgili lifecycle metodlarını doğru şekilde kullanmanızı sağlamayı amaçlamaktadır. React'te başarılı ve verimli uygulamalar geliştirmek için bu lifecycle metodlarını nasıl ve ne zaman kullanmanız gerektiğini bilmek önemlidir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating"><a class="header" href="#updating">Updating</a></h1>
<p>Bu eğitimde, React bileşenlerinin güncelleme döngüsünü ve bu süreçte kullanılan yaşam döngüsü yöntemlerini ele alacağız. İçeriğin ciddi ve bilimsel olmasına dikkat edeceğiz ve yazılım geliştirme alanında beklenen titizlik ve standartları yansıtacağız. Eğitim boyunca iyi yapılandırılmış kod parçacıkları ile konuyu açıklayacağız.</p>
<h3 id="1-bileşen-güncellenmesi"><a class="header" href="#1-bileşen-güncellenmesi">1. Bileşen Güncellenmesi</a></h3>
<p>Bir bileşen, durumunda (state) veya özelliklerinde (props) bir değişiklik olduğunda güncellenir. React, bir bileşen güncellendiğinde sırayla çağrılan beş yerleşik metoda sahiptir:</p>
<ol>
<li><code>getDerivedStateFromProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><code>render()</code></li>
<li><code>getSnapshotBeforeUpdate()</code></li>
<li><code>componentDidUpdate()</code></li>
</ol>
<p>Bu metotlar, bileşenin güncellenme sürecini yönetir.</p>
<h3 id="2-yaşam-döngüsü-metotları"><a class="header" href="#2-yaşam-döngüsü-metotları">2. Yaşam Döngüsü Metotları</a></h3>
<p><strong>getDerivedStateFromProps</strong>
Bileşen güncellenirken çağrılan ilk metottur. Bu metod, bileşenin yeni özelliklerine göre durumunu güncelleyebilir.</p>
<pre><code class="language-javascript">static getDerivedStateFromProps(nextProps, prevState) {
  // Yeni props'lara göre state'i güncelle
  if (nextProps.someValue !== prevState.someValue) {
    return { someValue: nextProps.someValue };
  }
  return null;
}
</code></pre>
<p><strong>shouldComponentUpdate</strong>
Bu metod, React'in bileşeni yeniden render edip etmeyeceğini belirler. Boolean bir değer döner.</p>
<pre><code class="language-javascript">shouldComponentUpdate(nextProps, nextState) {
  // Render edilip edilmeyeceğini belirle
  return nextProps.someValue !== this.props.someValue;
}
</code></pre>
<p><strong>render</strong>
Bileşen güncellendiğinde HTML'i yeniden DOM'a render eder. Bu metod her zaman çağrılır ve zorunludur.</p>
<pre><code class="language-javascript">render() {
  return (
    &lt;div&gt;
      {this.state.someValue}
    &lt;/div&gt;
  );
}
</code></pre>
<p><strong>getSnapshotBeforeUpdate</strong>
Bu metod, bileşen güncellenmeden önceki props ve state'e erişim sağlar. Güncellemeden sonra bile önceki değerleri kontrol etmek mümkündür.</p>
<pre><code class="language-javascript">getSnapshotBeforeUpdate(prevProps, prevState) {
  // Güncelleme öncesi değerleri al
  return { previousValue: prevProps.someValue };
}
</code></pre>
<p><strong>componentDidUpdate</strong>
Bu metod, bileşen DOM'da güncellendikten sonra çağrılır. Yan etkileri yönetmek için kullanılabilir.</p>
<pre><code class="language-javascript">componentDidUpdate(prevProps, prevState, snapshot) {
  // Bileşen güncellendi
  if (prevProps.someValue !== this.props.someValue) {
    document.title = `Updated to ${this.props.someValue}`;
  }
}
</code></pre>
<h3 id="3-fonksiyonel-bileşenlerde-güncelleme"><a class="header" href="#3-fonksiyonel-bileşenlerde-güncelleme">3. Fonksiyonel Bileşenlerde Güncelleme</a></h3>
<p>Fonksiyonel bileşenlerde <code>componentDidUpdate</code> metodunun davranışını <code>useEffect</code> kancası ile taklit edebiliriz. <code>useEffect</code>, yan etkileri yönetmek için kullanılır ve bağımlılıklar değiştiğinde her render'dan sonra çalışır.</p>
<pre><code class="language-javascript">import React, { useEffect } from 'react';

function MyComponent({ someValue }) {
  useEffect(() =&gt; {
    // componentDidUpdate benzeri
    document.title = `Updated to ${someValue}`;
  }, [someValue]);

  return (
    &lt;div&gt;
      {someValue}
    &lt;/div&gt;
  );
}
</code></pre>
<p><code>useEffect</code> kancasının kullanımına dikkat edelim:</p>
<ul>
<li>Boş bir dizi <code>[]</code> geçirirsek, etki fonksiyonu sadece ilk render'dan sonra çalışır (<code>componentDidMount</code> benzeri).</li>
<li>Hiç dizi geçmezsek, etki fonksiyonu her render'dan sonra çalışır (<code>componentDidMount</code> + <code>componentDidUpdate</code> benzeri).</li>
<li>Dizi içinde bazı değerler geçirirsek, bu değerler değiştiğinde etki fonksiyonu çalışır.</li>
</ul>
<h3 id="sonuç-27"><a class="header" href="#sonuç-27">Sonuç</a></h3>
<p>Bu eğitimde, React bileşenlerinin güncelleme döngüsünü ve bu süreçte kullanılan yaşam döngüsü yöntemlerini inceledik. Detaylı açıklamalar ve kod örnekleri ile konuyu pekiştirdik. React bileşenlerinin güncellenme sürecini anlamak, performans optimizasyonları ve doğru uygulama geliştirme için kritik öneme sahiptir.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-komponentlerinin-unmount-yapılması"><a class="header" href="#react-komponentlerinin-unmount-yapılması">React Komponentlerinin Unmount Yapılması</a></h1>
<p>Bu bölümde, React komponentlerinin DOM'dan kaldırıldığı aşama olan <strong>unmounting</strong> sürecini ele alacağız. React, bir komponent unmount edildiğinde çağrılan yalnızca bir yerleşik metoda sahiptir: <code>componentWillUnmount()</code>.</p>
<h2 id="class-komponentlerde-unmounting"><a class="header" href="#class-komponentlerde-unmounting">Class Komponentlerde Unmounting</a></h2>
<p>Class komponentlerde, <code>componentWillUnmount()</code> metodu, komponent DOM'dan kaldırıldığında çağrılır. Bu metod genellikle bellek sızıntılarını önlemek için kaynakları temizlemek amacıyla kullanılır. Aşağıdaki örnek, <code>Timer</code> komponentinin <code>componentWillUnmount()</code> metodunu kullanarak her saniye artan bir sayaç durumunu nasıl temizlediğini göstermektedir:</p>
<pre><code class="language-jsx">import React, { Component } from 'react';

class Timer extends Component {
  constructor(props) {
    super(props);
    this.state = { seconds: 0 };
  }

  componentDidMount() {
    this.interval = setInterval(() =&gt; this.setState({
      seconds: this.state.seconds + 1
    }), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  render() {
    return (
      &lt;div&gt;Seconds: {this.state.seconds}&lt;/div&gt;
    );
  }
}

export default Timer;
</code></pre>
<p>Bu örnekte, <code>Timer</code> komponenti, <code>componentDidMount()</code> metodunda her saniye <code>seconds</code> durumunu artırmak için bir interval kurar. Komponent DOM'dan kaldırıldığında <code>componentWillUnmount()</code> metodu çağrılır ve bu interval temizlenir, böylece bellek sızıntıları önlenir.</p>
<h2 id="fonksiyonel-komponentlerde-unmounting"><a class="header" href="#fonksiyonel-komponentlerde-unmounting">Fonksiyonel Komponentlerde Unmounting</a></h2>
<p>Fonksiyonel komponentlerde, unmounting işlemi <code>useEffect</code> hook'u kullanılarak ele alınır. <code>useEffect</code> callback'inden bir fonksiyon döndürdüğünüzde, bu fonksiyon komponent unmount edildiğinde çağrılacak bir temizlik fonksiyonu olarak görev yapar. Aşağıdaki örnek, <code>Timer</code> fonksiyonel komponentinin <code>useEffect</code> kullanarak her saniye artan bir sayaç durumunu nasıl temizlediğini göstermektedir:</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from 'react';

const Timer = () =&gt; {
  const [seconds, setSeconds] = useState(0);

  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setSeconds(seconds =&gt; seconds + 1);
    }, 1000);

    return () =&gt; clearInterval(interval);
  }, []);

  return (
    &lt;div&gt;Seconds: {seconds}&lt;/div&gt;
  );
}

export default Timer;
</code></pre>
<p>Bu örnekte, <code>Timer</code> fonksiyonel komponenti, <code>useEffect</code> kullanarak her saniye <code>seconds</code> durumunu artırmak için bir interval kurar. <code>useEffect</code> callback'inden döndürülen temizlik fonksiyonu, komponent unmount edildiğinde intervali temizler, böylece bellek sızıntıları önlenir.</p>
<h2 id="sonuç-28"><a class="header" href="#sonuç-28">Sonuç</a></h2>
<p>React'te unmounting işlemi, hem class hem de fonksiyonel komponentlerde kaynakların doğru şekilde temizlenmesi açısından kritik öneme sahiptir. <code>componentWillUnmount()</code> metodu veya <code>useEffect</code> hook'u kullanarak, komponentlerinizin DOM'dan kaldırıldığında bellek sızıntılarına neden olmasını önleyebilirsiniz. Bu yöntemler, yazılım geliştirme sürecinde yüksek performans ve bellek verimliliği sağlar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ile-pokemon-bulucu-uygulaması"><a class="header" href="#react-ile-pokemon-bulucu-uygulaması">React ile Pokemon Bulucu Uygulaması</a></h1>
<h2 id="pokemon-bulucu"><a class="header" href="#pokemon-bulucu">Pokemon Bulucu</a></h2>
<h2 id="amacı"><a class="header" href="#amacı">Amacı</a></h2>
<p>Bu eğitimde, kullanıcıların Pokemon bilgilerini görüntüleyebileceği ve açık ve koyu modlar arasında geçiş yapabileceği bir web uygulaması geliştireceğiz. Uygulama, React ile sınıf bileşenleri kullanılarak oluşturulacak.</p>
<h2 id="gereksinimler-10"><a class="header" href="#gereksinimler-10">Gereksinimler</a></h2>
<p>Bu eğitimin temel amacı, modern web geliştirme alanında iki önemli konunun anlaşılması ve uygulanmasını teşvik etmektir:</p>
<ol>
<li>
<p>Bir üçüncü taraf web API'sinin (bu durumda Pokemon API) entegrasyonu ve tarayıcıda dinamik olarak veri çekip görüntüleme.</p>
<p><strong>API</strong> - <a href="https://pokeapi.co/api/v2/pokemon?limit=100">https://pokeapi.co/api/v2/pokemon?limit=100</a></p>
</li>
<li>
<p>Kullanıcı deneyimini geliştirmek için açık ve koyu mod geçişi sağlayan bir özellik uygulama.</p>
</li>
</ol>
<h2 id="temel-İşlevsellik"><a class="header" href="#temel-İşlevsellik">Temel İşlevsellik</a></h2>
<ol>
<li>
<p><strong>Pokemon Listesi:</strong></p>
<ul>
<li><strong>pokeapi.co</strong> API'sinden çekilen Pokemon listesini görüntüleyin.</li>
<li>Her Pokemon öğesi bir resim ve adını içermelidir.</li>
</ul>
</li>
<li>
<p><strong>Koyu Mod/Açık Mod Geçişi:</strong></p>
<ul>
<li>Sağ üst köşeye bir geçiş düğmesi/ikonu ekleyin.</li>
<li>Varsayılan tema açık mod olmalıdır.</li>
<li>Açık moddayken, koyu moda geçişi göstermek için bir ay ikonunu görüntüleyin.</li>
<li>Koyu moddayken, açık moda dönmek için bir güneş ikonunu görüntüleyin.</li>
</ul>
</li>
</ol>
<h2 id="teslimat-3"><a class="header" href="#teslimat-3">Teslimat</a></h2>
<ol>
<li>React projenizi barındırmak için bir GitHub deposu oluşturun.</li>
<li>Kodunuzu bu depoya gönderin ve yayınlayın.</li>
<li>Uygulamanızın nasıl çalıştırılacağına dair talimatlar içeren bir README dosyası ekleyin.</li>
<li>Netlify veya GitHub Pages gibi bir platform kullanarak web sitenizin canlı demosunu sağlayın.</li>
</ol>
<h2 id="eğitim-İçeriği-2"><a class="header" href="#eğitim-İçeriği-2">Eğitim İçeriği</a></h2>
<h3 id="1-react-projesini-başlatma"><a class="header" href="#1-react-projesini-başlatma">1. React Projesini Başlatma</a></h3>
<pre><code class="language-sh">npx create-react-app pokemon-finder
cd pokemon-finder
npm start
</code></pre>
<h3 id="2-api-entegrasyonu"><a class="header" href="#2-api-entegrasyonu">2. API Entegrasyonu</a></h3>
<pre><code class="language-jsx">import React, { Component } from 'react';

class PokemonList extends Component {
  state = {
    pokemons: [],
    isLoading: true,
    error: null,
  };

  componentDidMount() {
    fetch('https://pokeapi.co/api/v2/pokemon?limit=100')
      .then(response =&gt; response.json())
      .then(data =&gt; {
        this.setState({ pokemons: data.results, isLoading: false });
      })
      .catch(error =&gt; this.setState({ error, isLoading: false }));
  }

  render() {
    const { pokemons, isLoading, error } = this.state;

    if (isLoading) {
      return &lt;p&gt;Yükleniyor...&lt;/p&gt;;
    }

    if (error) {
      return &lt;p&gt;Bir hata oluştu: {error.message}&lt;/p&gt;;
    }

    return (
      &lt;div&gt;
        &lt;ul&gt;
          {pokemons.map((pokemon, index) =&gt; (
            &lt;li key={index}&gt;
              &lt;p&gt;{pokemon.name}&lt;/p&gt;
              &lt;img src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${index + 1}.png`} alt={pokemon.name} /&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  }
}

export default PokemonList;
</code></pre>
<h3 id="3-koyu-modaçık-mod-geçişi"><a class="header" href="#3-koyu-modaçık-mod-geçişi">3. Koyu Mod/Açık Mod Geçişi</a></h3>
<pre><code class="language-jsx">import React, { Component } from 'react';
import './App.css';

class App extends Component {
  state = {
    darkMode: false,
  };

  toggleDarkMode = () =&gt; {
    this.setState(prevState =&gt; ({ darkMode: !prevState.darkMode }));
  };

  render() {
    const { darkMode } = this.state;
    return (
      &lt;div className={darkMode ? 'dark-mode' : 'light-mode'}&gt;
        &lt;nav&gt;
          &lt;button onClick={this.toggleDarkMode}&gt;
            {darkMode ? '🌞' : '🌜'}
          &lt;/button&gt;
        &lt;/nav&gt;
        &lt;PokemonList /&gt;
      &lt;/div&gt;
    );
  }
}

export default App;
</code></pre>
<h3 id="4-css-ile-temalar"><a class="header" href="#4-css-ile-temalar">4. CSS ile Temalar</a></h3>
<pre><code class="language-css">/* App.css */
body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
}

.light-mode {
  background-color: white;
  color: black;
}

.dark-mode {
  background-color: black;
  color: white;
}

nav {
  display: flex;
  justify-content: flex-end;
  padding: 1em;
}

button {
  background: none;
  border: none;
  font-size: 2em;
  cursor: pointer;
}
</code></pre>
<h3 id="5-proje-dosya-yapısı"><a class="header" href="#5-proje-dosya-yapısı">5. Proje Dosya Yapısı</a></h3>
<pre><code>pokemon-finder/
├── public/
│   ├── index.html
│   └── ...
├── src/
│   ├── App.js
│   ├── App.css
│   ├── PokemonList.js
│   └── index.js
├── package.json
└── ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-management-in-react"><a class="header" href="#state-management-in-react">State Management in React</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-prop-drilling"><a class="header" href="#react-prop-drilling">React Prop Drilling</a></h1>
<p>Prop drilling, React'te verilerin bir üst bileşenden daha alt seviyedeki bileşenlere geçirilmesini sağlamak için kullanılan bir tekniktir. Bu eğitimde, prop drilling konseptini ve bu teknikle ilgili sorunları detaylı bir şekilde ele alacağız. Ayrıca, prop drilling'e alternatif olarak kullanılabilecek yöntemlere de değineceğiz. Eğitim boyunca iyi yapılandırılmış kod parçacıkları ekleyeceğiz ve terminolojiye dikkat ederek ciddi ve bilimsel bir dil kullanacağız.</p>
<h2 id="giriş-24"><a class="header" href="#giriş-24">Giriş</a></h2>
<p>Prop drilling, veriyi birkaç ara bileşenin de dahil olduğu bir hiyerarşi boyunca geçirme işlemidir. Bu, veri geçişine ihtiyaç duymayan bileşenler aracılığıyla veri iletmek anlamına gelir. Bu teknik genellikle veriyi daha üst seviyedeki bir bileşenden, bu veriye ihtiyaç duyan daha alt seviyedeki bir bileşene geçirmek için kullanılır.</p>
<h2 id="Örnek-senaryo"><a class="header" href="#Örnek-senaryo">Örnek Senaryo</a></h2>
<p>Basit bir örnek senaryo ile prop drilling'i anlatacağız. Bu senaryoda üç bileşen kullanacağız: Parent, Child ve GrandChild.</p>
<h3 id="adım-1-proje-yapısı"><a class="header" href="#adım-1-proje-yapısı">Adım 1: Proje Yapısı</a></h3>
<p>Öncelikle, projenizin <code>src</code> dizininde bir <code>components</code> klasörü oluşturun (eğer yoksa).</p>
<h3 id="adım-2-parent-bileşeni"><a class="header" href="#adım-2-parent-bileşeni">Adım 2: Parent Bileşeni</a></h3>
<p><code>components</code> klasörü içinde <code>Parent.jsx</code> adlı bir dosya oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React from 'react';
import Child from './Child';

const Parent = () =&gt; {
  const data = 'Hello from Parent';
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Parent Component&lt;/h1&gt;
      &lt;Child data={data} /&gt;
    &lt;/div&gt;
  );
};

export default Parent;
</code></pre>
<h3 id="adım-3-child-bileşeni"><a class="header" href="#adım-3-child-bileşeni">Adım 3: Child Bileşeni</a></h3>
<p><code>components</code> klasörü içinde <code>Child.jsx</code> adlı bir dosya oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React from 'react';
import GrandChild from './GrandChild';

const Child = ({ data }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h2&gt;Child Component&lt;/h2&gt;
      &lt;GrandChild data={data} /&gt;
    &lt;/div&gt;
  );
};

export default Child;
</code></pre>
<h3 id="adım-4-grandchild-bileşeni"><a class="header" href="#adım-4-grandchild-bileşeni">Adım 4: GrandChild Bileşeni</a></h3>
<p><code>components</code> klasörü içinde <code>GrandChild.jsx</code> adlı bir dosya oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React from 'react';

const GrandChild = ({ data }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h3&gt;GrandChild Component&lt;/h3&gt;
      &lt;p&gt;{data}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default GrandChild;
</code></pre>
<h3 id="adım-5-app-bileşeni"><a class="header" href="#adım-5-app-bileşeni">Adım 5: App Bileşeni</a></h3>
<p>Projenizin <code>src</code> klasöründe bulunan <code>App.jsx</code> dosyasını açın ve Parent bileşenini import edin:</p>
<pre><code class="language-jsx">import React from 'react';
import Parent from './components/Parent';

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Parent /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<h3 id="adım-6-projeyi-Çalıştırma"><a class="header" href="#adım-6-projeyi-Çalıştırma">Adım 6: Projeyi Çalıştırma</a></h3>
<p>Projeyi çalıştırmak için terminalden <code>npm start</code> komutunu kullanabilirsiniz.</p>
<pre><code class="language-sh">npm start
</code></pre>
<p>Bu adımlar tamamlandığında, Parent bileşeninde bulunan veri GrandChild bileşeninde görüntülenecektir. Veri akışı şu şekildedir:</p>
<ol>
<li>Parent bileşeni bazı veriler içerir.</li>
<li>Parent bileşeni bu veriyi prop olarak Child bileşenine geçirir.</li>
<li>Child bileşeni veriyi alır ancak kullanmaz. Bunun yerine, veriyi prop olarak GrandChild bileşenine geçirir.</li>
<li>GrandChild bileşeni veriyi alır ve görüntüler.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-context-api"><a class="header" href="#react-context-api">React Context API</a></h1>
<h4 id="giriş-25"><a class="header" href="#giriş-25">Giriş</a></h4>
<p>React Context API, React kütüphanesi tarafından sağlanan ve bileşenler arasında veri veya durum paylaşımını, props (özellik) geçişi yapmadan sağlayan bir özelliktir. Props drilling olarak bilinen bu durum, bir bileşenden diğerine props geçişi yaparak derin bileşen ağaçlarında veri taşımak gerektiğinde ortaya çıkar. Context API, bu problemi çözmek için kullanılır.</p>
<p>Context API'nin ana bileşenleri şunlardır:</p>
<ol>
<li><strong>Context</strong>: <code>createContext()</code> fonksiyonu ile oluşturulur ve bileşenler arasında paylaşılacak veriyi tutar.</li>
<li><strong>Provider</strong>: <code>Context.Provider</code> bileşeni, paylaşılan veriye erişmesi gereken bileşen ağacının bir kısmını sarmalar. <code>value</code> prop'u ile çocuk bileşenlere paylaşılacak veriyi içerir.</li>
<li><strong>Consumer</strong>: <code>Context.Consumer</code> bileşeni, çocuk bileşenlerde paylaşılan veriye erişmek için kullanılır. Alternatif olarak, fonksiyonel bileşenlerde aynı amacı gerçekleştirmek için <code>useContext</code> hook'u kullanılabilir.</li>
</ol>
<h3 id="adım-adım-uygulama-5"><a class="header" href="#adım-adım-uygulama-5">Adım Adım Uygulama</a></h3>
<p>Bu eğitimde, props drilling problemini React Context API kullanarak nasıl çözeceğimizi adım adım inceleyeceğiz.</p>
<h4 id="adım-1-context-oluşturma"><a class="header" href="#adım-1-context-oluşturma">Adım 1: Context Oluşturma</a></h4>
<p>Öncelikle, bileşenler arasında paylaşmak istediğiniz veri için bir context oluşturun. Projenizin <code>src</code> klasöründe yeni bir dosya oluşturun ve adını <code>DataContext.jsx</code> olarak belirleyin. Aşağıdaki kodu bu dosyaya ekleyin:</p>
<pre><code class="language-jsx">import React, { createContext } from 'react';

export const DataContext = createContext();
</code></pre>
<p>Bu kod, veriyi tutacak yeni bir context oluşturur.</p>
<h4 id="adım-2-provider-kullanımı"><a class="header" href="#adım-2-provider-kullanımı">Adım 2: Provider Kullanımı</a></h4>
<p><code>Parent.jsx</code> bileşenini güncelleyerek <code>DataContext.Provider</code> kullanın ve <code>Child</code> bileşenini sarmalayın, veriyi <code>value</code> prop'u ile geçirin:</p>
<pre><code class="language-jsx">import React from 'react';
import { DataContext } from './DataContext';
import Child from './Child';

const Parent = () =&gt; {
  const data = "Paylaşılan Veri";

  return (
    &lt;DataContext.Provider value={data}&gt;
      &lt;Child /&gt;
    &lt;/DataContext.Provider&gt;
  );
};

export default Parent;
</code></pre>
<h4 id="adım-3-props-geçişini-kaldırma"><a class="header" href="#adım-3-props-geçişini-kaldırma">Adım 3: Props Geçişini Kaldırma</a></h4>
<p><code>Child.jsx</code> bileşenini, gereksiz props geçişini kaldıracak şekilde güncelleyin. Context API kullanıldığında, <code>Child</code> bileşeninin artık veriyi props olarak almasına gerek yoktur:</p>
<pre><code class="language-jsx">import React from 'react';
import GrandChild from './GrandChild';

const Child = () =&gt; {
  return (
    &lt;div&gt;
      &lt;GrandChild /&gt;
    &lt;/div&gt;
  );
};

export default Child;
</code></pre>
<h4 id="adım-4-context-tüketimi"><a class="header" href="#adım-4-context-tüketimi">Adım 4: Context Tüketimi</a></h4>
<p><code>GrandChild.jsx</code> bileşenini güncelleyerek context'ten veri tüketin:</p>
<pre><code class="language-jsx">import React, { useContext } from 'react';
import { DataContext } from './DataContext';

const GrandChild = () =&gt; {
  const data = useContext(DataContext);

  return (
    &lt;div&gt;
      {data}
    &lt;/div&gt;
  );
};

export default GrandChild;
</code></pre>
<h4 id="adım-5-uygulamanın-Çalıştırılması"><a class="header" href="#adım-5-uygulamanın-Çalıştırılması">Adım 5: Uygulamanın Çalıştırılması</a></h4>
<p>Projenizin <code>src</code> klasöründe bulunan <code>App.jsx</code> dosyasını açın ve en üstte <code>Parent</code> bileşenini içe aktararak kullanın:</p>
<pre><code class="language-jsx">import React from 'react';
import Parent from './Parent';

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Parent /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-store-uygulaması-geliştirme"><a class="header" href="#data-store-uygulaması-geliştirme">Data Store Uygulaması Geliştirme</a></h1>
<p>Bu eğitimde, React Context API kullanarak bir Data Store Uygulaması geliştireceğiz ve uygulamamızı Tailwind CSS ile stilize edeceğiz. Bu eğitim kapsamlı ve ayrıntılı olacaktır, her adımı dikkatlice ele alacağız ve yazılım geliştirme alanında beklenen titizlik ve standartları yansıtacağız.</p>
<h3 id="amaç-4"><a class="header" href="#amaç-4"><strong>Amaç:</strong></a></h3>
<p>React Context API kullanarak kullanıcıların bir veri deposuna öğe ekleyip çıkarmalarını sağlayan bir Data Store Uygulaması geliştirin ve uygulamanızı Tailwind CSS ile stilize edin.</p>
<h3 id="gereksinimler-11"><a class="header" href="#gereksinimler-11"><strong>Gereksinimler:</strong></a></h3>
<ol>
<li><strong><code>components</code></strong> klasöründe <strong><code>DataStoreApp</code></strong> adlı yeni bir React bileşeni oluşturun.</li>
<li>Veri deposunu yönetmek için React Context API kullanarak bir context oluşturun.</li>
<li>Veri deposuna yeni öğeler ekleme işlevselliğini uygulayın.</li>
<li>Veri deposundan öğeleri kaldırma işlevselliğini uygulayın.</li>
<li>Uygulamayı temiz ve görsel olarak çekici bir tasarıma ulaşmak için Tailwind CSS sınıflarını kullanarak stilize edin.</li>
</ol>
<h3 id="adım-1-proje-kurulumu-1"><a class="header" href="#adım-1-proje-kurulumu-1"><strong>Adım 1: Proje Kurulumu</strong></a></h3>
<p>İlk olarak, React projemizi oluşturacağız ve gerekli bağımlılıkları yükleyeceğiz. Aşağıdaki adımları izleyin:</p>
<pre><code class="language-bash">npx create-react-app datastore-app
cd datastore-app
npm install tailwindcss@latest postcss@latest autoprefixer@latest
npx tailwindcss init -p
</code></pre>
<p>Tailwind CSS yapılandırmasını <strong><code>tailwind.config.js</code></strong> dosyasında aşağıdaki gibi yapılandırın:</p>
<pre><code class="language-javascript">module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
}
</code></pre>
<p><strong><code>src/index.css</code></strong> dosyasını şu şekilde güncelleyin:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h3 id="adım-2-context-api-kurulumu"><a class="header" href="#adım-2-context-api-kurulumu"><strong>Adım 2: Context API Kurulumu</strong></a></h3>
<p>Veri deposunu yönetmek için bir context oluşturacağız. <strong><code>src/context/DataStoreContext.js</code></strong> dosyasını oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-javascript">import React, { createContext, useState } from 'react';

export const DataStoreContext = createContext();

export const DataStoreProvider = ({ children }) =&gt; {
  const [items, setItems] = useState([]);

  const addItem = (item) =&gt; {
    setItems([...items, item]);
  };

  const removeItem = (item) =&gt; {
    setItems(items.filter(i =&gt; i !== item));
  };

  return (
    &lt;DataStoreContext.Provider value={{ items, addItem, removeItem }}&gt;
      {children}
    &lt;/DataStoreContext.Provider&gt;
  );
};
</code></pre>
<h3 id="adım-3-datastoreapp-bileşenini-oluşturma"><a class="header" href="#adım-3-datastoreapp-bileşenini-oluşturma"><strong>Adım 3: DataStoreApp Bileşenini Oluşturma</strong></a></h3>
<p><strong><code>components/DataStoreApp.js</code></strong> dosyasını oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-javascript">import React, { useContext, useState } from 'react';
import { DataStoreContext } from '../context/DataStoreContext';

const DataStoreApp = () =&gt; {
  const { items, addItem, removeItem } = useContext(DataStoreContext);
  const [newItem, setNewItem] = useState('');

  const handleAddItem = () =&gt; {
    addItem(newItem);
    setNewItem('');
  };

  return (
    &lt;div className="p-4"&gt;
      &lt;h1 className="text-2xl font-bold mb-4"&gt;Data Store Uygulaması&lt;/h1&gt;
      &lt;input
        type="text"
        value={newItem}
        onChange={(e) =&gt; setNewItem(e.target.value)}
        className="border p-2 mr-2"
      /&gt;
      &lt;button
        onClick={handleAddItem}
        className="bg-blue-500 text-white p-2 rounded"
      &gt;
        Ekle
      &lt;/button&gt;
      &lt;ul className="mt-4"&gt;
        {items.map((item, index) =&gt; (
          &lt;li key={index} className="flex justify-between items-center mb-2"&gt;
            {item}
            &lt;button
              onClick={() =&gt; removeItem(item)}
              className="bg-red-500 text-white p-2 rounded"
            &gt;
              Kaldır
            &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default DataStoreApp;
</code></pre>
<h3 id="adım-4-contexti-kullanıma-alma"><a class="header" href="#adım-4-contexti-kullanıma-alma"><strong>Adım 4: Context'i Kullanıma Alma</strong></a></h3>
<p><strong><code>src/App.js</code></strong> dosyasını şu şekilde güncelleyin:</p>
<pre><code class="language-javascript">import React from 'react';
import { DataStoreProvider } from './context/DataStoreContext';
import DataStoreApp from './components/DataStoreApp';

const App = () =&gt; {
  return (
    &lt;DataStoreProvider&gt;
      &lt;div className="container mx-auto"&gt;
        &lt;DataStoreApp /&gt;
      &lt;/div&gt;
    &lt;/DataStoreProvider&gt;
  );
};

export default App;
</code></pre>
<h3 id="adım-5-stilize-etme"><a class="header" href="#adım-5-stilize-etme"><strong>Adım 5: Stilize Etme</strong></a></h3>
<p>Tailwind CSS kullanarak uygulamanızın stilini ayarladık. Sınıfları ihtiyaçlarınıza göre düzenleyebilirsiniz. Örneğin, <strong><code>input</code></strong> ve <strong><code>button</code></strong> öğelerine eklediğimiz sınıflar, temiz ve kullanıcı dostu bir arayüz sağlar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="higher-order-components"><a class="header" href="#higher-order-components">Higher-Order Components</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="react-yüksek-düzey-bileşenler-higher-order-components"><a class="header" href="#react-yüksek-düzey-bileşenler-higher-order-components">React Yüksek-Düzey Bileşenler (Higher-Order Components)</a></h2>
<h3 id="giriş-26"><a class="header" href="#giriş-26">Giriş</a></h3>
<p>Yüksek-Düzey Bileşenler (Higher-Order Components - HOCs), React'te bileşen mantığını yeniden kullanmak için güçlü ve gelişmiş bir tekniktir. Orijinal bileşeni değiştirmeye gerek kalmadan ek işlevsellik veya davranış sağlamak için mevcut bileşenleri sarmalayarak yeni bileşenler oluşturmanıza olanak tanırlar. Bu eğitimde aşağıdaki konuları ele alacağız:</p>
<ol>
<li>Yüksek-Düzey Bileşenler nedir?</li>
<li>Neden Yüksek-Düzey Bileşenler kullanmalısınız?</li>
<li>Bir Yüksek-Düzey Bileşen nasıl oluşturulur?</li>
<li>Yüksek-Düzey Bileşenlerin yaygın kullanım durumları</li>
</ol>
<h3 id="1-yüksek-düzey-bileşenler-nedir"><a class="header" href="#1-yüksek-düzey-bileşenler-nedir">1. Yüksek-Düzey Bileşenler Nedir?</a></h3>
<p>Yüksek-Düzey Bileşen (Higher-Order Component), bir bileşeni argüman olarak alan ve bu bileşene ek işlevsellik ekleyerek yeni bir bileşen döndüren bir fonksiyondur.</p>
<h3 id="2-neden-yüksek-düzey-bileşenler-kullanmalısınız"><a class="header" href="#2-neden-yüksek-düzey-bileşenler-kullanmalısınız">2. Neden Yüksek-Düzey Bileşenler Kullanmalısınız?</a></h3>
<p>Yüksek-Düzey Bileşenler, birden fazla bileşen arasında ortak mantık veya davranış paylaşmak istediğinizde faydalıdır. Bu, kodun daha iyi bakımını, okunabilirliğini ve yeniden kullanılabilirliğini sağlar. Ayrıca, orijinal bileşenin ana sorumluluğuna odaklanmasını sağlayarak kaygıların ayrılmasını teşvik eder.</p>
<h3 id="3-bir-yüksek-düzey-bileşen-nasıl-oluşturulur"><a class="header" href="#3-bir-yüksek-düzey-bileşen-nasıl-oluşturulur">3. Bir Yüksek-Düzey Bileşen Nasıl Oluşturulur?</a></h3>
<p>Bir Yüksek-Düzey Bileşen oluşturmak için, bir bileşeni argüman olarak alan ve bu bileşeni saran yeni bir bileşen döndüren bir fonksiyon tanımlamanız gerekir. İşte basit bir örnek:</p>
<pre><code class="language-javascript">import React from 'react';

const ExampleHOC = (WrappedComponent) =&gt; {
  return class EnhancedComponent extends React.Component {
    render() {
      return &lt;WrappedComponent {...this.props} /&gt;;
    }
  };
};
</code></pre>
<p>Bu örnekte, <code>ExampleHOC</code>, <code>WrappedComponent</code> adlı bileşeni argüman olarak alan ve bu bileşeni saran <code>EnhancedComponent</code> adlı yeni bir işlevsel bileşen döndüren bir HOC'dir. Bu HOC'yi herhangi bir bileşeni sarmalayarak kullanabilirsiniz:</p>
<pre><code class="language-javascript">const SimpleComponent = (props) =&gt; {
  return &lt;div&gt;{props.message}&lt;/div&gt;;
};

const EnhancedSimpleComponent = ExampleHOC(SimpleComponent);

// Kullanım
&lt;EnhancedSimpleComponent message="Hello, World!" /&gt;;
</code></pre>
<h3 id="4-yüksek-düzey-bileşenlerin-yaygın-kullanım-durumları"><a class="header" href="#4-yüksek-düzey-bileşenlerin-yaygın-kullanım-durumları">4. Yüksek-Düzey Bileşenlerin Yaygın Kullanım Durumları</a></h3>
<p>Yüksek-Düzey Bileşenlerin bazı yaygın kullanım durumları şunlardır:</p>
<ul>
<li><strong>Kodun yeniden kullanımı</strong>: Birden fazla bileşen arasında ortak mantığı paylaşma.</li>
<li><strong>Özellikleri değiştirme</strong>: Sarılan bileşene geçirilen özellikleri manipüle etme.</li>
<li><strong>Koşullu render etme</strong>: Belirli koşullara bağlı olarak sarılan bileşeni kontrol etme.</li>
<li><strong>Kimlik doğrulama ve yetkilendirme</strong>: Uygulamanın belirli bölümlerine erişimi kontrol etme.</li>
</ul>
<h3 id="Örnek-kimlik-doğrulama-ile-yüksek-düzey-bileşen"><a class="header" href="#Örnek-kimlik-doğrulama-ile-yüksek-düzey-bileşen">Örnek: Kimlik Doğrulama ile Yüksek-Düzey Bileşen</a></h3>
<p>Aşağıda kimlik doğrulama için bir Yüksek-Düzey Bileşen örneği verilmiştir:</p>
<pre><code class="language-javascript">import React from 'react';
import { Redirect } from 'react-router-dom';

const withAuth = (WrappedComponent) =&gt; {
  return class extends React.Component {
    render() {
      const { isAuthenticated, ...otherProps } = this.props;
      if (!isAuthenticated) {
        return &lt;Redirect to="/login" /&gt;;
      }
      return &lt;WrappedComponent {...otherProps} /&gt;;
    }
  };
};

export default withAuth;
</code></pre>
<p>Bu örnekte, <code>withAuth</code> HOC'si, <code>isAuthenticated</code> özelliğine göre sarılan bileşenin render edilmesini kontrol eder. Kimliği doğrulanmamış kullanıcıları giriş sayfasına yönlendirir.</p>
<pre><code class="language-javascript">// Kullanım
const Dashboard = (props) =&gt; {
  return &lt;div&gt;Dashboard&lt;/div&gt;;
};

const ProtectedDashboard = withAuth(Dashboard);

// Kullanım
&lt;ProtectedDashboard isAuthenticated={true} /&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="higher-order-components-hoc-kullanım-durumları"><a class="header" href="#higher-order-components-hoc-kullanım-durumları">Higher-Order Components (HOC) Kullanım Durumları</a></h1>
<p>Higher-Order Components (HOCs), React'te yaygın olarak kullanılan ve birden fazla bileşen arasında ortak mantığı paylaşmanızı ve yeniden kullanmanızı sağlayan gelişmiş bir desendir. Bu eğitici yazıda, HOC'lerin temel kullanım durumlarını ve her bir kullanım durumuna ait kod örneklerini ele alacağız. İçeriğin ciddi ve bilimsel bir tonla yazıldığını, doğru bilgiye dayalı olduğunu ve yazılım geliştirme alanında beklenen titizlik ve standartları yansıttığını göreceksiniz.</p>
<h2 id="1-kodun-yeniden-kullanımı"><a class="header" href="#1-kodun-yeniden-kullanımı">1. Kodun Yeniden Kullanımı</a></h2>
<p>HOCs'in en temel kullanım durumu, kod tekrarlamasını önlemektir. Aynı mantığı paylaşan birden fazla bileşeniniz varsa, bu mantığı kapsüllemek ve her bileşene uygulamak için bir HOC oluşturabilirsiniz. Bu, mantığın tek bir yerde olmasını ve kolayca yönetilmesini sağlar.</p>
<h3 id="Örnek-kullanıcı-etkileşimlerini-veya-analitik-olaylarını-kaydetme"><a class="header" href="#Örnek-kullanıcı-etkileşimlerini-veya-analitik-olaylarını-kaydetme">Örnek: Kullanıcı Etkileşimlerini veya Analitik Olaylarını Kaydetme</a></h3>
<p>Aşağıda, kullanıcı etkileşimlerini kaydeden bir HOC örneği bulunmaktadır:</p>
<pre><code class="language-jsx">import React, { Component } from 'react';

// HOC tanımı
const withLogging = (WrappedComponent) =&gt; {
  return class extends Component {
    componentDidMount() {
      console.log(`Component ${WrappedComponent.name} mounted.`);
    }

    render() {
      return &lt;WrappedComponent {...this.props} /&gt;;
    }
  };
};

// Örnek bileşen
class Button extends Component {
  render() {
    return &lt;button&gt;{this.props.label}&lt;/button&gt;;
  }
}

// HOC ile sarmalanmış bileşen
const LoggingButton = withLogging(Button);

export default LoggingButton;
</code></pre>
<p>Bu örnekte, <code>withLogging</code> HOC'si, bileşen her yüklendiğinde bir mesaj kaydeder.</p>
<h2 id="2-props-değiştirme"><a class="header" href="#2-props-değiştirme">2. Props Değiştirme</a></h2>
<p>HOC'ler, sarılan bileşene geçilen props'ları değiştirmek için kullanılabilir. Bu, yeni props eklemeyi, gereksiz props'ları kaldırmayı veya mevcut props'ları dönüştürmeyi içerebilir.</p>
<h3 id="Örnek-geçilen-Ölçü-birimlerini-dönüştürme"><a class="header" href="#Örnek-geçilen-Ölçü-birimlerini-dönüştürme">Örnek: Geçilen Ölçü Birimlerini Dönüştürme</a></h3>
<p>Aşağıda, Fahrenheit'ten Celsius'a sıcaklık birimlerini dönüştüren bir HOC örneği bulunmaktadır:</p>
<pre><code class="language-jsx">import React from 'react';

const withUnitConversion = (WrappedComponent) =&gt; {
  return class extends React.Component {
    convertTemperature(fahrenheit) {
      return ((fahrenheit - 32) * 5) / 9;
    }

    render() {
      const { temperature, ...otherProps } = this.props;
      const celsius = this.convertTemperature(temperature);

      return &lt;WrappedComponent temperature={celsius} {...otherProps} /&gt;;
    }
  };
};

// Örnek bileşen
const TemperatureDisplay = ({ temperature }) =&gt; (
  &lt;div&gt;Temperature: {temperature}°C&lt;/div&gt;
);

// HOC ile sarmalanmış bileşen
const ConvertedTemperatureDisplay = withUnitConversion(TemperatureDisplay);

export default ConvertedTemperatureDisplay;
</code></pre>
<p>Bu örnekte, <code>withUnitConversion</code> HOC'si, Fahrenheit olarak verilen sıcaklık değerini Celsius'a dönüştürür ve sarılan bileşene geçirir.</p>
<h2 id="3-koşullu-render-etme"><a class="header" href="#3-koşullu-render-etme">3. Koşullu Render Etme</a></h2>
<p>HOC'ler, belirli koşullara bağlı olarak sarılan bileşenin render edilmesini kontrol etmek için kullanılabilir. Bu, kullanıcı izinlerine veya uygulama durumuna göre bileşenleri gizlemek veya göstermek için yararlı olabilir.</p>
<h3 id="Örnek-veri-getirilirken-yükleniyor-simgesi-gösterme"><a class="header" href="#Örnek-veri-getirilirken-yükleniyor-simgesi-gösterme">Örnek: Veri Getirilirken Yükleniyor Simgesi Gösterme</a></h3>
<p>Aşağıda, veri getirildiğinde yükleniyor simgesi gösteren bir HOC örneği bulunmaktadır:</p>
<pre><code class="language-jsx">import React from 'react';

const withLoading = (WrappedComponent) =&gt; {
  return class extends React.Component {
    render() {
      if (this.props.isLoading) {
        return &lt;div&gt;Loading...&lt;/div&gt;;
      }

      return &lt;WrappedComponent {...this.props} /&gt;;
    }
  };
};

// Örnek bileşen
const DataDisplay = ({ data }) =&gt; (
  &lt;div&gt;Data: {data}&lt;/div&gt;
);

// HOC ile sarmalanmış bileşen
const LoadingDataDisplay = withLoading(DataDisplay);

export default LoadingDataDisplay;
</code></pre>
<p>Bu örnekte, <code>withLoading</code> HOC'si, veri yüklenirken yükleniyor mesajı gösterir ve veri yüklendiğinde sarılan bileşeni render eder.</p>
<h2 id="4-kimlik-doğrulama-ve-yetkilendirme"><a class="header" href="#4-kimlik-doğrulama-ve-yetkilendirme">4. Kimlik Doğrulama ve Yetkilendirme</a></h2>
<p>HOC'ler, uygulamanızın belirli kısımlarına erişimi kontrol etmek için kullanılabilir. Kullanıcının kimlik doğrulamasını veya belirli izinlere sahip olup olmadığını kontrol eden bir HOC oluşturabilir ve bileşeni buna göre render edebilirsiniz.</p>
<h3 id="Örnek-sadece-giriş-yapmış-kullanıcıların-erişebilmesi"><a class="header" href="#Örnek-sadece-giriş-yapmış-kullanıcıların-erişebilmesi">Örnek: Sadece Giriş Yapmış Kullanıcıların Erişebilmesi</a></h3>
<p>Aşağıda, sadece giriş yapmış kullanıcıların erişebileceği bir HOC örneği bulunmaktadır:</p>
<pre><code class="language-jsx">import React from 'react';
import { Redirect } from 'react-router-dom';

const withAuth = (WrappedComponent) =&gt; {
  return class extends React.Component {
    render() {
      if (!this.props.isAuthenticated) {
        return &lt;Redirect to="/login" /&gt;;
      }

      return &lt;WrappedComponent {...this.props} /&gt;;
    }
  };
};

// Örnek bileşen
const ProtectedComponent = () =&gt; (
  &lt;div&gt;This is a protected component.&lt;/div&gt;
);

// HOC ile sarmalanmış bileşen
const AuthProtectedComponent = withAuth(ProtectedComponent);

export default AuthProtectedComponent;
</code></pre>
<p>Bu örnekte, <code>withAuth</code> HOC'si, kullanıcı kimliği doğrulanmamışsa giriş sayfasına yönlendirir ve kimliği doğrulanmışsa sarılan bileşeni render eder.</p>
<h2 id="5-hata-yönetimi"><a class="header" href="#5-hata-yönetimi">5. Hata Yönetimi</a></h2>
<p>HOC'ler, hataları ele almak ve uygulamanız genelinde hata mesajlarını veya yedek kullanıcı arayüzü bileşenlerini tutarlı bir şekilde görüntülemek için kullanılabilir.</p>
<h3 id="Örnek-veri-getirilirken-hataları-yakalama-ve-gösterme"><a class="header" href="#Örnek-veri-getirilirken-hataları-yakalama-ve-gösterme">Örnek: Veri Getirilirken Hataları Yakalama ve Gösterme</a></h3>
<p>Aşağıda, veri getirilirken hataları yakalayan ve gösteren bir HOC örneği bulunmaktadır:</p>
<pre><code class="language-jsx">import React from 'react';

const withErrorHandling = (WrappedComponent) =&gt; {
  return class extends React.Component {
    state = {
      hasError: false,
      error: null,
    };

    componentDidCatch(error, info) {
      this.setState({ hasError: true, error });
    }

    render() {
      if (this.state.hasError) {
        return &lt;div&gt;Error: {this.state.error.message}&lt;/div&gt;;
      }

      return &lt;WrappedComponent {...this.props} /&gt;;
    }
  };
};

// Örnek bileşen
const DataComponent = ({ data }) =&gt; (
  &lt;div&gt;Data: {data}&lt;/div&gt;
);

// HOC ile sarmalanmış bileşen
const ErrorHandledDataComponent = withErrorHandling(DataComponent);

export default ErrorHandledDataComponent;
</code></pre>
<p>Bu örnekte, <code>withErrorHandling</code> HOC'si, veri getirilirken oluşan hataları yakalar ve hata mesajını gösterir.</p>
<p>Bu eğitimde, HOC'lerin React uygulamalarında nasıl kullanıldığını ve yaygın kullanım durumlarını ele aldık. Her bir örnek, HOC'lerin çeşitli durumlarda nasıl uygulanabileceğini ve uygulamanızdaki bileşenlerin işlevselliğini nasıl artırabileceğini göstermektedir. Bu yöntemler, React projelerinizde daha temiz ve sürdürülebilir kod yazmanıza yardımcı olacaktır.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ile-higher-order-component-hoc-oluşturma-eğitimi"><a class="header" href="#react-ile-higher-order-component-hoc-oluşturma-eğitimi">React ile Higher-Order Component (HOC) Oluşturma Eğitimi</a></h1>
<p>Bu eğitimde, kullanıcıların yalnızca kimlik doğrulaması yapıldığında gizli bir mesajı görebileceği bir senaryo oluşturmayı hedefleyeceğiz. Bu doğrulama kontrolünü gerçekleştirmek ve gizli mesaj bileşenini koşullu olarak render etmek için bir Higher-Order Component (HOC) kullanacağız.</p>
<h2 id="hedef"><a class="header" href="#hedef">Hedef</a></h2>
<p>Bir kullanıcının yalnızca kimlik doğrulaması yapıldığında bir gizli mesajı görebileceği bir senaryo oluşturmak. Bu doğrulama kontrolünü yönetmek ve gizli mesaj bileşenini koşullu olarak render etmek için bir HOC kullanacağız.</p>
<h2 id="akış"><a class="header" href="#akış">Akış</a></h2>
<ol>
<li><code>components</code> klasörünü oluşturun (zaten mevcut değilse).</li>
<li><code>SecretMessage.jsx</code> bileşenini oluşturun.</li>
<li><code>WithAuthentication.js</code> HOC'sini oluşturun.</li>
<li><code>SecretMessage</code> bileşenini <code>WithAuthentication</code> HOC'si ile sarın.</li>
<li>Kimlik doğrulama durumunu değiştirerek HOC'nin davranışını test edin.</li>
</ol>
<p>Bu adım adım örnekte, kullanıcı kimlik doğrulama durumuna göre bir bileşeni gösteren veya gizleyen bir HOC kullanarak basit bir React uygulaması oluşturacağız.</p>
<h3 id="adım-1-components-klasörünü-oluşturma"><a class="header" href="#adım-1-components-klasörünü-oluşturma">Adım 1: <code>components</code> Klasörünü Oluşturma</a></h3>
<p>Öncelikle, <code>src</code> dizininde bir <code>components</code> klasörü oluşturun (eğer zaten mevcut değilse).</p>
<pre><code class="language-sh">mkdir src/components
</code></pre>
<h3 id="adım-2-secretmessagejsx-bileşenini-oluşturma"><a class="header" href="#adım-2-secretmessagejsx-bileşenini-oluşturma">Adım 2: <code>SecretMessage.jsx</code> Bileşenini Oluşturma</a></h3>
<p><code>components</code> klasöründe, gizli bir mesajı görüntüleyecek olan <code>SecretMessage.jsx</code> bileşenini oluşturun.</p>
<pre><code class="language-jsx">// src/components/SecretMessage.jsx
import React from 'react';

const SecretMessage = () =&gt; {
    return (
        &lt;div&gt;
            &lt;h1&gt;Bu bir gizli mesajdır!&lt;/h1&gt;
        &lt;/div&gt;
    );
};

export default SecretMessage;
</code></pre>
<h3 id="adım-3-withauthenticationjs-hocsini-oluşturma"><a class="header" href="#adım-3-withauthenticationjs-hocsini-oluşturma">Adım 3: <code>WithAuthentication.js</code> HOC'sini Oluşturma</a></h3>
<p><code>components</code> klasöründe, kullanıcının kimlik doğrulamasını kontrol edecek ve <code>WrappedComponent</code> veya kimliği doğrulanmamış kullanıcılar için bir mesaj render edecek olan <code>WithAuthentication.js</code> HOC'sini oluşturun.</p>
<pre><code class="language-jsx">// src/components/WithAuthentication.js
import React from 'react';

const withAuthentication = (WrappedComponent) =&gt; {
    return class extends React.Component {
        render() {
            const isAuthenticated = this.props.isAuthenticated;
            if (isAuthenticated) {
                return &lt;WrappedComponent {...this.props} /&gt;;
            } else {
                return &lt;div&gt;Lütfen gizli mesajı görmek için giriş yapın.&lt;/div&gt;;
            }
        }
    };
};

export default withAuthentication;
</code></pre>
<h3 id="adım-4-secretmessage-bileşenini-withauthentication-hocsi-ile-sarma"><a class="header" href="#adım-4-secretmessage-bileşenini-withauthentication-hocsi-ile-sarma">Adım 4: <code>SecretMessage</code> Bileşenini <code>WithAuthentication</code> HOC'si ile Sarma</a></h3>
<p><code>App.js</code> dosyasında <code>SecretMessage</code> bileşenini <code>withAuthentication</code> HOC'si ile sarın.</p>
<pre><code class="language-jsx">// src/App.js
import React from 'react';
import SecretMessage from './components/SecretMessage';
import withAuthentication from './components/WithAuthentication';

const SecretMessageWithAuth = withAuthentication(SecretMessage);

class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            isAuthenticated: false
        };
    }

    toggleAuth = () =&gt; {
        this.setState({ isAuthenticated: !this.state.isAuthenticated });
    };

    render() {
        return (
            &lt;div&gt;
                &lt;button onClick={this.toggleAuth}&gt;
                    {this.state.isAuthenticated ? 'Çıkış Yap' : 'Giriş Yap'}
                &lt;/button&gt;
                &lt;SecretMessageWithAuth isAuthenticated={this.state.isAuthenticated} /&gt;
            &lt;/div&gt;
        );
    }
}

export default App;
</code></pre>
<h3 id="adım-5-hocnin-davranışını-test-etme"><a class="header" href="#adım-5-hocnin-davranışını-test-etme">Adım 5: HOC'nin Davranışını Test Etme</a></h3>
<p><code>App.js</code> dosyasında <code>isAuthenticated</code> değerini değiştirerek HOC'nin davranışını test edin.</p>
<ul>
<li><code>isAuthenticated</code> değerini <code>true</code> yapın ve gizli mesajın görüntülenip görüntülenmediğini kontrol edin.</li>
<li><code>isAuthenticated</code> değerini <code>false</code> yapın ve "Lütfen gizli mesajı görmek için giriş yapın." mesajının görüntülenip görüntülenmediğini kontrol edin.</li>
</ul>
<pre><code class="language-sh"># Uygulamayı çalıştırın
npm start
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="movie-list-app"><a class="header" href="#movie-list-app">Movie List App</a></h1>
<h4 id="amaç-5"><a class="header" href="#amaç-5"><strong>Amaç:</strong></a></h4>
<p>Bu eğitimin amacı, React'te Üst Düzey Bileşenlerin (HOC) kullanımını uygulamak, <strong>CSS ile stil oluşturmak</strong> ve bir <strong>API'den veri çekmektir.</strong> Yeniden kullanılabilir HOC'lar oluşturacak, bunları bir React uygulamasında uygulayacak ve sağlanan API'den verileri göstereceksiniz.</p>
<p><strong>API -</strong> <a href="https://my-json-server.typicode.com/horizon-code-academy/fake-movies-api/movies">Fake Movies API</a></p>
<h4 id="gereksinimler-12"><a class="header" href="#gereksinimler-12">Gereksinimler:</a></h4>
<ol>
<li>Bu ödev için yeni bir React uygulaması oluşturun veya mevcut bir uygulamayı kullanın.</li>
<li>Sağlanan API'den film verilerini çeken ve film listesini dinamik olarak görüntüleyen bir <strong><code>MovieList</code></strong> bileşeni oluşturun.</li>
<li>Film kartlarını CSS kullanarak hoş bir düzen oluşturacak şekilde stilize edin.</li>
<li>Film verileri çekilirken <strong>yükleme bileşeni</strong> ekleyin. Bu bileşen, verilerin yüklendiğini belirten görsel geri bildirim sağlar.</li>
<li>Veriler çekildikten sonra film listesi ekranda görüntülenecektir.</li>
<li>Duyarlı tasarımı uygulayın.</li>
<li>Uygulamayı bir web tarayıcısında test ederek film listesinin doğru görüntülendiğini ve stilin uygulandığını doğrulayın.</li>
</ol>
<h3 id="adım-adım-eğitim"><a class="header" href="#adım-adım-eğitim">Adım Adım Eğitim</a></h3>
<h4 id="1-react-uygulaması-oluşturma"><a class="header" href="#1-react-uygulaması-oluşturma">1. React Uygulaması Oluşturma</a></h4>
<pre><code class="language-bash">npx create-react-app movie-list-app
cd movie-list-app
</code></pre>
<h4 id="2-gerekli-dosyaları-ve-bileşenleri-oluşturma"><a class="header" href="#2-gerekli-dosyaları-ve-bileşenleri-oluşturma">2. Gerekli Dosyaları ve Bileşenleri Oluşturma</a></h4>
<p><code>src</code> klasöründe <code>components</code> adında bir klasör oluşturun ve aşağıdaki dosyaları ekleyin:</p>
<ul>
<li><code>MovieList.js</code></li>
<li><code>MovieCard.js</code></li>
<li><code>Loading.js</code></li>
<li><code>withLoading.js</code></li>
</ul>
<h4 id="3-movielist-bileşenini-oluşturma"><a class="header" href="#3-movielist-bileşenini-oluşturma">3. <code>MovieList</code> Bileşenini Oluşturma</a></h4>
<pre><code class="language-javascript">// src/components/MovieList.js
import React, { useEffect, useState } from 'react';
import MovieCard from './MovieCard';
import withLoading from './withLoading';

const MovieList = ({ isLoading, setLoading }) =&gt; {
  const [movies, setMovies] = useState([]);

  useEffect(() =&gt; {
    setLoading(true);
    fetch('https://my-json-server.typicode.com/horizon-code-academy/fake-movies-api/movies')
      .then(response =&gt; response.json())
      .then(data =&gt; {
        setMovies(data);
        setLoading(false);
      });
  }, [setLoading]);

  return (
    &lt;div className="movie-list"&gt;
      {movies.map(movie =&gt; (
        &lt;MovieCard key={movie.id} movie={movie} /&gt;
      ))}
    &lt;/div&gt;
  );
};

export default withLoading(MovieList);
</code></pre>
<h4 id="4-moviecard-bileşenini-oluşturma"><a class="header" href="#4-moviecard-bileşenini-oluşturma">4. <code>MovieCard</code> Bileşenini Oluşturma</a></h4>
<pre><code class="language-javascript">// src/components/MovieCard.js
import React from 'react';
import './MovieCard.css';

const MovieCard = ({ movie }) =&gt; {
  return (
    &lt;div className="movie-card"&gt;
      &lt;img src={movie.poster} alt={movie.title} /&gt;
      &lt;div className="movie-info"&gt;
        &lt;h3&gt;{movie.title}&lt;/h3&gt;
        &lt;p&gt;{movie.description}&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default MovieCard;
</code></pre>
<h4 id="5-loading-bileşenini-oluşturma"><a class="header" href="#5-loading-bileşenini-oluşturma">5. <code>Loading</code> Bileşenini Oluşturma</a></h4>
<pre><code class="language-javascript">// src/components/Loading.js
import React from 'react';
import './Loading.css';

const Loading = () =&gt; (
  &lt;div className="loading"&gt;
    &lt;div className="spinner"&gt;&lt;/div&gt;
    &lt;p&gt;Loading...&lt;/p&gt;
  &lt;/div&gt;
);

export default Loading;
</code></pre>
<h4 id="6-withloading-hoc-oluşturma"><a class="header" href="#6-withloading-hoc-oluşturma">6. <code>withLoading</code> HOC Oluşturma</a></h4>
<pre><code class="language-javascript">// src/components/withLoading.js
import React, { useState } from 'react';
import Loading from './Loading';

const withLoading = WrappedComponent =&gt; {
  return function WithLoadingComponent(props) {
    const [isLoading, setLoading] = useState(false);

    return (
      &lt;&gt;
        {isLoading &amp;&amp; &lt;Loading /&gt;}
        &lt;WrappedComponent isLoading={isLoading} setLoading={setLoading} {...props} /&gt;
      &lt;/&gt;
    );
  };
};

export default withLoading;
</code></pre>
<h4 id="7-css-dosyalarını-oluşturma"><a class="header" href="#7-css-dosyalarını-oluşturma">7. CSS Dosyalarını Oluşturma</a></h4>
<p><code>src/components</code> klasörüne <code>MovieCard.css</code> ve <code>Loading.css</code> dosyalarını ekleyin.</p>
<pre><code class="language-css">/* src/components/MovieCard.css */
.movie-card {
  border: 1px solid #ddd;
  border-radius: 8px;
  overflow: hidden;
  margin: 16px;
  max-width: 300px;
}

.movie-card img {
  width: 100%;
  height: auto;
}

.movie-info {
  padding: 16px;
}

.movie-info h3 {
  margin: 0 0 8px;
}

.movie-info p {
  margin: 0;
}
</code></pre>
<pre><code class="language-css">/* src/components/Loading.css */
.loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
}

.spinner {
  border: 8px solid #f3f3f3;
  border-top: 8px solid #3498db;
  border-radius: 50%;
  width: 60px;
  height: 60px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
</code></pre>
<h4 id="8-appjs-dosyasını-güncelleme"><a class="header" href="#8-appjs-dosyasını-güncelleme">8. <code>App.js</code> Dosyasını Güncelleme</a></h4>
<pre><code class="language-javascript">// src/App.js
import React from 'react';
import MovieList from './components/MovieList';
import './App.css';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;Movie List&lt;/h1&gt;
      &lt;MovieList /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<h4 id="9-responsive-tasarım-ve-son-testler"><a class="header" href="#9-responsive-tasarım-ve-son-testler">9. Responsive Tasarım ve Son Testler</a></h4>
<p>Tarayıcınızda uygulamayı açın ve responsive tasarımı test edin. Film listesi düzgün görüntülenmeli ve CSS stilleri uygulanmış olmalıdır.</p>
<pre><code class="language-css">/* src/App.css */
.App {
  text-align: center;
  padding: 20px;
}

.movie-list {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}
</code></pre>
<p>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-in-react"><a class="header" href="#error-handling-in-react">Error Handling in React</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactte-hata-sınırları"><a class="header" href="#reactte-hata-sınırları">React'te Hata Sınırları</a></h1>
<h2 id="1-giriş"><a class="header" href="#1-giriş">1. Giriş</a></h2>
<p>React uygulamalarında hata sınırları, hataları zarif bir şekilde ele almak ve kesintisiz bir kullanıcı deneyimi sağlamak için kritik bir özelliktir. Hata sınırları, uygulamanızın herhangi bir yerinde meydana gelen JavaScript hatalarını yakalamak için tasarlanmış özel React bileşenleridir. Bu hataları kaydederek ve bir yedek UI render ederek, hata sınırları tüm bileşen ağacının çökmesini önler. Bunun yerine, bir bileşen içinde bir hata oluştuğunda sadece yedek UI görüntülenir ve uygulamanın geri kalanı beklendiği gibi çalışmaya devam eder.</p>
<h2 id="2-hata-sınırlarının-tanımı-ve-Önemi"><a class="header" href="#2-hata-sınırlarının-tanımı-ve-Önemi">2. Hata Sınırlarının Tanımı ve Önemi</a></h2>
<p>Hata sınırları, React uygulamalarında meydana gelen hataları izole etmek ve ele almak için kullanılır. Özellikle büyük ve karmaşık uygulamalarda, bir hatanın tüm uygulamayı çökertmesi kullanıcı deneyimini olumsuz etkiler. Hata sınırları sayesinde, sadece hatanın meydana geldiği bileşen etkilenir ve uygulamanın geri kalanı çalışmaya devam eder. Bu, kullanıcıların uygulamayı kullanmaya devam etmelerini sağlar ve hataların daha yönetilebilir hale gelmesine yardımcı olur.</p>
<h2 id="3-hata-sınırlarının-oluşturulması"><a class="header" href="#3-hata-sınırlarının-oluşturulması">3. Hata Sınırlarının Oluşturulması</a></h2>
<p>React 16.x sürümünden itibaren, hata sınırları yalnızca sınıf bileşenleri kullanılarak oluşturulabilir. Ancak, React 18 sürümünden itibaren, <code>ErrorBoundary</code> bileşeni ve <code>useErrorHandler</code> kancası kullanılarak fonksiyonel bileşenler ile hata sınırları oluşturulabilir.</p>
<h3 id="31-sınıf-bileşenleri-ile-hata-sınırları"><a class="header" href="#31-sınıf-bileşenleri-ile-hata-sınırları">3.1 Sınıf Bileşenleri ile Hata Sınırları</a></h3>
<p>Aşağıda, sınıf bileşenleri kullanarak bir hata sınırı oluşturma örneği verilmiştir:</p>
<pre><code class="language-jsx">import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Hata durumunu güncelle
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Hataları bir hata raporlama servisine gönder
    console.error("ErrorBoundary caught an error", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Yedek UI render
      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
    }

    return this.props.children; 
  }
}

export default ErrorBoundary;
</code></pre>
<h3 id="32-fonksiyonel-bileşenler-ile-hata-sınırları"><a class="header" href="#32-fonksiyonel-bileşenler-ile-hata-sınırları">3.2 Fonksiyonel Bileşenler ile Hata Sınırları</a></h3>
<p>React 18 ile birlikte, fonksiyonel bileşenlerde hata sınırları oluşturmak için <code>ErrorBoundary</code> bileşeni ve <code>useErrorHandler</code> kancası kullanılabilir:</p>
<pre><code class="language-jsx">import { ErrorBoundary, useErrorHandler } from 'react-error-boundary';

function ErrorFallback({ error }) {
  return (
    &lt;div role="alert"&gt;
      &lt;p&gt;Something went wrong:&lt;/p&gt;
      &lt;pre&gt;{error.message}&lt;/pre&gt;
    &lt;/div&gt;
  );
}

function MyComponent() {
  const handleError = useErrorHandler();
  
  // Bir hata fırlatmak için örnek
  const throwError = () =&gt; {
    try {
      // Hata oluşturan kod
    } catch (error) {
      handleError(error);
    }
  };

  return (
    &lt;div&gt;
      &lt;button onClick={throwError}&gt;Throw Error&lt;/button&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;ErrorBoundary FallbackComponent={ErrorFallback}&gt;
      &lt;MyComponent /&gt;
    &lt;/ErrorBoundary&gt;
  );
}

export default App;
</code></pre>
<h2 id="4-hata-sınırlarının-kullanım-alanları"><a class="header" href="#4-hata-sınırlarının-kullanım-alanları">4. Hata Sınırlarının Kullanım Alanları</a></h2>
<p>Hata sınırları aşağıdaki durumlarda özellikle yararlıdır:</p>
<ul>
<li>Üçüncü taraf kütüphaneler kullanıldığında ve bu kütüphanelerin hataları ele almadığında.</li>
<li>Karmaşık bileşen yapılarında, bileşenlerin belirli parçalarının izole edilmesi gerektiğinde.</li>
<li>Kullanıcı etkileşimlerine bağlı olarak meydana gelen hataların kullanıcı deneyimini olumsuz etkilemesini önlemek için.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hata-sınırları-kullanım-durumları"><a class="header" href="#hata-sınırları-kullanım-durumları">Hata Sınırları Kullanım Durumları</a></h1>
<h2 id="giriş-27"><a class="header" href="#giriş-27">Giriş</a></h2>
<p>Hata sınırları, bir React uygulamasında meydana gelen hataları zarif bir şekilde ele alarak, tüm uygulamanın çökmesini önler. Hata sınırlarını kullanarak, kullanıcı deneyimini geliştirebilir ve beklenmeyen hatalar meydana geldiğinde bile işlevsel bir kullanıcı arayüzü (UI) sağlayabilirsiniz.</p>
<p>Bu eğitimde, hata sınırlarının çeşitli kullanım durumlarını detaylandıracağız. Verilen PDF dokümanından elde edilen bilgileri, eleştirel bir yaklaşımla değerlendirerek kapsamlı bir şekilde ele alacağız. Her bölümde kod parçacıkları ile konuyu destekleyeceğiz.</p>
<h2 id="hata-sınırlarının-kullanım-durumları"><a class="header" href="#hata-sınırlarının-kullanım-durumları">Hata Sınırlarının Kullanım Durumları</a></h2>
<ol>
<li>
<p><strong>Üçüncü Taraf Bileşenler</strong>
Üçüncü taraf bileşenleri entegre ederken, beklenmedik senaryolar veya veriler nedeniyle hatalar meydana gelebilir. Bu bileşenleri hata sınırları ile sarmak, çöküşleri önler ve bir yedek UI (kullanıcı arayüzü) görüntülemenizi sağlar.</p>
<pre><code class="language-jsx">import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Hata kaydı yapma
    console.log(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return &lt;h1&gt;Bir hata meydana geldi.&lt;/h1&gt;;
    }

    return this.props.children; 
  }
}

// Kullanım
&lt;ErrorBoundary&gt;
  &lt;ThirdPartyComponent /&gt;
&lt;/ErrorBoundary&gt;
</code></pre>
</li>
<li>
<p><strong>Ağ Hatalarını Yönetmek</strong>
Bileşenleriniz sunucudan veri çekmeye bağımlı olduğunda, ağ hataları UI sorunlarına veya çökmelere neden olabilir. Bu bileşenlerin etrafına hata sınırları yerleştirmek, kullanıcılara anlamlı bir mesaj veya yedek bir UI göstermenizi sağlar.</p>
<pre><code class="language-jsx">class DataFetcher extends React.Component {
  state = { data: null, error: null };

  componentDidMount() {
    fetch('/api/data')
      .then(response =&gt; response.json())
      .then(data =&gt; this.setState({ data }))
      .catch(error =&gt; this.setState({ error }));
  }

  render() {
    if (this.state.error) {
      throw new Error('Veri çekme hatası');
    }

    return (
      &lt;div&gt;
        {this.state.data ? (
          &lt;div&gt;{this.state.data}&lt;/div&gt;
        ) : (
          &lt;div&gt;Veri yükleniyor...&lt;/div&gt;
        )}
      &lt;/div&gt;
    );
  }
}

// Kullanım
&lt;ErrorBoundary&gt;
  &lt;DataFetcher /&gt;
&lt;/ErrorBoundary&gt;
</code></pre>
</li>
<li>
<p><strong>Öngörülemeyen Kullanıcı Girdileri</strong>
Kullanıcılar, uygulamanızın beklemediği girdiler sağlayabilir ve bu, render sırasında veya bileşen mantığında hatalara yol açabilir. Hata sınırları, bu hataları yakalamanıza ve yardımcı bir mesaj veya yedek bir UI görüntülemenize yardımcı olur.</p>
<pre><code class="language-jsx">class UserInputComponent extends React.Component {
  state = { userInput: '' };

  handleChange = (event) =&gt; {
    try {
      this.setState({ userInput: event.target.value });
    } catch (error) {
      throw new Error('Geçersiz kullanıcı girdisi');
    }
  };

  render() {
    if (this.state.error) {
      throw new Error('Render hatası');
    }

    return (
      &lt;input
        type="text"
        value={this.state.userInput}
        onChange={this.handleChange}
      /&gt;
    );
  }
}

// Kullanım
&lt;ErrorBoundary&gt;
  &lt;UserInputComponent /&gt;
&lt;/ErrorBoundary&gt;
</code></pre>
</li>
<li>
<p><strong>Dinamik Bileşen Yükleme</strong>
Dinamik ithalatlar veya kod bölme işlemleri kullanarak bileşenleri yüklerken, bileşenin doğru yüklenmemesi veya render sırasında bir hata ile karşılaşma riski vardır. Bir hata sınırı bu hataları yakalayabilir ve yedek bir UI gösterebilir.</p>
<pre><code class="language-jsx">import React, { Suspense, lazy } from 'react';

const LazyComponent = lazy(() =&gt; import('./LazyComponent'));

// Kullanım
&lt;ErrorBoundary&gt;
  &lt;Suspense fallback={&lt;div&gt;Yükleniyor...&lt;/div&gt;}&gt;
    &lt;LazyComponent /&gt;
  &lt;/Suspense&gt;
&lt;/ErrorBoundary&gt;
</code></pre>
</li>
<li>
<p><strong>Bileşen Hatalarını İzole Etmek</strong>
Büyük uygulamalarda, bileşen hatalarını izole etmek ve bunların tüm uygulamayı etkilemesini önlemek genellikle iyi bir fikirdir. Hata sınırlarını bileşen hiyerarşisinin farklı seviyelerine stratejik olarak yerleştirerek hataları yakalayabilir ve işlevsel bir kullanıcı arayüzünü koruyabilirsiniz.</p>
<pre><code class="language-jsx">&lt;ErrorBoundary&gt;
  &lt;Header /&gt;
  &lt;ErrorBoundary&gt;
    &lt;MainContent /&gt;
  &lt;/ErrorBoundary&gt;
  &lt;Footer /&gt;
&lt;/ErrorBoundary&gt;
</code></pre>
</li>
<li>
<p><strong>Hata Kaydı ve İzleme</strong>
Hata sınırları, hataları kaydetme ve bileşen yığını gibi ek bilgileri yakalama fırsatı sağlar. Bu bilgiler, bir izleme hizmetine gönderilebilir veya daha fazla analiz için saklanabilir ve uygulamanızdaki sorunları belirlemenize ve düzeltmenize yardımcı olur.</p>
<pre><code class="language-jsx">componentDidCatch(error, errorInfo) {
  // Hataları bir izleme servisine gönderme
  logErrorToService(error, errorInfo);
}
</code></pre>
</li>
</ol>
<h2 id="sonuç-29"><a class="header" href="#sonuç-29">Sonuç</a></h2>
<p>Hata sınırları, React uygulamalarında hataları yönetmenin ve kullanıcı deneyimini iyileştirmenin güçlü bir yoludur. Bu eğitimde, hata sınırlarının çeşitli kullanım durumlarını detaylandırdık ve her biri için yapılandırılmış kod parçacıkları sunduk. Hata sınırlarını stratejik olarak kullanarak, uygulamanızın daha kararlı ve kullanıcı dostu olmasını sağlayabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-hata-sınırları-ile-hata-yönetimi"><a class="header" href="#react-hata-sınırları-ile-hata-yönetimi">React Hata Sınırları ile Hata Yönetimi</a></h1>
<p>React uygulamalarında, beklenmeyen JavaScript hatalarının tüm uygulamayı çökertmesini önlemek için hata sınırları (error boundaries) kullanılır. Bu mekanizma, hataları yakalayıp ele alarak kullanıcıya bir hata arayüzü gösterir ve uygulamanın geri kalanının sorunsuz çalışmasını sağlar. Bu eğitimde, React uygulamalarınızda hata sınırlarını nasıl kullanacağınızı ayrıntılı bir şekilde inceleyeceğiz.</p>
<h2 id="1-proje-yapısının-oluşturulması-4"><a class="header" href="#1-proje-yapısının-oluşturulması-4">1. Proje Yapısının Oluşturulması</a></h2>
<p>Öncelikle, bileşen dosyalarınızı saklayacağınız bir <code>components</code> klasörü oluşturun (eğer mevcut değilse). Bu klasör, hata sınırı ve diğer bileşenlerinizi barındıracaktır.</p>
<h2 id="2-errorboundary-bileşeninin-oluşturulması"><a class="header" href="#2-errorboundary-bileşeninin-oluşturulması">2. ErrorBoundary Bileşeninin Oluşturulması</a></h2>
<p><code>components</code> klasörü içinde <code>ErrorBoundary.jsx</code> adında yeni bir dosya oluşturun. Bu dosyada hata sınırı bileşenimizi tanımlayacağız.</p>
<h2 id="errorboundary-bileşeninin-tanımlanması"><a class="header" href="#errorboundary-bileşeninin-tanımlanması">ErrorBoundary Bileşeninin Tanımlanması</a></h2>
<p><code>ErrorBoundary.jsx</code> dosyasına aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Sonraki render işlemi için state güncellenir
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Hata bilgileri kaydedilebilir veya bir izleme servisine gönderilebilir
    console.log("Hata:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Hata oluştuğunda gösterilecek arayüz
      return &lt;h1&gt;Bir hata oluştu.&lt;/h1&gt;;
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
</code></pre>
<p>Bu kod parçası, <code>ErrorBoundary</code> sınıf bileşenini tanımlar. Hata yakalandığında <code>hasError</code> state'i <code>true</code> olarak güncellenir ve hata mesajı görüntülenir.</p>
<h2 id="3-Örnek-bir-bileşenin-oluşturulması"><a class="header" href="#3-Örnek-bir-bileşenin-oluşturulması">3. Örnek Bir Bileşenin Oluşturulması</a></h2>
<p><code>components</code> klasörü içinde <code>Sample.jsx</code> adında yeni bir dosya oluşturun. Bu dosyada hata oluşturabilecek bir örnek bileşen tanımlayacağız.</p>
<h2 id="sample-bileşeninin-tanımlanması"><a class="header" href="#sample-bileşeninin-tanımlanması">Sample Bileşeninin Tanımlanması</a></h2>
<p><code>Sample.jsx</code> dosyasına aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React from 'react';

const Sample = () =&gt; {
  const handleClick = () =&gt; {
    throw new Error("Simüle edilmiş hata!");
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handleClick}&gt;Hata Oluştur&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default Sample;
</code></pre>
<p>Bu bileşen, bir hata oluşturmak için bir düğme içerir. Düğmeye tıklandığında <code>handleClick</code> fonksiyonu çağrılır ve bir hata fırlatılır.</p>
<h2 id="4-app-bileşenine-errorboundary-ve-sample-bileşenlerini-dahil-etmek"><a class="header" href="#4-app-bileşenine-errorboundary-ve-sample-bileşenlerini-dahil-etmek">4. App Bileşenine ErrorBoundary ve Sample Bileşenlerini Dahil Etmek</a></h2>
<p><code>App.jsx</code> dosyasını açın ve <code>ErrorBoundary</code> ile <code>Sample</code> bileşenlerini içe aktararak <code>Sample</code> bileşenini <code>ErrorBoundary</code> bileşeni ile sarın.</p>
<h2 id="appjsx-dosyasının-güncellenmesi"><a class="header" href="#appjsx-dosyasının-güncellenmesi">App.jsx Dosyasının Güncellenmesi</a></h2>
<pre><code class="language-jsx">import React from 'react';
import ErrorBoundary from './components/ErrorBoundary';
import Sample from './components/Sample';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;ErrorBoundary&gt;
        &lt;Sample /&gt;
      &lt;/ErrorBoundary&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>Bu düzenleme ile <code>Sample</code> bileşeninde bir hata meydana geldiğinde <code>ErrorBoundary</code> bileşeni hatayı yakalayacak ve kullanıcıya bir hata mesajı gösterecektir.</p>
<h2 id="sonuç-30"><a class="header" href="#sonuç-30">Sonuç</a></h2>
<p>Bu eğitimde, React uygulamalarınızda hata sınırları kullanarak hataları nasıl yakalayabileceğinizi ve yönetebileceğinizi inceledik. Hata sınırları, uygulamanızın daha kararlı ve kullanıcı dostu olmasını sağlar. Yukarıdaki adımları takip ederek kendi hata yönetim stratejinizi oluşturabilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-hata-sınırı-uygulaması"><a class="header" href="#react-hata-sınırı-uygulaması">React Hata Sınırı Uygulaması</a></h1>
<h2 id="giriş-28"><a class="header" href="#giriş-28">Giriş</a></h2>
<p>Bu eğitimde, React uygulamalarında hata sınırlarını nasıl kullanacağınızı öğreneceksiniz. Hata sınırları, belirli bileşenler içinde oluşan hataları yakalayıp yönetmek ve bu hatalar meydana geldiğinde yedek bir kullanıcı arayüzü göstermek için kullanılır. Bu uygulama, kullanıcı deneyimini geliştirir ve uygulama çökmesini önler. Eğitim boyunca iyi yapılandırılmış kod parçacıkları ve gerekli açıklamalar ile süreci adım adım inceleyeceğiz.</p>
<h2 id="gereksinimler-13"><a class="header" href="#gereksinimler-13">Gereksinimler</a></h2>
<ol>
<li>Create React App kullanarak yeni bir React uygulaması oluşturun veya mevcut bir uygulamayı kullanın.</li>
<li>Hata sınırı olarak işlev görecek ve hata atabilecek bileşenleri sarmalayacak bir <code>ErrorBoundary</code> bileşeni oluşturun.</li>
<li><code>ErrorBoundary</code> bileşeninde hataları yakalayıp yönetmek için gerekli mantığı <code>componentDidCatch</code> yaşam döngüsü yöntemiyle uygulayın.</li>
<li>Hata meydana geldiğinde <code>ErrorBoundary</code> bileşeni içinde kullanıcıyı bilgilendiren bir yedek kullanıcı arayüzü (fallback UI) gösterin.</li>
<li>Bilerek hata atan bir bileşen olan <code>ComponentWithError</code> bileşenini oluşturun.</li>
<li><code>ComponentWithError</code> bileşenini <code>ErrorBoundary</code> bileşeni ile sararak hata sınırı işlevselliğini test edin.</li>
<li><code>ComponentWithError</code> içinde bir hata meydana geldiğinde, <code>ErrorBoundary</code> bileşeninin yedek kullanıcı arayüzünü gösterdiğinden emin olun.</li>
<li>Yedek kullanıcı arayüzünü CSS kullanarak görsel olarak çekici hale getirin.</li>
<li>Hata sınırı ile sarılmış bileşenlerde kasten hatalar oluşturarak uygulamayı test edin ve yedek kullanıcı arayüzünün doğru şekilde görüntülendiğini doğrulayın.</li>
</ol>
<h2 id="uygulama-adımları-2"><a class="header" href="#uygulama-adımları-2">Uygulama Adımları</a></h2>
<h2 id="1-react-uygulamasının-kurulumu"><a class="header" href="#1-react-uygulamasının-kurulumu">1. React Uygulamasının Kurulumu</a></h2>
<p>Yeni bir React uygulaması oluşturun veya mevcut bir uygulamayı kullanın.</p>
<pre><code class="language-sh">npx create-react-app error-boundary-app
cd error-boundary-app
</code></pre>
<h2 id="2-errorboundary-bileşeninin-oluşturulması-1"><a class="header" href="#2-errorboundary-bileşeninin-oluşturulması-1">2. ErrorBoundary Bileşeninin Oluşturulması</a></h2>
<p><code>ErrorBoundary.js</code> adında bir dosya oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Bir hata meydana geldiğinde durumu güncelle
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Hataları loglama gibi işlemler burada yapılabilir
    console.error("ErrorBoundary caught an error", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Hata meydana geldiğinde gösterilecek yedek kullanıcı arayüzü
      return &lt;h1&gt;Bir hata oluştu. Lütfen daha sonra tekrar deneyin.&lt;/h1&gt;;
    }

    return this.props.children; 
  }
}

export default ErrorBoundary;
</code></pre>
<h2 id="3-componentwitherror-bileşeninin-oluşturulması"><a class="header" href="#3-componentwitherror-bileşeninin-oluşturulması">3. ComponentWithError Bileşeninin Oluşturulması</a></h2>
<p><code>ComponentWithError.js</code> adında bir dosya oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">import React from 'react';

const ComponentWithError = () =&gt; {
  throw new Error("Bu, bilerek oluşturulmuş bir hatadır.");
  return &lt;div&gt;Bu bileşen hata oluşturur.&lt;/div&gt;;
};

export default ComponentWithError;
</code></pre>
<h2 id="4-hata-sınırını-kullanma"><a class="header" href="#4-hata-sınırını-kullanma">4. Hata Sınırını Kullanma</a></h2>
<p><code>App.js</code> dosyasını aşağıdaki gibi güncelleyin:</p>
<pre><code class="language-jsx">import React from 'react';
import './App.css';
import ErrorBoundary from './ErrorBoundary';
import ComponentWithError from './ComponentWithError';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;ErrorBoundary&gt;
          &lt;ComponentWithError /&gt;
        &lt;/ErrorBoundary&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<h2 id="5-yedek-kullanıcı-arayüzünün-stilize-edilmesi"><a class="header" href="#5-yedek-kullanıcı-arayüzünün-stilize-edilmesi">5. Yedek Kullanıcı Arayüzünün Stilize Edilmesi</a></h2>
<p><code>App.css</code> dosyasını aşağıdaki gibi güncelleyin:</p>
<pre><code class="language-css">.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}
</code></pre>
<h2 id="6-uygulamanın-test-edilmesi"><a class="header" href="#6-uygulamanın-test-edilmesi">6. Uygulamanın Test Edilmesi</a></h2>
<p>Uygulamanızı çalıştırarak hata sınırının doğru çalıştığını doğrulayın:</p>
<pre><code class="language-sh">npm start
</code></pre>
<h2 id="7-projeyi-githuba-yükleme-ve-canlı-demo-sağlama"><a class="header" href="#7-projeyi-githuba-yükleme-ve-canlı-demo-sağlama">7. Projeyi GitHub'a Yükleme ve Canlı Demo Sağlama</a></h2>
<p>Uygulamanızı GitHub'a yükleyin ve Netlify veya GitHub Pages kullanarak canlı bir demo sağlayın. README dosyanızda nasıl çalıştırılacağına dair talimatlar eklemeyi unutmayın.</p>
<h2 id="sonuç-31"><a class="header" href="#sonuç-31">Sonuç</a></h2>
<p>Bu eğitimde, React uygulamalarında hata sınırlarının nasıl kullanılacağını öğrendiniz. Hata sınırları, kullanıcı deneyimini geliştirir ve uygulama çökmesini önler. Bu yöntemleri kendi projelerinizde uygulayarak daha güvenilir ve kullanıcı dostu uygulamalar geliştirebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-hooks-beyond-usestate-and-useeffect"><a class="header" href="#more-hooks-beyond-usestate-and-useeffect">More Hooks: Beyond useState and useEffect</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usereducer-hook"><a class="header" href="#usereducer-hook">useReducer Hook</a></h1>
<p>Bu eğitim rehberi, React uygulamalarında daha karmaşık durum yönetimi için kullanılan <code>useReducer</code> kancasının nasıl kullanılacağını kapsamlı ve ayrıntılı bir şekilde açıklamaktadır. <code>useReducer</code>, <code>useState</code> kancasına daha ileri düzey bir alternatiftir ve bir bileşen içerisindeki durum mantığını daha etkili bir şekilde yönetmek için kullanılır. Bu rehber, durum yönetimi ve <code>useReducer</code> kancasının kullanımını örneklerle açıklayacaktır.</p>
<h2 id="giriş-29"><a class="header" href="#giriş-29">Giriş</a></h2>
<h3 id="usereducer-nedir"><a class="header" href="#usereducer-nedir"><code>useReducer</code> Nedir?</a></h3>
<p><code>useReducer</code> kancası, bir bileşen içindeki karmaşık durum mantığını yönetmek için kullanılır. Özellikle birden fazla alt değer içeren durumlarla veya bir sonraki durumun önceki duruma bağlı olduğu durumlarla ilgilenirken kullanışlıdır.</p>
<h3 id="kullanım-adımları"><a class="header" href="#kullanım-adımları">Kullanım Adımları</a></h3>
<p><code>useReducer</code> kancasını kullanmak için iki ana bileşene ihtiyacınız vardır:</p>
<ol>
<li><strong>Reducer Fonksiyonu</strong>: Bu, mevcut durumu ve bir aksiyonu argüman olarak alan ve aksiyon türü ve yüküne (payload) bağlı olarak bir sonraki durumu döndüren saf bir fonksiyondur.</li>
<li><strong>Başlangıç Durumu</strong>: Bu, reducer tarafından yönetilen durumun başlangıç değeridir.</li>
</ol>
<h3 id="sözdizimi-1"><a class="header" href="#sözdizimi-1">Sözdizimi</a></h3>
<p><code>useReducer</code> kancasını bir React bileşeninde kullanmak için şu adımları takip edin:</p>
<ol>
<li><code>useReducer</code>'ı <code>react</code>'dan içe aktarın.</li>
<li>Mevcut durumu ve aksiyonu argüman olarak alan bir reducer fonksiyonu oluşturun.</li>
<li>Başlangıç durumunu tanımlayın.</li>
<li>Reducer fonksiyonu ve başlangıç durumu ile <code>useReducer</code>'ı çağırın.</li>
<li>Mevcut durumu bileşende erişin ve render edin.</li>
<li>Durumu güncellemek için dispatch fonksiyonunu kullanarak aksiyonları gönderin.</li>
<li>Reducer, aksiyon türüne bağlı olarak durumu günceller ve bileşen yeni durum ile yeniden render edilir.</li>
</ol>
<h2 id="adım-adım-uygulama-6"><a class="header" href="#adım-adım-uygulama-6">Adım Adım Uygulama</a></h2>
<p>Aşağıdaki adımları izleyerek React uygulamanızda <code>useReducer</code> kancasını kullanabilirsiniz:</p>
<h3 id="1-bileşenler-İçin-yeni-bir-klasör-oluşturun"><a class="header" href="#1-bileşenler-İçin-yeni-bir-klasör-oluşturun">1. Bileşenler İçin Yeni Bir Klasör Oluşturun</a></h3>
<p>React projenizin <code>src</code> klasöründe, <code>components</code> adında yeni bir klasör oluşturun (eğer zaten mevcut değilse).</p>
<pre><code class="language-bash">mkdir src/components
</code></pre>
<h3 id="2-yeni-bir-bileşen-dosyası-oluşturun"><a class="header" href="#2-yeni-bir-bileşen-dosyası-oluşturun">2. Yeni Bir Bileşen Dosyası Oluşturun</a></h3>
<p><code>components</code> klasörü içinde <code>Counter.jsx</code> adında yeni bir dosya oluşturun.</p>
<pre><code class="language-bash">touch src/components/Counter.jsx
</code></pre>
<h3 id="3-reacti-İçe-aktarın"><a class="header" href="#3-reacti-İçe-aktarın">3. React'i İçe Aktarın</a></h3>
<p><code>Counter.jsx</code> dosyasını açın ve React'i içe aktararak başlayın.</p>
<pre><code class="language-jsx">import React from 'react';
</code></pre>
<h3 id="4-counter-bileşenini-oluşturun"><a class="header" href="#4-counter-bileşenini-oluşturun">4. Counter Bileşenini Oluşturun</a></h3>
<p><code>useReducer</code> kancasını kullanarak durumunu yönetecek olan <code>Counter</code> adlı fonksiyonel bir bileşen tanımlayın. Şimdilik, UI bileşenlerini render edin.</p>
<pre><code class="language-jsx">const Counter = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;Counter&lt;/h1&gt;
      &lt;button&gt;Increment&lt;/button&gt;
      &lt;button&gt;Decrement&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default Counter;
</code></pre>
<h3 id="5-counter-bileşenini-İçe-aktarın-ve-kullanın"><a class="header" href="#5-counter-bileşenini-İçe-aktarın-ve-kullanın">5. Counter Bileşenini İçe Aktarın ve Kullanın</a></h3>
<p><code>src</code> klasörünüzde <code>App.jsx</code> dosyasını açın ve <code>Counter</code> bileşenini içe aktarın. <code>App</code> bileşeninin mevcut içeriğini <code>Counter</code> bileşeni ile değiştirin.</p>
<pre><code class="language-jsx">import React from 'react';
import Counter from './components/Counter';

const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Counter /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<h3 id="6-uygulamayı-Çalıştırın"><a class="header" href="#6-uygulamayı-Çalıştırın">6. Uygulamayı Çalıştırın</a></h3>
<p>Uygulamanızı çalıştırın ve <code>Counter</code> bileşeninin doğru şekilde render edildiğini doğrulayın.</p>
<pre><code class="language-bash">npm start
</code></pre>
<h3 id="7-usereducerı-İçe-aktarın"><a class="header" href="#7-usereducerı-İçe-aktarın">7. <code>useReducer</code>'ı İçe Aktarın</a></h3>
<p><code>Counter.jsx</code> dosyasını güncelleyerek <code>useReducer</code> kancasını içe aktarın.</p>
<pre><code class="language-jsx">import React, { useReducer } from 'react';
</code></pre>
<h3 id="8-reducer-fonksiyonu-oluşturun"><a class="header" href="#8-reducer-fonksiyonu-oluşturun">8. Reducer Fonksiyonu Oluşturun</a></h3>
<p>Mevcut durumu ve aksiyonu argüman olarak alan ve aksiyon türü ve yüküne (payload) bağlı olarak bir sonraki durumu döndüren bir reducer fonksiyonu tanımlayın.</p>
<pre><code class="language-jsx">const reducer = (state, action) =&gt; {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error('Unknown action type');
  }
};
</code></pre>
<h3 id="9-başlangıç-durumunu-tanımlayın"><a class="header" href="#9-başlangıç-durumunu-tanımlayın">9. Başlangıç Durumunu Tanımlayın</a></h3>
<p>Reducer tarafından yönetilecek durum için başlangıç durum değerini belirleyin. Bu örnekte, başlangıç durumu basit bir sayı, 0'dır.</p>
<pre><code class="language-jsx">const initialState = { count: 0 };
</code></pre>
<h3 id="10-usereducerı-uygulayın"><a class="header" href="#10-usereducerı-uygulayın">10. <code>useReducer</code>'ı Uygulayın</a></h3>
<p><code>Counter</code> bileşenini güncelleyerek durumunu yönetmek için <code>useReducer</code> kancasını kullanın ve UI bileşenlerini durumu kullanacak ve aksiyonları dispatch edecek şekilde güncelleyin.</p>
<pre><code class="language-jsx">const Counter = () =&gt; {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    &lt;div&gt;
      &lt;h1&gt;Counter: {state.count}&lt;/h1&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'increment' })}&gt;Increment&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'decrement' })}&gt;Decrement&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default Counter;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="usecallback-kullanımı-ile-react-performans-optimizasyonu"><a class="header" href="#usecallback-kullanımı-ile-react-performans-optimizasyonu">useCallback Kullanımı ile React Performans Optimizasyonu</a></h3>
<p>React'teki <code>useCallback</code> kancası (hook), bir fonksiyonu hatırlama (memoize) işlevi görerek, bağımlılıkları değişmediği sürece fonksiyonun önbelleğe alınmış bir sürümünü döndürür. Bu, performans optimizasyonları için özellikle faydalıdır ve gereksiz render işlemlerini önlemek için fonksiyonları prop olarak geçerken referans eşitliğine dayanan alt bileşenler için önemlidir.</p>
<h4 id="usecallback-kancası-neden-gereklidir"><a class="header" href="#usecallback-kancası-neden-gereklidir"><code>useCallback</code> Kancası Neden Gereklidir?</a></h4>
<ol>
<li><strong>Performans Optimizasyonu</strong>: <code>useCallback</code>, React uygulamanızın performansını gereksiz render ve fonksiyon yeniden yaratmalarını azaltarak iyileştirir.</li>
<li><strong>Memoization</strong>: Bir geri çağırma fonksiyonunu (callback function) hatırlatarak, bağımlılıklarından biri değiştiğinde fonksiyonun yeniden yaratılmasını sağlar.</li>
<li><strong>Kararlı Fonksiyon Referansları</strong>: <code>useCallback</code>, fonksiyonlar için kararlı referanslar sağlar, bu da bu fonksiyonlara props olarak bağımlı bileşenlerle çalışırken önemlidir.</li>
<li><strong>Alt Bileşen Render'larını Azaltma</strong>: <code>React.memo</code> ile kullanıldığında, <code>useCallback</code>, hatırlanan fonksiyonları props olarak kullanan alt bileşenlerde gereksiz render'ları önleyebilir.</li>
<li><strong>Pahalı Hesaplamaları Optimize Etme</strong>: <code>useCallback</code>, uzun süre çalışması gereken pahalı hesaplamaları veya fonksiyonları hatırlamak için kullanılabilir, böylece uygulamanızın genel performansını artırır.</li>
<li><strong>Sonsuz Döngüleri Önleme</strong>: Bazı senaryolarda, <code>useCallback</code>, <code>useEffect</code> gibi kancaların bağımlılıkları içinde sürekli değişen fonksiyon referanslarından kaynaklanan sonsuz döngüleri önlemeye yardımcı olabilir.</li>
</ol>
<h4 id="Örnek-uygulama-1"><a class="header" href="#Örnek-uygulama-1">Örnek Uygulama</a></h4>
<p>Bu örnekte, bir sayaç bileşeni (<code>Counter</code>) ve bir liste bileşeni (<code>List</code>) oluşturacağız. Sayaç değeri temel alınarak öğeler oluşturulacak ve <code>useCallback</code> kancasının liste bileşeninde kullanılıp kullanılmamasının etkilerini gözlemleyeceğiz.</p>
<h5 id="usecallback-olmadan"><a class="header" href="#usecallback-olmadan"><code>useCallback</code> Olmadan</a></h5>
<p><strong>Adımlar</strong>:</p>
<ol>
<li>React projenizin <code>src</code> klasöründe, <code>components</code> adında yeni bir klasör oluşturun (eğer zaten mevcut değilse).</li>
<li><code>components</code> klasöründe <code>Counter.jsx</code> adında bir bileşen oluşturun.</li>
<li><code>components</code> klasöründe <code>List.jsx</code> adında bir bileşen oluşturun.</li>
</ol>
<pre><code class="language-jsx">// Counter.jsx
import React, { useState } from 'react';
import List from './List';

const Counter = () =&gt; {
  const [counter, setCounter] = useState(0);

  const increment = () =&gt; {
    setCounter(counter + 1);
  };

  return (
    &lt;div&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
      &lt;List counter={counter} /&gt;
    &lt;/div&gt;
  );
};

export default Counter;

// List.jsx
import React, { useEffect, useState } from 'react';

const List = ({ counter }) =&gt; {
  const [items, setItems] = useState([]);

  useEffect(() =&gt; {
    setItems((prevItems) =&gt; [...prevItems, counter]);
  }, [counter]);

  return (
    &lt;ul&gt;
      {items.map((item, index) =&gt; (
        &lt;li key={index}&gt;{item}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};

export default List;
</code></pre>
<p>Bu yapılandırmada, <code>Counter</code> bileşenindeki <code>increment</code> fonksiyonu sayaç değerini günceller ve <code>List</code> bileşeni sayaç değerini bir prop olarak alır. Sayaç değeri değiştiğinde, <code>List</code> bileşenindeki <code>useEffect</code> tetiklenir ve listeye yeni bir öğe eklenir.</p>
<h5 id="usecallback-ile"><a class="header" href="#usecallback-ile"><code>useCallback</code> ile</a></h5>
<p>Şimdi, <code>List</code> bileşenini <code>useCallback</code> kullanacak şekilde değiştirelim:</p>
<pre><code class="language-jsx">// List.jsx
import React, { useEffect, useState, useCallback } from 'react';

const List = ({ counter }) =&gt; {
  const [items, setItems] = useState([]);

  const addItem = useCallback(() =&gt; {
    setItems((prevItems) =&gt; [...prevItems, counter]);
  }, [counter]);

  useEffect(() =&gt; {
    addItem();
  }, [addItem]);

  return (
    &lt;ul&gt;
      {items.map((item, index) =&gt; (
        &lt;li key={index}&gt;{item}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};

export default List;
</code></pre>
<p>Bu versiyonda, <code>useCallback</code> kancasını <code>addItem</code> fonksiyonunu hatırlatmak (memoize) için tanıttık. Bu şekilde, <code>addItem</code> fonksiyonunun sadece sayaç değeri değiştiğinde yeniden yaratılmasını sağladık. Sonuç olarak, <code>List</code> bileşenindeki <code>useEffect</code>, sadece <code>addItem</code> fonksiyon referansı değiştiğinde çalışacaktır, bu da sayaç değeri değiştiğinde gerçekleşir.</p>
<h4 id="sonuç-32"><a class="header" href="#sonuç-32">Sonuç</a></h4>
<p>Her iki durumda da uygulamanın görsel çıktısı aynı kalır. Ancak, <code>useCallback</code> kullanmanın temel farkı, performans optimizasyonunda ve gereksiz render'ların önlenmesinde yatmaktadır. Bu spesifik örnekte, bileşenler nispeten basit olduğundan ve render sayısı az olduğundan performans farkı fark edilmeyebilir. Ancak, daha karmaşık uygulamalarda ve daha büyük bileşen ağaçlarında, <code>useCallback</code> kullanmak, gereksiz render sayısını azaltarak performansı iyileştirmeye yardımcı olabilir.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="usememo-hook-kullanımı"><a class="header" href="#usememo-hook-kullanımı"><code>useMemo</code> Hook Kullanımı</a></h2>
<p>React geliştirmelerinde <code>useMemo</code> Hook'u, performans optimizasyonu sağlamak için kullanılan önemli bir araçtır. Bu eğitimde, <code>useMemo</code> Hook'unun nasıl kullanılacağını, kullanımı ile ilgili dikkat edilmesi gereken noktaları ve gerçek bir örnek üzerinden nasıl uygulanacağını anlatacağız.</p>
<h3 id="usememo-nedir"><a class="header" href="#usememo-nedir">useMemo Nedir?</a></h3>
<p><code>useMemo</code>, hesaplanması pahalı olan bir değeri, belirli bağımlılıklar değişmediği sürece yeniden hesaplamadan kullanmamıza olanak tanır. Bu sayede gereksiz render işlemlerinin önüne geçilmiş olur.</p>
<p><strong>Sözdizimi:</strong></p>
<pre><code class="language-javascript">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);
</code></pre>
<ul>
<li><code>useMemo</code> iki argüman alır:
<ol>
<li>Pahalı bir hesaplama işlemi döndüren fonksiyon (<code>() =&gt; computeExpensiveValue(a, b)</code>).</li>
<li>Bu fonksiyonun bağımlılıklarını içeren bir dizi (<code>[a, b]</code>). Bu bağımlılıklardan herhangi biri değiştiğinde, <code>useMemo</code> yeni değeri hesaplar.</li>
</ol>
</li>
</ul>
<h3 id="problem"><a class="header" href="#problem">Problem</a></h3>
<p><code>useMemo</code> ve <code>useCallback</code> kullanmanın temel nedenlerinden biri, bileşenin propsları değişmediği sürece yeniden render edilmesini önlemektir. Şimdi, <code>useMemo</code> kullanarak ve kullanmadan iki ayrı bileşenle bu farkı gösteren bir örnek oluşturacağız.</p>
<h3 id="adım-adım-uygulama-7"><a class="header" href="#adım-adım-uygulama-7">Adım Adım Uygulama</a></h3>
<ol>
<li>
<p><strong>Yeni Bir Klasör Oluşturma:</strong></p>
<p>React projenizin <code>src</code> klasöründe <code>components</code> adında yeni bir klasör oluşturun (eğer mevcut değilse).</p>
</li>
<li>
<p><strong>Timer Bileşenini Oluşturma:</strong></p>
<p><code>components</code> klasöründe <code>Timer.jsx</code> adlı bir bileşen oluşturun. Bu bileşende <code>useState</code> kullanarak bir timer durumu yönetilecektir. Ayrıca timer değerini artırmak için bir buton bulunacak. <code>ExpensiveCalculation</code> bileşeni <code>useMemo</code> kullanmadan pahalı bir hesaplama yaparken, <code>MemoizedCalculation</code> bileşeni aynı hesaplamayı <code>useMemo</code> kullanarak optimize edecektir.</p>
<pre><code class="language-javascript">// Timer.jsx
import React, { useState } from 'react';
import ExpensiveCalculation from './ExpensiveCalculation';
import MemoizedCalculation from './MemoizedCalculation';

const Timer = () =&gt; {
  const [time, setTime] = useState(0);

  return (
    &lt;div&gt;
      &lt;h1&gt;Timer: {time}&lt;/h1&gt;
      &lt;button onClick={() =&gt; setTime(time + 1)}&gt;Tick&lt;/button&gt;
      &lt;ExpensiveCalculation time={time} /&gt;
      &lt;MemoizedCalculation time={time} /&gt;
    &lt;/div&gt;
  );
};

export default Timer;
</code></pre>
</li>
<li>
<p><strong>ExpensiveCalculation Bileşenini Oluşturma:</strong></p>
<p><code>components</code> klasöründe <code>ExpensiveCalculation.jsx</code> adlı bir bileşen oluşturun. Bu bileşen <code>useMemo</code> kullanmadan pahalı bir hesaplama yapar.</p>
<pre><code class="language-javascript">// ExpensiveCalculation.jsx
import React from 'react';

const ExpensiveCalculation = ({ time }) =&gt; {
  const performExpensiveCalculation = (num) =&gt; {
    console.log('Performing expensive calculation');
    // Pahalı hesaplama işlemi
    return num * 2;
  };

  const result = performExpensiveCalculation(time);

  return &lt;div&gt;Expensive Calculation Result: {result}&lt;/div&gt;;
};

export default ExpensiveCalculation;
</code></pre>
</li>
<li>
<p><strong>MemoizedCalculation Bileşenini Oluşturma:</strong></p>
<p><code>components</code> klasöründe <code>MemoizedCalculation.jsx</code> adlı bir bileşen oluşturun. Bu bileşen <code>useMemo</code> kullanarak aynı pahalı hesaplamayı optimize eder.</p>
<pre><code class="language-javascript">// MemoizedCalculation.jsx
import React, { useMemo } from 'react';

const MemoizedCalculation = ({ time }) =&gt; {
  const performExpensiveCalculation = (num) =&gt; {
    console.log('Performing memoized expensive calculation');
    // Pahalı hesaplama işlemi
    return num * 2;
  };

  const memoizedResult = useMemo(() =&gt; performExpensiveCalculation(time), [time]);

  return &lt;div&gt;Memoized Calculation Result: {memoizedResult}&lt;/div&gt;;
};

export default MemoizedCalculation;
</code></pre>
</li>
<li>
<p><strong>App Bileşenini Güncelleme:</strong></p>
<p><code>App.jsx</code> dosyasını <code>Timer</code> bileşenini içerecek şekilde güncelleyin.</p>
<pre><code class="language-javascript">// App.jsx
import React from 'react';
import Timer from './components/Timer';

const App = () =&gt; {
  return (
    &lt;div className="App"&gt;
      &lt;Timer /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
</li>
</ol>
<h3 id="uygulamanın-akışı"><a class="header" href="#uygulamanın-akışı">Uygulamanın Akışı</a></h3>
<ol>
<li>Uygulama başladığında <code>Timer</code> bileşeni render edilir. <code>timer</code> durumu 0 olarak başlatılır.</li>
<li><code>ExpensiveCalculation</code> ve <code>MemoizedCalculation</code> bileşenleri de render edilir ve <code>time</code> prop'u 0'dır. Her iki bileşen de pahalı hesaplamayı gerçekleştirir.</li>
<li>Konsol, "Performing expensive calculation" ve "Performing memoized expensive calculation" mesajlarını gösterir.</li>
<li>"Tick" butonuna tıkladığınızda, <code>Timer</code> bileşeninin <code>time</code> durumu 1 artar ve bu bileşen ve çocuk bileşenleri yeniden render edilir.</li>
<li><code>ExpensiveCalculation</code> bileşeni, <code>time</code> prop'u değişmese bile pahalı hesaplamayı yeniden yapar. Konsol "Performing expensive calculation" mesajını tekrar gösterir.</li>
<li><code>MemoizedCalculation</code> bileşeni, <code>time</code> prop'u değişip değişmediğini kontrol eder. Eğer değişmişse, pahalı hesaplamayı yeniden yapar ve konsol "Performing memoized expensive calculation" mesajını gösterir. Eğer değişmemişse, pahalı hesaplamayı atlar.</li>
<li>Her "Tick" butonuna tıkladığınızda, bu adımlar tekrarlanır.</li>
</ol>
<h3 id="sonuç-33"><a class="header" href="#sonuç-33">Sonuç</a></h3>
<p><code>useMemo</code>, bağımlılıkları değişmediği sürece pahalı hesaplamaları atlayarak uygulamayı optimize etmeye yardımcı olur. Bu sayede, <code>MemoizedCalculation</code> bileşeni, <code>time</code> prop'u değişmediğinde hesaplamayı yeniden yapmaz, bu da performans iyileştirmesi sağlar.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kullanıcı-listesi-uygulaması-İnşası"><a class="header" href="#kullanıcı-listesi-uygulaması-İnşası">Kullanıcı Listesi Uygulaması İnşası</a></h2>
<h3 id="amaç-6"><a class="header" href="#amaç-6">Amaç:</a></h3>
<p>Bu eğitimde, React performansını optimize etmek için çeşitli teknikler uygulanacaktır. Memoization, PureComponent ve useCallback kullanarak, React bileşenlerinin render verimliliğini artıracak ve web uygulamanızın genel performansını geliştireceksiniz. <strong>Tailwind CSS</strong> kullanarak daha iyi görselleştirme sağlayın.</p>
<h3 id="gereksinimler-14"><a class="header" href="#gereksinimler-14">Gereksinimler:</a></h3>
<ol>
<li>İçinde karmaşık bir bileşen ve bu bileşenin alt bileşenlerini içeren bir React uygulaması oluşturun.</li>
<li>Şu API'yi kullanabilirsiniz: <a href="https://jsonplaceholder.typicode.com/users">JSONPlaceholder Kullanıcı API'si</a></li>
<li>Bileşenlerin render edilmesini optimize etmek için memoization uygulayın. Memoization, pahalı hesaplamaların yalnızca gerektiğinde yürütülmesini sağlar.</li>
<li>Shallow equality (yüzeysel eşitlik) kontrollerine dayanan prop ve state'ler için bileşenlerin render edilmesini optimize etmek için PureComponent sınıfını kullanın. PureComponent, gereksiz yeniden render edilmeleri otomatik prop ve state karşılaştırmaları yaparak azaltır.</li>
<li>Bileşenlerinizde event handler veya callback fonksiyonlarını memoize etmek için useCallback hook'unu kullanın. Bu, her render işleminde fonksiyonların gereksiz yere yeniden oluşturulmasını önler.</li>
<li>Bileşenlerin yalnızca gerektiğinde yeniden render edilmesini sağlamak için uygun prop ve state yönetim tekniklerini uygulayın.</li>
<li>Bileşenlerinizi stilize etmek ve uygulamanızın görsel çekiciliğini artırmak için Tailwind CSS kullanın.</li>
<li>Bu teknikleri uygulayarak elde edilen performans iyileştirmelerini React Developer Tools veya diğer ilgili performans izleme araçlarıyla test edin.</li>
<li>Her optimizasyon tekniğinin uygulamanızın genel performansı üzerindeki etkisini açıklayan kısa bir rapor yazın.</li>
<li>Uygulamanın farklı cihaz ve tarayıcılarda doğru şekilde çalışmasını, erişilebilir olmasını ve responsive olmasını sağlayın.</li>
<li>Her bileşenin ve optimizasyon tekniğinin amacını ve işlevselliğini açıklayan net ve özlü kod belgeleri sağlayın.</li>
</ol>
<h3 id="adım-adım-eğitim-1"><a class="header" href="#adım-adım-eğitim-1">Adım Adım Eğitim:</a></h3>
<h4 id="1-react-uygulamasının-kurulumu-1"><a class="header" href="#1-react-uygulamasının-kurulumu-1">1. React Uygulamasının Kurulumu</a></h4>
<p>Öncelikle, React projesini başlatmak için aşağıdaki komutları çalıştırın:</p>
<pre><code class="language-bash">npx create-react-app user-list-app
cd user-list-app
npm start
</code></pre>
<h4 id="2-apiden-kullanıcı-verilerini-Çekmek"><a class="header" href="#2-apiden-kullanıcı-verilerini-Çekmek">2. API'den Kullanıcı Verilerini Çekmek</a></h4>
<p><code>src</code> klasöründe <code>components</code> adında bir klasör oluşturun ve içine <code>UserList.js</code> adında bir dosya ekleyin. API'den kullanıcı verilerini çekmek için aşağıdaki kodu ekleyin:</p>
<pre><code class="language-jsx">// src/components/UserList.js
import React, { useState, useEffect, memo } from 'react';

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(response =&gt; response.json())
      .then(data =&gt; setUsers(data));
  }, []);

  return (
    &lt;div className="p-4"&gt;
      &lt;h1 className="text-2xl font-bold mb-4"&gt;User List&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id} className="mb-2 p-2 border rounded"&gt;
            {user.name}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default memo(UserList);
</code></pre>
<h4 id="3-memoization-ile-optimizasyon"><a class="header" href="#3-memoization-ile-optimizasyon">3. Memoization ile Optimizasyon</a></h4>
<p><code>UserList</code> bileşeninin <code>memo</code> ile sarılarak, yalnızca <code>users</code> değiştiğinde yeniden render edilmesini sağladık. Bu, performansı artırır.</p>
<h4 id="4-purecomponent-kullanımı"><a class="header" href="#4-purecomponent-kullanımı">4. PureComponent Kullanımı</a></h4>
<p>Alt bileşenlerden birinde <code>PureComponent</code> kullanarak optimizasyon yapalım:</p>
<pre><code class="language-jsx">// src/components/User.js
import React, { PureComponent } from 'react';

class User extends PureComponent {
  render() {
    const { user } = this.props;
    return (
      &lt;li className="mb-2 p-2 border rounded"&gt;
        {user.name}
      &lt;/li&gt;
    );
  }
}

export default User;
</code></pre>
<p>Ve <code>UserList.js</code> dosyasını aşağıdaki gibi güncelleyin:</p>
<pre><code class="language-jsx">// src/components/UserList.js
import React, { useState, useEffect, memo } from 'react';
import User from './User';

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(response =&gt; response.json())
      .then(data =&gt; setUsers(data));
  }, []);

  return (
    &lt;div className="p-4"&gt;
      &lt;h1 className="text-2xl font-bold mb-4"&gt;User List&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;User key={user.id} user={user} /&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default memo(UserList);
</code></pre>
<h4 id="5-usecallback-kullanımı"><a class="header" href="#5-usecallback-kullanımı">5. useCallback Kullanımı</a></h4>
<p><code>useCallback</code> kullanarak, event handler fonksiyonlarını memoize edelim:</p>
<pre><code class="language-jsx">// src/components/UserList.js
import React, { useState, useEffect, memo, useCallback } from 'react';
import User from './User';

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);
  const [search, setSearch] = useState('');

  useEffect(() =&gt; {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(response =&gt; response.json())
      .then(data =&gt; setUsers(data));
  }, []);

  const handleSearch = useCallback((event) =&gt; {
    setSearch(event.target.value);
  }, []);

  const filteredUsers = users.filter(user =&gt;
    user.name.toLowerCase().includes(search.toLowerCase())
  );

  return (
    &lt;div className="p-4"&gt;
      &lt;h1 className="text-2xl font-bold mb-4"&gt;User List&lt;/h1&gt;
      &lt;input
        type="text"
        value={search}
        onChange={handleSearch}
        className="mb-4 p-2 border rounded"
        placeholder="Search users"
      /&gt;
      &lt;ul&gt;
        {filteredUsers.map(user =&gt; (
          &lt;User key={user.id} user={user} /&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default memo(UserList);
</code></pre>
<h4 id="6-tailwind-css-entegrasyonu"><a class="header" href="#6-tailwind-css-entegrasyonu">6. Tailwind CSS Entegrasyonu</a></h4>
<p>Tailwind CSS'i projenize ekleyin:</p>
<pre><code class="language-bash">npm install tailwindcss
npx tailwindcss init
</code></pre>
<p><code>tailwind.config.js</code> dosyasını aşağıdaki gibi güncelleyin:</p>
<pre><code class="language-js">// tailwind.config.js
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'],
  theme: {
    extend: {},
  },
  plugins: [],
};
</code></pre>
<p><code>src/index.css</code> dosyasını güncelleyin:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h4 id="7-performans-testleri"><a class="header" href="#7-performans-testleri">7. Performans Testleri</a></h4>
<p>React Developer Tools veya diğer performans izleme araçları ile optimizasyon tekniklerinin etkisini test edin.</p>
<h4 id="8-rapor-yazımı"><a class="header" href="#8-rapor-yazımı">8. Rapor Yazımı</a></h4>
<p>Her optimizasyon tekniğinin uygulamanızın genel performansı üzerindeki etkisini açıklayan kısa bir rapor yazın.</p>
<h4 id="9-responsive-ve-erişilebilirlik"><a class="header" href="#9-responsive-ve-erişilebilirlik">9. Responsive ve Erişilebilirlik</a></h4>
<p>Uygulamanın farklı cihaz ve tarayıcılarda doğru şekilde çalışmasını, erişilebilir olmasını ve responsive olmasını sağlayın.</p>
<h4 id="10-kod-dokümantasyonu"><a class="header" href="#10-kod-dokümantasyonu">10. Kod Dokümantasyonu</a></h4>
<p>Her bileşenin ve optimizasyon tekniğinin amacını ve işlevselliğini açıklayan net ve özlü kod belgeleri sağlayın.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-custom-hook"><a class="header" href="#react-custom-hook">React Custom Hook</a></h1>
<h2 id="giriş-30"><a class="header" href="#giriş-30">Giriş</a></h2>
<p>React'te özel kancalar (custom hooks), durumsal mantığı birden fazla bileşen arasında kodu tekrarlamadan yeniden kullanmanıza olanak tanıyan fonksiyonlardır. Genellikle "use" öneki ile başlarlar ve ardından özel kancanın adı gelir.</p>
<h2 id="Özel-kancalara-neden-İhtiyaç-duyarız"><a class="header" href="#Özel-kancalara-neden-İhtiyaç-duyarız">Özel Kancalara Neden İhtiyaç Duyarız?</a></h2>
<p>Özel kancalar, bileşenler arasında ortak işlevselliği çıkarmanıza ve paylaşmanıza olanak tanır. Bu, kodunuzu daha modüler, yeniden kullanılabilir ve bakımının kolay olmasını sağlar.</p>
<h2 id="Örnek-sayaç-durumunu-yöneten-bir-Özel-kanca"><a class="header" href="#Örnek-sayaç-durumunu-yöneten-bir-Özel-kanca">Örnek: Sayaç Durumunu Yöneten Bir Özel Kanca</a></h2>
<h3 id="adım-adım-İşlem"><a class="header" href="#adım-adım-İşlem">Adım Adım İşlem:</a></h3>
<ol>
<li>
<p><strong>Yeni Bir Klasör Oluşturun:</strong>
<code>src</code> klasörünüzde, <code>components</code> adında yeni bir klasör oluşturun (eğer zaten mevcut değilse).</p>
</li>
<li>
<p><strong>useCounter.jsx Dosyasını Oluşturun:</strong>
<code>components</code> klasörünün içine <code>useCounter.jsx</code> adlı yeni bir dosya oluşturun.</p>
</li>
<li>
<p><strong>SampleCounter.jsx Dosyasını Oluşturun:</strong>
<code>components</code> klasörünün içine <code>SampleCounter.jsx</code> adlı yeni bir dosya oluşturun.</p>
</li>
<li>
<p><strong>SampleCounter Bileşenini App.js İçine Dahil Edin:</strong>
<code>App.js</code> dosyanıza <code>SampleCounter</code> bileşenini dahil edin ve kullanın.</p>
</li>
</ol>
<h3 id="kod-akışı"><a class="header" href="#kod-akışı">Kod Akışı:</a></h3>
<ol>
<li>
<p><strong>useCounter Kancasını Oluşturma:</strong>
<code>useCounter</code> adlı özel bir kanca oluşturun. Bu kanca, opsiyonel bir <code>initialValue</code> argümanını kabul eder ve <code>useState</code> kullanarak bir sayacın durumunu yönetir.</p>
</li>
<li>
<p><strong>İşlevleri Tanımlama:</strong>
<code>useCounter</code> içinde, <code>count</code> durumunu manipüle etmek için <code>increment</code>, <code>decrement</code> ve <code>reset</code> işlevlerini tanımlayın.</p>
</li>
<li>
<p><strong>Değerlerin Geri Dönüşü:</strong>
<code>useCounter</code> kancası, <code>count</code> durumu ve <code>increment</code>, <code>decrement</code>, <code>reset</code> işlevlerini içeren bir nesne döner.</p>
</li>
<li>
<p><strong>Counter Bileşeninde Kullanım:</strong>
<code>Counter</code> bileşeninde, özel kancayı <code>const { count, increment, decrement, reset } = useCounter(0);</code> şeklinde çağırarak kullanın.</p>
</li>
<li>
<p><strong>Render İşlemi:</strong>
<code>Counter</code> bileşeni, mevcut sayacın değerini ve sayacı artırmak, azaltmak ve sıfırlamak için üç buton render eder. Buton tıklama olayları, <code>useCounter</code> özel kancası tarafından sağlanan ilgili işlevlere bağlanmıştır.</p>
</li>
</ol>
<h2 id="kaynak-kod"><a class="header" href="#kaynak-kod">Kaynak Kod</a></h2>
<p>Aşağıda, yukarıda açıklanan özel kanca ve bileşenlerin kaynak kodu bulunmaktadır:</p>
<p><strong>useCounter.jsx</strong></p>
<pre><code class="language-jsx">import { useState } from 'react';

const useCounter = (initialValue = 0) =&gt; {
  const [count, setCount] = useState(initialValue);

  const increment = () =&gt; setCount(count + 1);
  const decrement = () =&gt; setCount(count - 1);
  const reset = () =&gt; setCount(initialValue);

  return {
    count,
    increment,
    decrement,
    reset
  };
};

export default useCounter;
</code></pre>
<p><strong>SampleCounter.jsx</strong></p>
<pre><code class="language-jsx">import React from 'react';
import useCounter from './useCounter';

const SampleCounter = () =&gt; {
  const { count, increment, decrement, reset } = useCounter(0);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;
      &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default SampleCounter;
</code></pre>
<p><strong>App.js</strong></p>
<pre><code class="language-jsx">import React from 'react';
import SampleCounter from './components/SampleCounter';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;SampleCounter /&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<p>Bu eğitim, React'te özel kancaların nasıl oluşturulacağını ve kullanılacağını kapsamlı bir şekilde ele almaktadır. Kodunuzu daha modüler ve yeniden kullanılabilir hale getirmek için özel kancaları etkin bir şekilde kullanmayı öğrenmek, daha temiz ve sürdürülebilir bir kod tabanına sahip olmanıza yardımcı olacaktır.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Özel-hooklar-ne-zaman-ve-neden-oluşturulmalıdır"><a class="header" href="#Özel-hooklar-ne-zaman-ve-neden-oluşturulmalıdır">Özel Hook'lar Ne Zaman ve Neden Oluşturulmalıdır?</a></h1>
<h2 id="Özel-hooklar-ne-zaman-oluşturulmalı"><a class="header" href="#Özel-hooklar-ne-zaman-oluşturulmalı">Özel Hook'lar Ne Zaman Oluşturulmalı?</a></h2>
<h3 id="1-kod-tekrarı"><a class="header" href="#1-kod-tekrarı">1. Kod Tekrarı</a></h3>
<p>Birden fazla bileşende benzer durumsal mantık veya yan etkiler fark ettiğinizde, bu mantığı çıkarmak ve yeniden kullanmak için özel bir hook oluşturmak iyi bir fikirdir.</p>
<h3 id="2-sorumlulukların-ayrılması"><a class="header" href="#2-sorumlulukların-ayrılması">2. Sorumlulukların Ayrılması</a></h3>
<p>Bir bileşen çok karmaşık hale geldiğinde ve birden fazla sorumluluk üstlendiğinde, özel hook'lar oluşturarak farklı sorumlulukları ayırabilir ve bileşeni daha yönetilebilir hale getirebilirsiniz.</p>
<h3 id="3-yeniden-kullanılabilir-mantık"><a class="header" href="#3-yeniden-kullanılabilir-mantık">3. Yeniden Kullanılabilir Mantık</a></h3>
<p>Uygulamanızda veya farklı projeler arasında kolayca paylaşılabilecek yeniden kullanılabilir bir mantık oluşturmak istediğinizde özel hook'lar kullanabilirsiniz.</p>
<h3 id="4-harici-api-Çağrılarının-soyutlanması"><a class="header" href="#4-harici-api-Çağrılarının-soyutlanması">4. Harici API Çağrılarının Soyutlanması</a></h3>
<p>Harici hizmetlere API çağrıları yaparken, özel bir hook ağ isteklerini, yüklenme durumlarını ve hata işlemlerini yönetebilir, uygulama detaylarını soyutlayarak veri alma için tutarlı bir arayüz sağlayabilir.</p>
<h3 id="5-tarayıcı-apilerine-erişim"><a class="header" href="#5-tarayıcı-apilerine-erişim">5. Tarayıcı API'lerine Erişim</a></h3>
<p>Geolocation, local storage veya clipboard API gibi tarayıcıya özgü API'leri kapsüllemek için özel hook'lar kullanabilir, bu işlevselliklere daha rahat ve tutarlı bir şekilde erişim sağlayabilirsiniz.</p>
<h2 id="Özel-hooklar-neden-oluşturulmalı"><a class="header" href="#Özel-hooklar-neden-oluşturulmalı">Özel Hook'lar Neden Oluşturulmalı?</a></h2>
<h3 id="1-kod-yeniden-kullanılabilirliği"><a class="header" href="#1-kod-yeniden-kullanılabilirliği">1. Kod Yeniden Kullanılabilirliği</a></h3>
<p>Özel hook'lar, durumsal mantığı birden fazla bileşen arasında yeniden kullanmanızı sağlar, kod tekrarını azaltır ve kod tabanını daha sürdürülebilir hale getirir.</p>
<h3 id="2-modülerlik"><a class="header" href="#2-modülerlik">2. Modülerlik</a></h3>
<p>İlgili mantığı özel hook'lara kapsülleyerek daha modüler bir kod tabanı oluşturabilirsiniz, bu da anlamayı, test etmeyi ve sürdürmeyi kolaylaştırır.</p>
<h3 id="3-daha-kolay-test-edilebilirlik"><a class="header" href="#3-daha-kolay-test-edilebilirlik">3. Daha Kolay Test Edilebilirlik</a></h3>
<p>Özel hook'lar, bileşeni kullanan bileşenden bağımsız olarak hook'un mantığını test etmenizi kolaylaştırır.</p>
<h3 id="4-gelişmiş-okunabilirlik"><a class="header" href="#4-gelişmiş-okunabilirlik">4. Gelişmiş Okunabilirlik</a></h3>
<p>Özel hook'lar, karmaşık mantığı ayrı, iyi adlandırılmış fonksiyonlara ayırarak bileşenlerinizin okunabilirliğini artırabilir.</p>
<h3 id="5-daha-İyi-İşbirliği"><a class="header" href="#5-daha-İyi-İşbirliği">5. Daha İyi İşbirliği</a></h3>
<p>Özel hook'lar, geliştiricilerin ortak işlevselliği kolayca paylaşmasını ve yeniden kullanmasını sağlayarak takım içi işbirliğini teşvik edebilir.</p>
<h2 id="Özel-hookların-oluşturulması-ve-kullanımı"><a class="header" href="#Özel-hookların-oluşturulması-ve-kullanımı">Özel Hook'ların Oluşturulması ve Kullanımı</a></h2>
<p>Aşağıda, özel hook'ların nasıl oluşturulacağı ve kullanılacağına dair örnekler sunulmaktadır. Her bir örnek, belirli bir kullanım senaryosuna odaklanmakta ve ilgili kod parçacıkları ile desteklenmektedir.</p>
<h2 id="kod-tekrarının-azaltılması"><a class="header" href="#kod-tekrarının-azaltılması">Kod Tekrarının Azaltılması</a></h2>
<pre><code class="language-javascript">import { useState, useEffect } from 'react';

function useFetchData(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      try {
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);

  return { data, loading, error };
}
</code></pre>
<h2 id="sorumlulukların-ayrılması"><a class="header" href="#sorumlulukların-ayrılması">Sorumlulukların Ayrılması</a></h2>
<pre><code class="language-javascript">function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = () =&gt; setCount(count + 1);
  const decrement = () =&gt; setCount(count - 1);

  return { count, increment, decrement };
}

// Kullanım
function CounterComponent() {
  const { count, increment, decrement } = useCounter(10);

  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;Increase&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Decrease&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="yeniden-kullanılabilir-mantığın-oluşturulması"><a class="header" href="#yeniden-kullanılabilir-mantığın-oluşturulması">Yeniden Kullanılabilir Mantığın Oluşturulması</a></h2>
<pre><code class="language-javascript">import { useState } from 'react';

function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = () =&gt; setValue(!value);

  return [value, toggle];
}

// Kullanım
function ToggleComponent() {
  const [isToggled, toggle] = useToggle();

  return (
    &lt;div&gt;
      &lt;p&gt;{isToggled ? 'On' : 'Off'}&lt;/p&gt;
      &lt;button onClick={toggle}&gt;Toggle&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="harici-api-Çağrılarının-soyutlanması"><a class="header" href="#harici-api-Çağrılarının-soyutlanması">Harici API Çağrılarının Soyutlanması</a></h2>
<pre><code class="language-javascript">import { useState, useEffect } from 'react';

function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      try {
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);

  return { data, loading, error };
}

// Kullanım
function ApiComponent() {
  const { data, loading, error } = useApi('https://api.example.com/data');

  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;
  if (error) return &lt;p&gt;Error: {error.message}&lt;/p&gt;;

  return (
    &lt;div&gt;
      &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="tarayıcı-apilerine-erişim"><a class="header" href="#tarayıcı-apilerine-erişim">Tarayıcı API'lerine Erişim</a></h2>
<pre><code class="language-javascript">import { useState, useEffect } from 'react';

function useGeolocation() {
  const [location, setLocation] = useState({ latitude: null, longitude: null });
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    if (!navigator.geolocation) {
      setError('Geolocation is not supported by your browser');
      return;
    }

    const handleSuccess = (position) =&gt; {
      const { latitude, longitude } = position.coords;
      setLocation({ latitude, longitude });
    };

    const handleError = (error) =&gt; {
      setError(error.message);
    };

    navigator.geolocation.getCurrentPosition(handleSuccess, handleError);
  }, []);

  return { location, error };
}

// Kullanım
function GeolocationComponent() {
  const { location, error } = useGeolocation();

  if (error) return &lt;p&gt;Error: {error}&lt;/p&gt;;
  if (!location.latitude) return &lt;p&gt;Loading...&lt;/p&gt;;

  return (
    &lt;div&gt;
      &lt;p&gt;Latitude: {location.latitude}&lt;/p&gt;
      &lt;p&gt;Longitude: {location.longitude}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>Bu eğitimde, React uygulamalarında özel hook'ların ne zaman ve neden kullanılacağı ve bu hook'ların nasıl oluşturulacağı detaylı bir şekilde ele alınmıştır. Bu bilgiler, yazılım geliştiricilerinin daha modüler, test edilebilir ve sürdürülebilir kodlar yazmalarına yardımcı olacaktır.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Özel-form-doğrulama-hooku-oluşturma"><a class="header" href="#Özel-form-doğrulama-hooku-oluşturma">Özel Form Doğrulama Hook'u Oluşturma</a></h1>
<p>Bu eğitim, React kullanarak özel bir form doğrulama hook'u oluşturma sürecini kapsamaktadır. Eğitim boyunca, sağlanan PDF'deki gereksinimlere dayanarak, adım adım bir rehber sunulacaktır. İçeriğin ciddiyetini ve bilimsel doğruluğunu korumak amacıyla resmi bir dil kullanılacaktır.</p>
<h2 id="giriş-31"><a class="header" href="#giriş-31">Giriş</a></h2>
<p>Bu eğitimin amacı, form girişlerinin doğrulanmasını sağlayan özel bir React hook'u (useFormValidation) oluşturmaktır. Bu hook, form verilerinin bütünlüğünü sağlamaya ve web sitesi formlarının kullanıcı deneyimini iyileştirmeye yardımcı olacaktır. Hook, Tailwind CSS kullanarak form girdilerini, hata mesajlarını ve genel form düzenini görsel olarak çekici hale getirecektir.</p>
<h2 id="gereksinimler-15"><a class="header" href="#gereksinimler-15">Gereksinimler</a></h2>
<ol>
<li><strong>useFormValidation</strong> adında özel bir hook oluşturulmalıdır.</li>
<li>Tailwind CSS sınıfları kullanılarak form girdileri, hata mesajları ve form düzeni stillendirilmelidir.</li>
<li>Hook, form değerleri için başlangıç durumunu ve her form alanı için doğrulama kurallarını tanımlayan bir nesneyi kabul etmelidir.</li>
<li>Hook, güncel form değerlerini, geçersiz girişler için hata mesajlarını, form değerlerini güncellemek için bir fonksiyonu ve form gönderimini işlemek için bir fonksiyonu döndürmelidir.</li>
<li>Doğrulama kuralları, zorunlu alanlar, minimum ve maksimum uzunluk, sayısal değerler, e-posta formatı gibi yaygın doğrulama senaryolarını desteklemelidir.</li>
<li>Tailwind CSS yardımcı sınıfları kullanılarak geçersiz girdiler için dinamik hata mesajları görüntülenmeli, hatalar renk veya sınır değişiklikleriyle vurgulanmalıdır.</li>
<li>Form düzeni, farklı ekran boyutlarında görsel olarak çekici olacak şekilde Tailwind CSS duyarlı sınıfları kullanılarak oluşturulmalıdır.</li>
<li>useFormValidation hook'unu kullanan ve birden çok giriş alanını doğrulayan örnek bir React bileşeni oluşturulmalıdır.</li>
<li>Kullanıcı veri girişi yapmadığında butonun içeriği değiştirilmelidir.</li>
</ol>
<h2 id="adım-adım-uygulama-8"><a class="header" href="#adım-adım-uygulama-8">Adım Adım Uygulama</a></h2>
<h3 id="1-proje-kurulumu-1"><a class="header" href="#1-proje-kurulumu-1">1. Proje Kurulumu</a></h3>
<p>İlk olarak, yeni bir React projesi oluşturalım ve Tailwind CSS'i projeye ekleyelim.</p>
<pre><code class="language-bash">npx create-react-app form-validator
cd form-validator
npm install tailwindcss
npx tailwindcss init
</code></pre>
<p>Tailwind CSS konfigürasyonunu <code>tailwind.config.js</code> dosyasına ekleyin:</p>
<pre><code class="language-javascript">module.exports = {
  purge: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'],
  darkMode: false,
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
}
</code></pre>
<p>Tailwind CSS'i <code>src/index.css</code> dosyasına ekleyin:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h3 id="2-useformvalidation-hooku-oluşturma"><a class="header" href="#2-useformvalidation-hooku-oluşturma">2. useFormValidation Hook'u Oluşturma</a></h3>
<p><code>src/hooks</code> klasöründe <code>useFormValidation.js</code> dosyasını oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-javascript">import { useState } from 'react';

const useFormValidation = (initialState, validate) =&gt; {
  const [values, setValues] = useState(initialState);
  const [errors, setErrors] = useState({});

  const handleChange = (event) =&gt; {
    const { name, value } = event.target;
    setValues({
      ...values,
      [name]: value,
    });
  };

  const handleSubmit = (event) =&gt; {
    event.preventDefault();
    const validationErrors = validate(values);
    setErrors(validationErrors);
  };

  return {
    values,
    errors,
    handleChange,
    handleSubmit,
  };
};

export default useFormValidation;
</code></pre>
<h3 id="3-doğrulama-fonksiyonunun-oluşturulması"><a class="header" href="#3-doğrulama-fonksiyonunun-oluşturulması">3. Doğrulama Fonksiyonunun Oluşturulması</a></h3>
<p>Doğrulama kurallarını içeren bir fonksiyon oluşturun. Bu fonksiyon, form değerlerini kontrol edecek ve geçersiz girdiler için hata mesajları döndürecektir.</p>
<p><code>src/utils/validation.js</code> dosyasını oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-javascript">const validate = (values) =&gt; {
  let errors = {};

  if (!values.name) {
    errors.name = 'İsim zorunludur';
  } else if (values.name.length &lt; 3) {
    errors.name = 'İsim en az 3 karakter olmalıdır';
  }

  if (!values.email) {
    errors.email = 'E-posta zorunludur';
  } else if (!/\S+@\S+\.\S+/.test(values.email)) {
    errors.email = 'Geçersiz e-posta adresi';
  }

  if (!values.password) {
    errors.password = 'Şifre zorunludur';
  } else if (values.password.length &lt; 6) {
    errors.password = 'Şifre en az 6 karakter olmalıdır';
  }

  return errors;
};

export default validate;
</code></pre>
<h3 id="4-Örnek-react-bileşeni-oluşturma"><a class="header" href="#4-Örnek-react-bileşeni-oluşturma">4. Örnek React Bileşeni Oluşturma</a></h3>
<p>Örnek bir React bileşeni oluşturarak useFormValidation hook'unu ve doğrulama fonksiyonunu kullanın.</p>
<p><code>src/components/Form.js</code> dosyasını oluşturun ve aşağıdaki kodu ekleyin:</p>
<pre><code class="language-javascript">import React from 'react';
import useFormValidation from '../hooks/useFormValidation';
import validate from '../utils/validation';

const INITIAL_STATE = {
  name: '',
  email: '',
  password: '',
};

const Form = () =&gt; {
  const { values, errors, handleChange, handleSubmit } = useFormValidation(INITIAL_STATE, validate);

  return (
    &lt;form onSubmit={handleSubmit} className="max-w-lg mx-auto mt-10"&gt;
      &lt;div className="mb-4"&gt;
        &lt;label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="name"&gt;
          İsim
        &lt;/label&gt;
        &lt;input
          type="text"
          name="name"
          id="name"
          className={`shadow appearance-none border ${errors.name ? 'border-red-500' : ''} rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline`}
          value={values.name}
          onChange={handleChange}
        /&gt;
        {errors.name &amp;&amp; &lt;p className="text-red-500 text-xs italic"&gt;{errors.name}&lt;/p&gt;}
      &lt;/div&gt;
      &lt;div className="mb-4"&gt;
        &lt;label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="email"&gt;
          E-posta
        &lt;/label&gt;
        &lt;input
          type="email"
          name="email"
          id="email"
          className={`shadow appearance-none border ${errors.email ? 'border-red-500' : ''} rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline`}
          value={values.email}
          onChange={handleChange}
        /&gt;
        {errors.email &amp;&amp; &lt;p className="text-red-500 text-xs italic"&gt;{errors.email}&lt;/p&gt;}
      &lt;/div&gt;
      &lt;div className="mb-4"&gt;
        &lt;label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="password"&gt;
          Şifre
        &lt;/label&gt;
        &lt;input
          type="password"
          name="password"
          id="password"
          className={`shadow appearance-none border ${errors.password ? 'border-red-500' : ''} rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline`}
          value={values.password}
          onChange={handleChange}
        /&gt;
        {errors.password &amp;&amp; &lt;p className="text-red-500 text-xs italic"&gt;{errors.password}&lt;/p&gt;}
      &lt;/div&gt;
      &lt;button
        type="submit"
        className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
        disabled={!values.name || !values.email || !values.password}
      &gt;
        Gönder
      &lt;/button&gt;
    &lt;/form&gt;
  );
};

export default Form;
</code></pre>
<h3 id="5-appjs-dosyasını-güncelleme"><a class="header" href="#5-appjs-dosyasını-güncelleme">5. App.js Dosyasını Güncelleme</a></h3>
<p>Son olarak, <code>src/App.js</code> dosyasını güncelleyerek Form bileşenini ekleyin:</p>
<pre><code class="language-javascript">import React from 'react';
import Form from './components/Form';

const App = () =&gt; {
  return (
    &lt;div className="App"&gt;
      &lt;Form /&gt;
    &lt;/div&gt;
  );
};

export default App;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="perfomance-optimization-in-react"><a class="header" href="#perfomance-optimization-in-react">Perfomance Optimization in React</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-performans-optimizasyonu"><a class="header" href="#react-performans-optimizasyonu">React Performans Optimizasyonu</a></h1>
<p>Bu eğitim, React uygulamalarında performans optimizasyonunu ele almak için kapsamlı ve ayrıntılı bir kılavuz sunmaktadır. Her bir öneriyi, kod örnekleri ile destekleyerek detaylandıracağız.</p>
<h2 id="1-durum-güncellemelerini-optimizasyon"><a class="header" href="#1-durum-güncellemelerini-optimizasyon">1. Durum Güncellemelerini Optimizasyon</a></h2>
<p>React bileşenlerinin gereksiz yere yeniden render edilmesini önlemek için durum güncellemelerinin yalnızca gerekli olduğunda yapılması önemlidir. Bu, performansın iyileştirilmesine yardımcı olur.</p>
<h2 id="Öneriler"><a class="header" href="#Öneriler">Öneriler</a></h2>
<ul>
<li><strong>Fonksiyonel Güncellemeler ve Spread Operatörü Kullanımı</strong>: Mevcut nesneleri değiştirmek yerine, yeni nesneler oluşturmak için spread operatörünü kullanın.</li>
</ul>
<pre><code class="language-javascript">const [state, setState] = useState(initialState);

// Durum güncellemesi örneği
setState(prevState =&gt; ({
    ...prevState,
    updatedProperty: newValue
}));
</code></pre>
<h2 id="2-lazy-loading-ve-kod-parçalama-code-splitting"><a class="header" href="#2-lazy-loading-ve-kod-parçalama-code-splitting">2. Lazy Loading ve Kod Parçalama (Code Splitting)</a></h2>
<p>Uygulamanızı daha küçük parçalara bölmek, başlangıç yükleme süresini önemli ölçüde azaltabilir. Bu, özellikle büyük ve karmaşık uygulamalar için faydalıdır.</p>
<h2 id="Öneriler-1"><a class="header" href="#Öneriler-1">Öneriler</a></h2>
<ul>
<li><strong>React.lazy() ve React.Suspense Kullanımı</strong>:</li>
</ul>
<pre><code class="language-javascript">const LazyComponent = React.lazy(() =&gt; import('./LazyComponent'));

function MyComponent() {
    return (
        &lt;React.Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
            &lt;LazyComponent /&gt;
        &lt;/React.Suspense&gt;
    );
}
</code></pre>
<h2 id="3-sanallaştırılmış-liste-kullanımı"><a class="header" href="#3-sanallaştırılmış-liste-kullanımı">3. Sanallaştırılmış Liste Kullanımı</a></h2>
<p>Uzun listeleri render etmek, performans üzerinde büyük bir yük oluşturabilir. Yalnızca görünümde olan öğeleri render etmek, performansı büyük ölçüde artırır.</p>
<h2 id="Öneriler-2"><a class="header" href="#Öneriler-2">Öneriler</a></h2>
<ul>
<li><strong>react-window veya react-virtualized Kullanımı</strong>:</li>
</ul>
<pre><code class="language-javascript">import { FixedSizeList as List } from 'react-window';

const Row = ({ index, style }) =&gt; (
    &lt;div style={style}&gt;
        Row {index}
    &lt;/div&gt;
);

const MyList = () =&gt; (
    &lt;List
        height={150}
        itemCount={1000}
        itemSize={35}
        width={300}
    &gt;
        {Row}
    &lt;/List&gt;
);
</code></pre>
<h2 id="4-usecallback-ve-usememo-hooklarını-kullanma"><a class="header" href="#4-usecallback-ve-usememo-hooklarını-kullanma">4. useCallback() ve useMemo() Hook'larını Kullanma</a></h2>
<p>Bu hook'lar, fonksiyonları ve değerleri memoize ederek gereksiz yeniden render veya yeniden hesaplamaların önüne geçer.</p>
<h2 id="Öneriler-3"><a class="header" href="#Öneriler-3">Öneriler</a></h2>
<ul>
<li><strong>useCallback() ile Fonksiyonları Memoize Etme</strong>:</li>
</ul>
<pre><code class="language-javascript">const memoizedCallback = useCallback(() =&gt; {
    doSomething(a, b);
}, [a, b]);
</code></pre>
<ul>
<li><strong>useMemo() ile Hesaplanmış Değerleri Memoize Etme</strong>:</li>
</ul>
<pre><code class="language-javascript">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);
</code></pre>
<h2 id="5-react-devtools-kullanımı"><a class="header" href="#5-react-devtools-kullanımı">5. React DevTools Kullanımı</a></h2>
<p>React Developer Tools uzantısını kullanarak uygulamanızın profilini çıkarabilir ve performans darboğazlarını tespit edebilirsiniz. Profiler API'sini kullanarak bileşenlerinizin render sürelerini programlı olarak ölçebilirsiniz.</p>
<h2 id="Öneriler-4"><a class="header" href="#Öneriler-4">Öneriler</a></h2>
<ul>
<li><strong>React DevTools ile Profil Oluşturma</strong>:</li>
</ul>
<pre><code class="language-javascript">import { Profiler } from 'react';

function onRenderCallback(
    id, // Profil oluşturulan bileşenin "id"si
    phase, // "mount" veya "update"
    actualDuration, // Bu güncelleme için geçen süre
    baseDuration, // Memoized durumdaki en yavaş render süresi
    startTime, // React'in bu güncellemeyi başlattığı zaman
    commitTime, // React'in bu güncellemeyi bitirdiği zaman
    interactions // Bu güncellemeyi tetikleyen etkileşimler
) {
    // Performans analizini burada yapın
}

&lt;Profiler id="Navigation" onRenderCallback={onRenderCallback}&gt;
    &lt;Navigation {...props} /&gt;
&lt;/Profiler&gt;
</code></pre>
<h2 id="6-görseller-ve-varlıkları-optimizasyon"><a class="header" href="#6-görseller-ve-varlıkları-optimizasyon">6. Görseller ve Varlıkları Optimizasyon</a></h2>
<p>Görsellerin sıkıştırılması ve uygun boyutlu görsellerin kullanılması, yükleme sürelerini azaltır. SVG veya simge fontları kullanarak ikonları optimize edebilirsiniz.</p>
<h2 id="Öneriler-5"><a class="header" href="#Öneriler-5">Öneriler</a></h2>
<ul>
<li><strong>Responsive Görseller Kullanma ve Görselleri Sıkıştırma</strong>:</li>
</ul>
<pre><code class="language-html">&lt;img srcset="image-small.jpg 480w, image-medium.jpg 800w, image-large.jpg 1200w"
     sizes="(max-width: 600px) 480px, (max-width: 1200px) 800px, 1200px"
     src="image-large.jpg" alt="Example Image"&gt;
</code></pre>
<h2 id="7-sunucu-taraflı-render-ssr-ve-statik-site-jenerasyonu-ssg"><a class="header" href="#7-sunucu-taraflı-render-ssr-ve-statik-site-jenerasyonu-ssg">7. Sunucu Taraflı Render (SSR) ve Statik Site Jenerasyonu (SSG)</a></h2>
<p>Başlangıç yükleme süresini ve SEO'yu iyileştirmek için SSR veya SSG kullanmayı düşünün. Next.js veya Gatsby gibi kütüphaneler bu konuda yardımcı olabilir.</p>
<h2 id="Öneriler-6"><a class="header" href="#Öneriler-6">Öneriler</a></h2>
<ul>
<li><strong>Next.js Kullanarak SSR ve SSG</strong>:</li>
</ul>
<pre><code class="language-javascript">// pages/index.js

export async function getStaticProps() {
    const res = await fetch('https://api.example.com/data');
    const data = await res.json();
    
    return {
        props: {
            data,
        },
    };
}

function HomePage({ data }) {
    return (
        &lt;div&gt;
            &lt;h1&gt;Data&lt;/h1&gt;
            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;
        &lt;/div&gt;
    );
}

export default HomePage;
</code></pre>
<p>Bu eğitimde belirtilen yöntemler ve kod örnekleri, React uygulamalarınızın performansını optimize etmek için kullanabileceğiniz önemli tekniklerdir. Bu teknikleri uygulayarak daha hızlı ve verimli web uygulamaları geliştirebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performans-darboğazlarını-tanımlama-ve-giderme-yöntemleri"><a class="header" href="#performans-darboğazlarını-tanımlama-ve-giderme-yöntemleri">Performans Darboğazlarını Tanımlama ve Giderme Yöntemleri</a></h1>
<p>Performans darboğazları, uygulamanızın genel performansını olumsuz etkileyen, sayfa yükleme sürelerini uzatan, yavaş etkileşimlere veya hatta çöküşlere neden olan noktalardır. Bu eğitimde, yaygın performans darboğazlarını ve bunları nasıl tanımlayabileceğinizi detaylandıracağız. Eğitim, yazılım geliştirme alanında yüksek standartlar ve titizlikle hazırlanmış olup, React uygulamaları üzerinde yoğunlaşmaktadır.</p>
<h2 id="1-yavaş-render-ve-güncellemeler"><a class="header" href="#1-yavaş-render-ve-güncellemeler">1. Yavaş Render ve Güncellemeler</a></h2>
<p><strong>React DevTools Profiler Kullanımı:</strong>
React DevTools Profiler sekmesi, bileşenlerinizin render performansını analiz etmek için kullanılır. Bu araç, en uzun sürede render veya güncelleme yapan bileşenleri gösteren bir alev grafiği ve sıralı bir liste sunar, böylece darboğazları belirleyebilirsiniz.</p>
<pre><code class="language-jsx">import React, { useState } from 'react';

function ExpensiveComponent() {
  const [count, setCount] = useState(0);

  // Simulate a heavy computation
  const expensiveCalculation = () =&gt; {
    let result = 0;
    for (let i = 0; i &lt; 1000000000; i++) {
      result += i;
    }
    return result;
  };

  return (
    &lt;div&gt;
      &lt;p&gt;{expensiveCalculation()}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increase&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default ExpensiveComponent;
</code></pre>
<p><strong>Tarayıcı Performans Araçları:</strong>
Chrome'un Performans sekmesi veya Firefox'un Performans paneli gibi tarayıcı performans araçlarını kullanarak render, script çalıştırma ve yükleme sürelerini kaydedip analiz edebilirsiniz.</p>
<h2 id="2-verimsiz-ağ-İstekleri"><a class="header" href="#2-verimsiz-ağ-İstekleri">2. Verimsiz Ağ İstekleri</a></h2>
<p><strong>Tarayıcı Ağ Araçları:</strong>
Tarayıcınızın geliştirici araçlarındaki Ağ sekmesini kullanarak uygulamanız tarafından yapılan tüm ağ isteklerini inceleyebilirsiniz. Büyük yükler, yavaş yanıt süreleri veya gereksiz istekleri arayın.</p>
<p><strong>İzleme Araçları:</strong>
Google Lighthouse, WebPageTest veya GTmetrix gibi izleme araçlarını kullanarak web uygulamanızın performansını, ağ istekleri dahil olmak üzere değerlendirebilir ve iyileştirme önerileri alabilirsiniz.</p>
<h2 id="3-verimsiz-javascript-Çalıştırma"><a class="header" href="#3-verimsiz-javascript-Çalıştırma">3. Verimsiz JavaScript Çalıştırma</a></h2>
<p><strong>Uzun Süreli İşlemler:</strong>
Ağır JavaScript işlemleri ana iş parçacığını engelleyerek uygulamanızı yanıt vermez hale getirebilir. Tarayıcı performans araçlarını kullanarak uzun süreli işlemleri veya "jank" olarak adlandırılan durumları belirleyebilir ve bunları optimize etmenin veya daha küçük görevlere bölmenin yollarını bulabilirsiniz.</p>
<p><strong>Bellek Sızıntıları:</strong>
Bellek sızıntıları, uygulamanızın artık ihtiyaç duymadığı belleği kullanmaya devam etmesi durumunda meydana gelir ve çökme veya yavaşlamalara yol açabilir. Chrome'un Bellek sekmesi gibi tarayıcı bellek araçlarını kullanarak bellek kullanımını analiz edebilir ve olası sızıntıları tespit edebilirsiniz.</p>
<h2 id="4-maliyetli-yeniden-render-ve-layout-thrashing"><a class="header" href="#4-maliyetli-yeniden-render-ve-layout-thrashing">4. Maliyetli Yeniden Render ve Layout Thrashing</a></h2>
<p><strong>React DevTools Kullanımı:</strong>
React DevTools kullanarak sık veya gereksiz yere yeniden render eden bileşenleri belirleyin. Ayrıca, Chrome'un Performans aracındaki Layout sekmesini kullanarak layout thrashing (sık layout yeniden hesaplamaları) olup olmadığını kontrol edebilirsiniz.</p>
<p><strong>Tarayıcı Performans Araçları:</strong>
Tarayıcı performans araçlarını kullanarak pahalı layout yeniden hesaplamalarını, stil yeniden hesaplamalarını veya zorunlu eşzamanlı layout işlemlerini bulun.</p>
<h2 id="5-verimsiz-durum-yönetimi"><a class="header" href="#5-verimsiz-durum-yönetimi">5. Verimsiz Durum Yönetimi</a></h2>
<p><strong>Durum Yönetimi Araçları:</strong>
Redux veya MobX gibi durum yönetim kütüphanelerini kullanırken, ilgili tarayıcı uzantılarını (örneğin, Redux DevTools) kullanarak uygulamanızdaki durum güncellemelerini görselleştirin ve analiz edin. Gereksiz durum değişiklikleri veya verimsiz güncelleme desenleri olup olmadığını kontrol edin.</p>
<pre><code class="language-jsx">import { createStore } from 'redux';
import { Provider, useDispatch, useSelector } from 'react-redux';

// Redux state slice and actions
const counterSlice = (state = 0, action) =&gt; {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    default:
      return state;
  }
};

const store = createStore(counterSlice);

function Counter() {
  const dispatch = useDispatch();
  const count = useSelector((state) =&gt; state);

  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;Increase&lt;/button&gt;
    &lt;/div&gt;
  );
}

function App() {
  return (
    &lt;Provider store={store}&gt;
      &lt;Counter /&gt;
    &lt;/Provider&gt;
  );
}

export default App;
</code></pre>
<h2 id="sonuç-34"><a class="header" href="#sonuç-34">Sonuç</a></h2>
<p>Performans darboğazlarını belirlemek ve gidermek, React uygulamanızın verimli ve kullanıcı dostu olmasını sağlamak için kritik öneme sahiptir. Yukarıda belirtilen araçlar ve yöntemler, performans sorunlarını tanımlamanıza ve çözmenize yardımcı olacaktır. Bu süreçte dikkatli analiz ve uygun optimizasyon teknikleri kullanarak, uygulamanızın performansını önemli ölçüde iyileştirebilirsiniz.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performansı-optimize-etme"><a class="header" href="#performansı-optimize-etme">Performansı Optimize Etme</a></h1>
<p>Bu eğitim, React uygulamalarının performansını optimize etmek için kullanılan teknikleri kapsamaktadır. Temel olarak, gereksiz yeniden render etmeleri en aza indirmek, bellek tüketimini azaltmak ve render sürelerini hızlandırmak üzerine odaklanacağız. Bu bağlamda memoizasyon, <code>PureComponent</code> ve <code>useCallback</code> kullanımına odaklanacağız.</p>
<h2 id="1-reactmemo"><a class="header" href="#1-reactmemo">1. React.memo</a></h2>
<p><code>React.memo</code>, işlevsel bileşenlerde gereksiz yeniden render işlemlerini önlemek için kullanılan bir memoizasyon yöntemidir. Bu yöntem, sadece giriş özellikleri değiştiğinde bileşenin yeniden render edilmesini sağlar.</p>
<h3 id="Örnek-8"><a class="header" href="#Örnek-8">Örnek:</a></h3>
<p>Basit bir işlevsel bileşen olan <code>Child</code>'ı ele alalım:</p>
<pre><code class="language-javascript">const Child = ({ text }) =&gt; {
  console.log("Child component is rendering");
  return &lt;div&gt;{text}&lt;/div&gt;;
};
</code></pre>
<p><code>Child</code> bileşeninin performansını <code>React.memo</code> kullanarak optimize edebiliriz:</p>
<pre><code class="language-javascript">const Child = React.memo(({ text }) =&gt; {
  console.log("Child component is rendering");
  return &lt;div&gt;{text}&lt;/div&gt;;
});
</code></pre>
<p>Bu şekilde, <code>Child</code> bileşeni yalnızca <code>text</code> özelliği değiştiğinde yeniden render edilecektir.</p>
<h2 id="2-reactpurecomponent"><a class="header" href="#2-reactpurecomponent">2. React.PureComponent</a></h2>
<p><code>React.PureComponent</code>, sınıf bileşenlerini optimize etmek için kullanılan bir yöntemdir. Bu yöntem, <code>shouldComponentUpdate</code> yaşam döngüsü yönteminde giriş özelliklerinin ve durumun yüzeysel bir karşılaştırmasını yapar.</p>
<h3 id="Örnek-9"><a class="header" href="#Örnek-9">Örnek:</a></h3>
<p>Basit bir sınıf bileşeni olan <code>Child</code>'ı ele alalım:</p>
<pre><code class="language-javascript">class Child extends React.Component {
  render() {
    console.log("Child component is rendering");
    return &lt;div&gt;{this.props.text}&lt;/div&gt;;
  }
}
</code></pre>
<p><code>Child</code> bileşeninin performansını <code>React.PureComponent</code> kullanarak optimize edebiliriz:</p>
<pre><code class="language-javascript">class Child extends React.PureComponent {
  render() {
    console.log("Child component is rendering");
    return &lt;div&gt;{this.props.text}&lt;/div&gt;;
  }
}
</code></pre>
<p>Bu şekilde, <code>Child</code> bileşeni yalnızca giriş özellikleri veya durum değiştiğinde yeniden render edilecektir.</p>
<h2 id="3-usecallback"><a class="header" href="#3-usecallback">3. useCallback</a></h2>
<p><code>useCallback</code>, işlevsel bileşenlerde inline fonksiyonları memoize etmeye yardımcı olan bir kancadır. Bu, her render işleminde yeni fonksiyon örneklerinin oluşturulmasını ve dolayısıyla alt bileşenlerde gereksiz yeniden render'ları önler.</p>
<h3 id="Örnek-10"><a class="header" href="#Örnek-10">Örnek:</a></h3>
<p>Bir butonla durumu güncelleyen <code>Parent</code> bileşeni ve bir fonksiyonu prop olarak alan <code>Child</code> bileşenini ele alalım:</p>
<pre><code class="language-javascript">const Parent = () =&gt; {
  const [count, setCount] = React.useState(0);

  const increment = () =&gt; {
    setCount(count + 1);
  };

  return (
    &lt;div&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
      &lt;Child onIncrement={increment} /&gt;
    &lt;/div&gt;
  );
};

const Child = ({ onIncrement }) =&gt; {
  console.log("Child component is rendering");
  return &lt;button onClick={onIncrement}&gt;Increment in Child&lt;/button&gt;;
};
</code></pre>
<p>Bu örnekte, <code>Parent</code> bileşeni her yeniden render edildiğinde <code>Child</code> bileşeni de yeniden render edilir çünkü <code>increment</code> fonksiyonu her seferinde yeniden oluşturulur. Bunu düzeltmek için <code>useCallback</code> kancasını kullanabiliriz:</p>
<pre><code class="language-javascript">const Parent = () =&gt; {
  const [count, setCount] = React.useState(0);

  const increment = React.useCallback(() =&gt; {
    setCount(count + 1);
  }, [count]);

  return (
    &lt;div&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
      &lt;Child onIncrement={increment} /&gt;
    &lt;/div&gt;
  );
};

const Child = ({ onIncrement }) =&gt; {
  console.log("Child component is rendering");
  return &lt;button onClick={onIncrement}&gt;Increment in Child&lt;/button&gt;;
};
</code></pre>
<p>Bu şekilde, <code>Child</code> bileşeni yalnızca <code>increment</code> fonksiyonu değiştiğinde yeniden render edilecektir.</p>
<h2 id="sonuç-35"><a class="header" href="#sonuç-35">Sonuç</a></h2>
<p>Bu eğitimde, React uygulamalarının performansını optimize etmek için kullanılan üç temel tekniği inceledik: <code>React.memo</code>, <code>React.PureComponent</code> ve <code>useCallback</code>. Bu teknikleri doğru bir şekilde kullanarak, React uygulamalarınızın performansını önemli ölçüde artırabilirsiniz. Bu yöntemleri uygularken dikkatli ve eleştirel bir yaklaşım benimsemek, daha verimli ve sürdürülebilir yazılım geliştirme süreçlerine katkıda bulunacaktır.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sosyal-medya-kontrol-paneli"><a class="header" href="#sosyal-medya-kontrol-paneli">Sosyal Medya Kontrol Paneli</a></h1>
<p>Bu eğitim, React kullanarak sosyal medya kontrol paneli oluşturmayı kapsamaktadır. İçeriğin, yazılım geliştirme alanında beklenen titizlik ve standartları yansıtmasını sağlamak amacıyla, adım adım ve detaylı bir şekilde hazırlanmıştır. Eğitimin sonunda, kullanıcılar fonksiyonel ve responsive bir sosyal medya kontrol paneli oluşturabileceklerdir.</p>
<h2 id="giriş-32"><a class="header" href="#giriş-32">Giriş</a></h2>
<p>Bu eğitimde, bir sosyal medya kontrol paneli oluşturmak için React bileşenleri ve durum yönetimi (state management) gibi konseptler kullanılacaktır. Kontrol paneli, sosyal medya hesaplarının beğeni sayılarını gösteren kartlar ve toplam beğeni sayısını hesaplayan bir bölüm içerecektir.</p>
<h2 id="gereksinimler-16"><a class="header" href="#gereksinimler-16">Gereksinimler</a></h2>
<ol>
<li>
<p><strong>React Uygulaması Oluşturma</strong></p>
<ul>
<li><code>SocialMediaCard</code> Bileşeni
<ul>
<li>Bir sosyal medya hesabının adını, beğeni sayısını ve simgesini (ikonunu) gösteren bir kart oluşturur.</li>
<li>Facebook, Twitter ve Instagram simgelerini gösterir.</li>
</ul>
</li>
<li><code>Metrics</code> Bileşeni
<ul>
<li>Tüm sosyal medya hesaplarının toplam beğeni sayısını gösteren bir bölüm oluşturur.</li>
<li><code>totalLikes</code> prop'u alır ve gösterir.</li>
</ul>
</li>
<li><code>Dashboard</code> Bileşeni
<ul>
<li><code>useState</code> kullanarak sosyal medya verilerini (mockSocialMediaData) yönetir.</li>
<li>Her sosyal medya hesabı kartını göstermek için <code>SocialMediaCard</code> bileşenini kullanır.</li>
<li>Belirli bir hesabın beğeni sayısını güncellemek için <code>useCallback</code> kullanarak <code>handleUpdateLikes</code> fonksiyonunu uygular.</li>
<li>Tüm hesapların toplam beğeni sayısını hesaplamak ve <code>Metrics</code> bileşenine geçmek için <code>useMemo</code> kullanır.</li>
<li>"Social Media Dashboard" başlığını gösterir.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>CSS Dosyası Oluşturma ve Bileşenleri Stilize Etme</strong></p>
<ul>
<li>Dashboard düzenini uygun marjin, padding ve arka plan renkleriyle stilize etme.</li>
<li>Kart stillerini, arka plan renkleri, border-radius ve box-shadow ile özelleştirme.</li>
<li>Beğeni butonunu (heart button) özel bir sınıfla (<code>custom-btn btn</code>) stilize etme.</li>
<li>Dashboard'un küçük cihazlarda da iyi görünmesini sağlamak için responsive CSS teknikleri kullanma.</li>
</ul>
</li>
<li>
<p><strong>Veri ve İkonları Kullanma</strong></p>
<ul>
<li>Sağlanan ikonları ve mockSocialMediaData'yı kullanarak kontrol panelini doldurma.</li>
</ul>
</li>
<li>
<p><strong>Responsive Tasarım</strong></p>
<ul>
<li>Dashboard'un küçük cihazlarda da düzenini ayarlayarak responsive olmasını sağlama.</li>
</ul>
</li>
</ol>
<h2 id="adım-adım-eğitim-2"><a class="header" href="#adım-adım-eğitim-2">Adım Adım Eğitim</a></h2>
<ol>
<li>
<p><strong>React Projesi Oluşturma</strong></p>
<pre><code class="language-bash">npx create-react-app social-media-dashboard
cd social-media-dashboard
</code></pre>
</li>
<li>
<p><strong>Gerekli Bileşenleri Oluşturma</strong></p>
<ul>
<li>
<p><code>SocialMediaCard</code> Bileşeni</p>
<pre><code class="language-jsx">// src/components/SocialMediaCard.js
import React from 'react';
import PropTypes from 'prop-types';
import './SocialMediaCard.css';

const SocialMediaCard = ({ name, likes, icon }) =&gt; {
  return (
    &lt;div className="social-media-card"&gt;
      &lt;img src={icon} alt={`${name} icon`} /&gt;
      &lt;h3&gt;{name}&lt;/h3&gt;
      &lt;p&gt;{likes} Likes&lt;/p&gt;
    &lt;/div&gt;
  );
};

SocialMediaCard.propTypes = {
  name: PropTypes.string.isRequired,
  likes: PropTypes.number.isRequired,
  icon: PropTypes.string.isRequired,
};

export default SocialMediaCard;
</code></pre>
</li>
<li>
<p><code>Metrics</code> Bileşeni</p>
<pre><code class="language-jsx">// src/components/Metrics.js
import React from 'react';
import PropTypes from 'prop-types';
import './Metrics.css';

const Metrics = ({ totalLikes }) =&gt; {
  return (
    &lt;div className="metrics"&gt;
      &lt;h2&gt;Total Likes: {totalLikes}&lt;/h2&gt;
    &lt;/div&gt;
  );
};

Metrics.propTypes = {
  totalLikes: PropTypes.number.isRequired,
};

export default Metrics;
</code></pre>
</li>
<li>
<p><code>Dashboard</code> Bileşeni</p>
<pre><code class="language-jsx">// src/components/Dashboard.js
import React, { useState, useCallback, useMemo } from 'react';
import SocialMediaCard from './SocialMediaCard';
import Metrics from './Metrics';
import './Dashboard.css';

const mockSocialMediaData = [
  { id: 1, name: 'Facebook', likes: 1200, icon: '/icons/facebook.png' },
  { id: 2, name: 'Twitter', likes: 800, icon: '/icons/twitter.png' },
  { id: 3, name: 'Instagram', likes: 1500, icon: '/icons/instagram.png' },
];

const Dashboard = () =&gt; {
  const [socialMediaData, setSocialMediaData] = useState(mockSocialMediaData);

  const handleUpdateLikes = useCallback((id, newLikes) =&gt; {
    setSocialMediaData(data =&gt;
      data.map(account =&gt; 
        account.id === id ? { ...account, likes: newLikes } : account
      )
    );
  }, []);

  const totalLikes = useMemo(() =&gt; 
    socialMediaData.reduce((total, account) =&gt; total + account.likes, 0), 
    [socialMediaData]
  );

  return (
    &lt;div className="dashboard"&gt;
      &lt;h1&gt;Social Media Dashboard&lt;/h1&gt;
      {socialMediaData.map(account =&gt; (
        &lt;SocialMediaCard 
          key={account.id} 
          name={account.name} 
          likes={account.likes} 
          icon={account.icon} 
        /&gt;
      ))}
      &lt;Metrics totalLikes={totalLikes} /&gt;
    &lt;/div&gt;
  );
};

export default Dashboard;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>CSS ile Stil Verme</strong></p>
<ul>
<li>
<p><code>src/components/SocialMediaCard.css</code></p>
<pre><code class="language-css">.social-media-card {
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 16px;
  margin: 16px;
  text-align: center;
}

.social-media-card img {
  width: 40px;
  height: 40px;
}
</code></pre>
</li>
<li>
<p><code>src/components/Metrics.css</code></p>
<pre><code class="language-css">.metrics {
  background-color: #f4f4f4;
  padding: 16px;
  text-align: center;
  margin: 16px 0;
}
</code></pre>
</li>
<li>
<p><code>src/components/Dashboard.css</code></p>
<pre><code class="language-css">.dashboard {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 16px;
}

@media (max-width: 600px) {
  .dashboard {
    padding: 8px;
  }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Projenin Depoya Yüklenmesi ve Canlı Demo</strong></p>
<ul>
<li>
<p>GitHub deposu oluşturun ve projeyi yükleyin:</p>
<pre><code class="language-bash">git init
git add .
git commit -m "Initial commit"
git branch -M main
git remote add origin &lt;repository-url&gt;
git push -u origin main
</code></pre>
</li>
<li>
<p>Canlı demoyu Netlify veya GitHub Pages kullanarak yapın.</p>
</li>
</ul>
</li>
</ol>
<p>Bu adımlar ve kod parçacıkları, sosyal medya kontrol paneli oluşturma sürecinde size rehberlik edecektir. Yazılım geliştirme standartlarına uygun olarak, bileşenlerin modüler ve yeniden kullanılabilir olmasına özen gösterilmiştir. Eğitim boyunca karşılaşılabilecek olası hatalar ve yanlış bilgiler eleştirel bir şekilde değerlendirilmiştir.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
